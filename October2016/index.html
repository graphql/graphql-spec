<!DOCTYPE html>
<!-- Built with spec-md -->
<html><head><meta charset="utf-8"><title>GraphQL</title><style>body {
  color: #333333;
  font: 13pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  margin: 6rem auto 3rem;
  max-width: 780px;
}


/* Links */

a {
  color: #3B5998;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}


/* Section headers */

h1, h2, h3, h4, h5, h6, h7, h8 {
  margin: 3rem 0 1em;
  position: relative;
}

h1 {
  font-size: 1.5em;
  margin: 8rem 0 2em;
}

h2 {
  font-size: 1.45em;
  margin: 8rem 0 1em;
}

h3 {
  font-size: 1.30em;
  margin: 5rem 0 1em;
}

h4 {
  font-size: 1.20em;
}

h5 {
  font-size: 1.12em;
}

h6, h7, h8 {
  font-size: 1.1em;
}

section .spec-secid {
  margin-right: 1ex;
  position: absolute;
  right: 100%;
  text-align: right;
  white-space: nowrap;
}

footer {
  font-size: 75%;
  opacity: 0.5;
  text-align: center;
  margin-top: 12rem;
}


/* Table of contents */

.spec-toc {
  margin: 1rem 0 3rem;
}

.spec-toc .title {
  content: 'Contents';
  display: block;
  font-weight: bold;
  margin: 3rem 0 1rem;
}

.spec-toc .spec-secid {
  margin-right: 1ex;
}

.spec-toc ol {
  list-style: none;
  padding-left: 0;
}

.spec-toc ol ol {
  list-style: none;
  padding-left: 2ex;
}

.spec-toc li {
  position: relative;
  padding: 5px 0 0 30px;
  margin: -5px 0 0 -30px;
}

.spec-toc a {
  color: #333333;
}

.spec-toc a:hover {
  text-decoration: none;
}

.spec-toc a .spec-secid {
  color: #3B5998;
}

.spec-toc a:hover .spec-secid {
  text-decoration: underline;
}

.spec-toc .toggle {
  display: none;
}

.spec-toc .toggle + label {
  cursor: pointer;
  left: 10px;
  opacity: 1;
  padding: 3px 5px 3px 6px;
  position: absolute;
  top: 8px;
  transform: rotate(0deg);
  transition: all 0.18s ease-in-out;
}

.spec-toc .toggle + label:after {
  border-color: transparent transparent transparent #bbc;
  border-style: solid;
  border-width: 6px 0 6px 7px;
  content: ' ';
  display: block;
  height: 0;
  width: 0;
}

.spec-toc .toggle:checked + label {
  transform: rotate(90deg);
}

.spec-toc li:not(:hover) > .toggle:checked + label {
  opacity: 0;
}

.spec-toc .toggle:not(:checked) ~ ol {
  max-height: 0;
  overflow: hidden;
}


/* Sidebar */

.spec-sidebar-toggle {
  display: none;
}

.spec-sidebar-toggle + label {
  position: fixed;
  right: 0;
  top: 0;
  padding: 10px 15px;
  font-size: 30px;
  color: rgba(0,0,0,0.7);
  z-index: 2;
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.spec-sidebar {
  display: none;
  position: fixed;
  right: 0;
  top: 0;
  width: 320px;
  font-size: 80%;
  overflow-y: scroll;
  height: 100%;
  padding: 0 0 5rem 30px;
  box-sizing: border-box;
  background: #f0f0f0;
}

.spec-sidebar-toggle:checked ~ .spec-sidebar {
  display: block;
  box-shadow:
    -1px 0 rgba(0,0,0,0.12),
    -4px 0 8px -2px rgba(0,0,0,0.05);
}

.spec-sidebar .viewing > a:after {
  color: #8b9;
  content: '\2022';
  margin-left: 1ex;
}

@media (min-width: 1240px) {
  .spec-sidebar-toggle + label {
    display: none;
  }

  .spec-sidebar {
    display: block;
    box-shadow:
      inset 1px 0 rgba(0,0,0,0.05),
      inset 4px 0 8px -2px rgba(0,0,0,0.08) !important;
  }

  body {
    padding-right: 300px;
  }
}


/* Notes */

.spec-note {
  background: #FEFEF3;
  border-left: solid 4px #F4E925;
  margin: 1em -1em;
  min-width: 416px;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-note::before {
  color: #6C6613;
  content: 'Note';
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}


/* Todos */

.spec-todo {
  color: #666666;
  margin: 1em 0 1em 5em;
  min-height: 1em;
}

.spec-todo::before {
  content: 'todo';
  display: block;
  float: left;
  margin-left: -5em;
  text-transform: uppercase;
}

/* Index table */

.spec-index ol {
  list-style-type: none;
  margin: 0 0 0 2rem;
  padding: 0;
  column-width: 210px;
  column-gap: 2rem;
}

.spec-index ol li {
  width: min-content;
}

/* Code */

code {
  background: #FAFAFA;
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  font-weight: inherit;
  margin: -2px -1px;
  padding: 3px 3px;
  white-space: pre;
}

pre code {
  background: none;
  font-weight: inherit;
  margin: 0;
  padding: 0;
}

pre {
  background: #FAFAFA;
  border-left: solid 4px #E9E9E9;
  margin: 1em -1em;
  min-width: 40ch;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-example {
  background: #FAFAFF;
  border-left: solid 4px #BBBBFF;
}

.spec-counter-example {
  background: #FFFAFA;
  border-left: solid 4px #FFBBBB;
}

.spec-example > a,
.spec-counter-example > a {
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}

.spec-counter-example > a {
  color: #98593b;
}


/* Tables */

table {
  border-collapse: collapse;
}

th {
  background-color: #F9F9F9;
}

td, th {
  border: 1px solid #D0D0D0;
  padding: 0.4em;
  vertical-align: baseline;
}


/* Edits */

ins {
  background-color: rgba(0, 200, 30, 0.08);
  text-decoration: none;
}

del {
  background-color: rgba(200, 0, 0, 0.08);
}

.spec-added, .spec-removed {
  border-left: 4px solid;
  margin-left: -18px;
  padding-left: 14px;
}

.spec-added {
  border-color: #396;
}

.spec-removed {
  border-color: #933;
  text-decoration: line-through;
}


/* Values */

.spec-keyword {
  font-weight: bold;
}

.spec-string {
  font-family: Consolas, Monaco, monospace;
  white-space: pre;
}

var {
  font-style: italic;
}


/* Grammar semantics, algorithms and calls */

.spec-semantic,
.spec-algo {
  margin: 1rem 0 1rem 2rem;
}

.spec-semantic > .spec-rhs {
  display: inline-block;
  margin-left: 1ex;
}

.spec-semantic > .spec-nt::after,
.spec-algo > .spec-call:first-child::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin-left: 1ex;
}

.spec-semantic ol, .spec-semantic ol ol ol ol,
.spec-algo ol, .spec-algo ol ol ol ol {
  list-style-type: decimal;
}

.spec-semantic ol ol, .spec-semantic ol ol ol ol ol,
.spec-algo ol ol, .spec-algo ol ol ol ol ol {
  list-style-type: lower-alpha;
}

.spec-semantic ol ol ol, .spec-semantic ol ol ol ol ol ol,
.spec-algo ol ol ol, .spec-algo ol ol ol ol ol ol {
  list-style-type: lower-roman;
}

.spec-call > a {
  color: inherit;
}


/* Grammar productions */

.spec-production {
  margin: 1rem 0 1rem 2rem;
}

.spec-production > .spec-nt::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin: 0 1ex;
}

.spec-semantic.d2 > .spec-nt::after,
.spec-production.d2 > .spec-nt::after {
  content: '::';
}

.spec-semantic.d3 > .spec-nt::after,
.spec-production.d3 > .spec-nt::after {
  content: ':::';
}

.spec-rhs {
  margin-left: 2rem;
}

.spec-oneof {
  display: inline;
}

.spec-oneof::before {
  content: 'one of';
  font-style: normal;
  font-weight: bold;
}

.spec-oneof > table {
  margin-left: 2rem;
}

.spec-oneof .spec-rhs {
  border: none;
  margin: 0;
  padding: 0 0.5em;
  vertical-align: baseline;
}

.spec-rhs .spec-constrained:not(:first-child),
.spec-rhs .spec-quantified:not(:first-child),
.spec-rhs .spec-nt:not(:first-child),
.spec-rhs .spec-t:not(:first-child),
.spec-rhs .spec-rx:not(:first-child),
.spec-rhs .spec-prose:not(:first-child),
.spec-rhs .spec-empty:not(:first-child),
.spec-rhs .spec-lookahead:not(:first-child) {
  margin-left: 1ex;
}

.spec-condition {
  font-size: 85%;
}

.spec-condition::before {
  content: '[+'
}

.spec-condition.not::before {
  content: '[~'
}

.spec-condition::after {
  content: ']'
}

.spec-empty,
.spec-prose {
  color: #666666;
}

.spec-nt {
  font-style: italic;
}

.spec-nt > a {
  color: inherit;
}

.spec-quantifiers,
.spec-params {
  font-size: 65%;
  font-style: normal;
  vertical-align: sub;
}

.spec-quantifier.list {
  color: #3348D3;
}

.spec-quantifier.optional {
  color: #83238E;
}

.spec-params,
.spec-condition {
  color: #1C7758;
}

.spec-params::before {
  content: '[';
}

.spec-params::after {
  content: ']';
}

.spec-quantifier:not(:last-child)::after,
.spec-param:not(:last-child)::after {
  color: #666666;
  content: ', ';
}

.spec-param.conditional::before {
  content: '?';
}

.spec-t, .spec-rx {
  color: #333333;
  font-family: monospace;
  font-weight: bold;
}

.spec-butnot::before {
  color: #666666;
  content: 'but not';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-butnot > *:not(:first-child)::before {
  color: #666666;
  content: 'or';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-rhs .spec-oneof::before,
.spec-rhs .spec-butnot::before {
  margin-left: 1ex;
}

.spec-lookahead > * {
  margin: 0 !important;
}

.spec-lookahead > *:not(:first-child)::before {
  color: #666666;
  content: ', ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead::before {
  color: #666666;
  content: '[lookahead = ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead.not::before {
  content: '[lookahead \2260  ';
}

.spec-lookahead.set::before {
  content: '[lookahead \2208  {';
  margin-right: 0;
}

.spec-lookahead.set.not::before {
  content: '[lookahead \2209  {';
}

.spec-lookahead::after {
  color: #666666;
  content: ']';
}

.spec-lookahead.set::after {
  content: '}]';
}
</style><style>/* Copied from node_modules/prismjs/themes/prism.css */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style></head><body><header><h1>GraphQL</h1><section id="intro"><p><em>Working Draft &ndash; October 2016</em></p><p><strong>Introduction</strong></p><p>This is a Draft RFC Specification for GraphQL, a query language created by Facebook in 2012 for describing the capabilities and requirements of data models for client&#8208;server applications. The development of this standard started in 2015. GraphQL is a new and evolving language and is not complete. Significant enhancement will continue in future editions of this specification.</p><p><strong>Copyright notice</strong></p><p>Copyright (c) 2015&#8208;2016, Facebook, Inc. All rights reserved.</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li><li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li><li>Neither the name Facebook nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li></ul><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &ldquo;AS IS&rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></section><nav class="spec-toc"><div class="title">Contents</div><ol><li><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a></li><li><a href="#sec-Language"><span class="spec-secid">2</span>Language</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2" /><label for="_toggle_2"></label><ol><li><a href="#sec-Source-Text"><span class="spec-secid">2.1</span>Source Text</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.1" /><label for="_toggle_2.1"></label><ol><li><a href="#sec-Unicode"><span class="spec-secid">2.1.1</span>Unicode</a></li><li><a href="#sec-White-Space"><span class="spec-secid">2.1.2</span>White Space</a></li><li><a href="#sec-Line-Terminators"><span class="spec-secid">2.1.3</span>Line Terminators</a></li><li><a href="#sec-Comments"><span class="spec-secid">2.1.4</span>Comments</a></li><li><a href="#sec-Insignificant-Commas"><span class="spec-secid">2.1.5</span>Insignificant Commas</a></li><li><a href="#sec-Source-Text.Lexical-Tokens"><span class="spec-secid">2.1.6</span>Lexical Tokens</a></li><li><a href="#sec-Source-Text.Ignored-Tokens"><span class="spec-secid">2.1.7</span>Ignored Tokens</a></li><li><a href="#sec-Punctuators"><span class="spec-secid">2.1.8</span>Punctuators</a></li><li><a href="#sec-Names"><span class="spec-secid">2.1.9</span>Names</a></li></ol></li><li><a href="#sec-Language.Query-Document"><span class="spec-secid">2.2</span>Query Document</a></li><li><a href="#sec-Language.Operations"><span class="spec-secid">2.3</span>Operations</a></li><li><a href="#sec-Selection-Sets"><span class="spec-secid">2.4</span>Selection Sets</a></li><li><a href="#sec-Language.Fields"><span class="spec-secid">2.5</span>Fields</a></li><li><a href="#sec-Language.Arguments"><span class="spec-secid">2.6</span>Arguments</a></li><li><a href="#sec-Field-Alias"><span class="spec-secid">2.7</span>Field Alias</a></li><li><a href="#sec-Language.Fragments"><span class="spec-secid">2.8</span>Fragments</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.8" /><label for="_toggle_2.8"></label><ol><li><a href="#sec-Type-Conditions"><span class="spec-secid">2.8.1</span>Type Conditions</a></li><li><a href="#sec-Inline-Fragments"><span class="spec-secid">2.8.2</span>Inline Fragments</a></li></ol></li><li><a href="#sec-Input-Values"><span class="spec-secid">2.9</span>Input Values</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.9" /><label for="_toggle_2.9"></label><ol><li><a href="#sec-Int-Value"><span class="spec-secid">2.9.1</span>Int Value</a></li><li><a href="#sec-Float-Value"><span class="spec-secid">2.9.2</span>Float Value</a></li><li><a href="#sec-Boolean-Value"><span class="spec-secid">2.9.3</span>Boolean Value</a></li><li><a href="#sec-String-Value"><span class="spec-secid">2.9.4</span>String Value</a></li><li><a href="#sec-Null-Value"><span class="spec-secid">2.9.5</span>Null Value</a></li><li><a href="#sec-Enum-Value"><span class="spec-secid">2.9.6</span>Enum Value</a></li><li><a href="#sec-List-Value"><span class="spec-secid">2.9.7</span>List Value</a></li><li><a href="#sec-Input-Object-Values"><span class="spec-secid">2.9.8</span>Input Object Values</a></li></ol></li><li><a href="#sec-Language.Variables"><span class="spec-secid">2.10</span>Variables</a></li><li><a href="#sec-Input-Types"><span class="spec-secid">2.11</span>Input Types</a></li><li><a href="#sec-Language.Directives"><span class="spec-secid">2.12</span>Directives</a></li></ol></li><li><a href="#sec-Type-System"><span class="spec-secid">3</span>Type System</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3" /><label for="_toggle_3"></label><ol><li><a href="#sec-Types"><span class="spec-secid">3.1</span>Types</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1" /><label for="_toggle_3.1"></label><ol><li><a href="#sec-Scalars"><span class="spec-secid">3.1.1</span>Scalars</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.1" /><label for="_toggle_3.1.1"></label><ol><li><a href="#sec-Int"><span class="spec-secid">3.1.1.1</span>Int</a></li><li><a href="#sec-Float"><span class="spec-secid">3.1.1.2</span>Float</a></li><li><a href="#sec-String"><span class="spec-secid">3.1.1.3</span>String</a></li><li><a href="#sec-Boolean"><span class="spec-secid">3.1.1.4</span>Boolean</a></li><li><a href="#sec-ID"><span class="spec-secid">3.1.1.5</span>ID</a></li></ol></li><li><a href="#sec-Objects"><span class="spec-secid">3.1.2</span>Objects</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.2" /><label for="_toggle_3.1.2"></label><ol><li><a href="#sec-Object-Field-Arguments"><span class="spec-secid">3.1.2.1</span>Object Field Arguments</a></li><li><a href="#sec-Object-Field-deprecation"><span class="spec-secid">3.1.2.2</span>Object Field deprecation</a></li><li><a href="#sec-Object-type-validation"><span class="spec-secid">3.1.2.3</span>Object type validation</a></li></ol></li><li><a href="#sec-Interfaces"><span class="spec-secid">3.1.3</span>Interfaces</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.3" /><label for="_toggle_3.1.3"></label><ol><li><a href="#sec-Interface-type-validation"><span class="spec-secid">3.1.3.1</span>Interface type validation</a></li></ol></li><li><a href="#sec-Unions"><span class="spec-secid">3.1.4</span>Unions</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.4" /><label for="_toggle_3.1.4"></label><ol><li><a href="#sec-Union-type-validation"><span class="spec-secid">3.1.4.1</span>Union type validation</a></li></ol></li><li><a href="#sec-Enums"><span class="spec-secid">3.1.5</span>Enums</a></li><li><a href="#sec-Input-Objects"><span class="spec-secid">3.1.6</span>Input Objects</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.6" /><label for="_toggle_3.1.6"></label><ol><li><a href="#sec-Input-Object-type-validation"><span class="spec-secid">3.1.6.1</span>Input Object type validation</a></li></ol></li><li><a href="#sec-Lists"><span class="spec-secid">3.1.7</span>Lists</a></li><li><a href="#sec-Types.Non-Null"><span class="spec-secid">3.1.8</span>Non-Null</a></li></ol></li><li><a href="#sec-Type-System.Directives"><span class="spec-secid">3.2</span>Directives</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.2" /><label for="_toggle_3.2"></label><ol><li><a href="#sec--skip"><span class="spec-secid">3.2.1</span>@skip</a></li><li><a href="#sec--include"><span class="spec-secid">3.2.2</span>@include</a></li></ol></li><li><a href="#sec-Initial-types"><span class="spec-secid">3.3</span>Initial types</a></li></ol></li><li><a href="#sec-Introspection"><span class="spec-secid">4</span>Introspection</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4" /><label for="_toggle_4"></label><ol><li><a href="#sec-General-Principles"><span class="spec-secid">4.1</span>General Principles</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.1" /><label for="_toggle_4.1"></label><ol><li><a href="#sec-Naming-conventions"><span class="spec-secid">4.1.1</span>Naming conventions</a></li><li><a href="#sec-Documentation"><span class="spec-secid">4.1.2</span>Documentation</a></li><li><a href="#sec-Deprecation"><span class="spec-secid">4.1.3</span>Deprecation</a></li><li><a href="#sec-Type-Name-Introspection"><span class="spec-secid">4.1.4</span>Type Name Introspection</a></li></ol></li><li><a href="#sec-Schema-Introspection"><span class="spec-secid">4.2</span>Schema Introspection</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.2" /><label for="_toggle_4.2"></label><ol><li><a href="#sec-The-__Type-Type"><span class="spec-secid">4.2.1</span>The __Type Type</a></li><li><a href="#sec-Type-Kinds"><span class="spec-secid">4.2.2</span>Type Kinds</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.2.2" /><label for="_toggle_4.2.2"></label><ol><li><a href="#sec-Scalar"><span class="spec-secid">4.2.2.1</span>Scalar</a></li><li><a href="#sec-Object"><span class="spec-secid">4.2.2.2</span>Object</a></li><li><a href="#sec-Union"><span class="spec-secid">4.2.2.3</span>Union</a></li><li><a href="#sec-Interface"><span class="spec-secid">4.2.2.4</span>Interface</a></li><li><a href="#sec-Enum"><span class="spec-secid">4.2.2.5</span>Enum</a></li><li><a href="#sec-Input-Object"><span class="spec-secid">4.2.2.6</span>Input Object</a></li><li><a href="#sec-List"><span class="spec-secid">4.2.2.7</span>List</a></li><li><a href="#sec-Type-Kinds.Non-Null"><span class="spec-secid">4.2.2.8</span>Non-Null</a></li><li><a href="#sec-Combining-List-and-Non-Null"><span class="spec-secid">4.2.2.9</span>Combining List and Non-Null</a></li></ol></li><li><a href="#sec-The-__Field-Type"><span class="spec-secid">4.2.3</span>The __Field Type</a></li><li><a href="#sec-The-__InputValue-Type"><span class="spec-secid">4.2.4</span>The __InputValue Type</a></li><li><a href="#sec-The-__Directive-Type"><span class="spec-secid">4.2.5</span>The __Directive Type</a></li></ol></li></ol></li><li><a href="#sec-Validation"><span class="spec-secid">5</span>Validation</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5" /><label for="_toggle_5"></label><ol><li><a href="#sec-Validation.Operations"><span class="spec-secid">5.1</span>Operations</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1" /><label for="_toggle_5.1"></label><ol><li><a href="#sec-Named-Operation-Definitions"><span class="spec-secid">5.1.1</span>Named Operation Definitions</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1.1" /><label for="_toggle_5.1.1"></label><ol><li><a href="#sec-Operation-Name-Uniqueness"><span class="spec-secid">5.1.1.1</span>Operation Name Uniqueness</a></li></ol></li><li><a href="#sec-Anonymous-Operation-Definitions"><span class="spec-secid">5.1.2</span>Anonymous Operation Definitions</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1.2" /><label for="_toggle_5.1.2"></label><ol><li><a href="#sec-Lone-Anonymous-Operation"><span class="spec-secid">5.1.2.1</span>Lone Anonymous Operation</a></li></ol></li></ol></li><li><a href="#sec-Validation.Fields"><span class="spec-secid">5.2</span>Fields</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.2" /><label for="_toggle_5.2"></label><ol><li><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types"><span class="spec-secid">5.2.1</span>Field Selections on Objects, Interfaces, and Unions Types</a></li><li><a href="#sec-Field-Selection-Merging"><span class="spec-secid">5.2.2</span>Field Selection Merging</a></li><li><a href="#sec-Leaf-Field-Selections"><span class="spec-secid">5.2.3</span>Leaf Field Selections</a></li></ol></li><li><a href="#sec-Validation.Arguments"><span class="spec-secid">5.3</span>Arguments</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.3" /><label for="_toggle_5.3"></label><ol><li><a href="#sec-Argument-Names"><span class="spec-secid">5.3.1</span>Argument Names</a></li><li><a href="#sec-Argument-Uniqueness"><span class="spec-secid">5.3.2</span>Argument Uniqueness</a></li><li><a href="#sec-Argument-Values-Type-Correctness"><span class="spec-secid">5.3.3</span>Argument Values Type Correctness</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.3.3" /><label for="_toggle_5.3.3"></label><ol><li><a href="#sec-Compatible-Values"><span class="spec-secid">5.3.3.1</span>Compatible Values</a></li><li><a href="#sec-Required-Non-Null-Arguments"><span class="spec-secid">5.3.3.2</span>Required Non-Null Arguments</a></li></ol></li></ol></li><li><a href="#sec-Validation.Fragments"><span class="spec-secid">5.4</span>Fragments</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4" /><label for="_toggle_5.4"></label><ol><li><a href="#sec-Fragment-Declarations"><span class="spec-secid">5.4.1</span>Fragment Declarations</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.1" /><label for="_toggle_5.4.1"></label><ol><li><a href="#sec-Fragment-Name-Uniqueness"><span class="spec-secid">5.4.1.1</span>Fragment Name Uniqueness</a></li><li><a href="#sec-Fragment-Spread-Type-Existence"><span class="spec-secid">5.4.1.2</span>Fragment Spread Type Existence</a></li><li><a href="#sec-Fragments-On-Composite-Types"><span class="spec-secid">5.4.1.3</span>Fragments On Composite Types</a></li><li><a href="#sec-Fragments-Must-Be-Used"><span class="spec-secid">5.4.1.4</span>Fragments Must Be Used</a></li></ol></li><li><a href="#sec-Fragment-Spreads"><span class="spec-secid">5.4.2</span>Fragment Spreads</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.2" /><label for="_toggle_5.4.2"></label><ol><li><a href="#sec-Fragment-spread-target-defined"><span class="spec-secid">5.4.2.1</span>Fragment spread target defined</a></li><li><a href="#sec-Fragment-spreads-must-not-form-cycles"><span class="spec-secid">5.4.2.2</span>Fragment spreads must not form cycles</a></li><li><a href="#sec-Fragment-spread-is-possible"><span class="spec-secid">5.4.2.3</span>Fragment spread is possible</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.2.3" /><label for="_toggle_5.4.2.3"></label><ol><li><a href="#sec-Object-Spreads-In-Object-Scope"><span class="spec-secid">5.4.2.3.1</span>Object Spreads In Object Scope</a></li><li><a href="#sec-Abstract-Spreads-in-Object-Scope"><span class="spec-secid">5.4.2.3.2</span>Abstract Spreads in Object Scope</a></li><li><a href="#sec-Object-Spreads-In-Abstract-Scope"><span class="spec-secid">5.4.2.3.3</span>Object Spreads In Abstract Scope</a></li><li><a href="#sec-Abstract-Spreads-in-Abstract-Scope"><span class="spec-secid">5.4.2.3.4</span>Abstract Spreads in Abstract Scope</a></li></ol></li></ol></li></ol></li><li><a href="#sec-Values"><span class="spec-secid">5.5</span>Values</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.5" /><label for="_toggle_5.5"></label><ol><li><a href="#sec-Input-Object-Field-Uniqueness"><span class="spec-secid">5.5.1</span>Input Object Field Uniqueness</a></li></ol></li><li><a href="#sec-Validation.Directives"><span class="spec-secid">5.6</span>Directives</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.6" /><label for="_toggle_5.6"></label><ol><li><a href="#sec-Directives-Are-Defined"><span class="spec-secid">5.6.1</span>Directives Are Defined</a></li><li><a href="#sec-Directives-Are-In-Valid-Locations"><span class="spec-secid">5.6.2</span>Directives Are In Valid Locations</a></li><li><a href="#sec-Directives-Are-Unique-Per-Location"><span class="spec-secid">5.6.3</span>Directives Are Unique Per Location</a></li></ol></li><li><a href="#sec-Validation.Variables"><span class="spec-secid">5.7</span>Variables</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.7" /><label for="_toggle_5.7"></label><ol><li><a href="#sec-Variable-Uniqueness"><span class="spec-secid">5.7.1</span>Variable Uniqueness</a></li><li><a href="#sec-Variable-Default-Values-Are-Correctly-Typed"><span class="spec-secid">5.7.2</span>Variable Default Values Are Correctly Typed</a></li><li><a href="#sec-Variables-Are-Input-Types"><span class="spec-secid">5.7.3</span>Variables Are Input Types</a></li><li><a href="#sec-All-Variable-Uses-Defined"><span class="spec-secid">5.7.4</span>All Variable Uses Defined</a></li><li><a href="#sec-All-Variables-Used"><span class="spec-secid">5.7.5</span>All Variables Used</a></li><li><a href="#sec-All-Variable-Usages-are-Allowed"><span class="spec-secid">5.7.6</span>All Variable Usages are Allowed</a></li></ol></li></ol></li><li><a href="#sec-Execution"><span class="spec-secid">6</span>Execution</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6" /><label for="_toggle_6"></label><ol><li><a href="#sec-Executing-Requests"><span class="spec-secid">6.1</span>Executing Requests</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.1" /><label for="_toggle_6.1"></label><ol><li><a href="#sec-Validating-Requests"><span class="spec-secid">6.1.1</span>Validating Requests</a></li><li><a href="#sec-Coercing-Variable-Values"><span class="spec-secid">6.1.2</span>Coercing Variable Values</a></li></ol></li><li><a href="#sec-Executing-Operations"><span class="spec-secid">6.2</span>Executing Operations</a></li><li><a href="#sec-Executing-Selection-Sets"><span class="spec-secid">6.3</span>Executing Selection Sets</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.3" /><label for="_toggle_6.3"></label><ol><li><a href="#sec-Normal-and-Serial-Execution"><span class="spec-secid">6.3.1</span>Normal and Serial Execution</a></li><li><a href="#sec-Field-Collection"><span class="spec-secid">6.3.2</span>Field Collection</a></li></ol></li><li><a href="#sec-Executing-Fields"><span class="spec-secid">6.4</span>Executing Fields</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.4" /><label for="_toggle_6.4"></label><ol><li><a href="#sec-Coercing-Field-Arguments"><span class="spec-secid">6.4.1</span>Coercing Field Arguments</a></li><li><a href="#sec-Value-Resolution"><span class="spec-secid">6.4.2</span>Value Resolution</a></li><li><a href="#sec-Value-Completion"><span class="spec-secid">6.4.3</span>Value Completion</a></li><li><a href="#sec-Errors-and-Non-Nullability"><span class="spec-secid">6.4.4</span>Errors and Non-Nullability</a></li></ol></li></ol></li><li><a href="#sec-Response"><span class="spec-secid">7</span>Response</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7" /><label for="_toggle_7"></label><ol><li><a href="#sec-Serialization-Format"><span class="spec-secid">7.1</span>Serialization Format</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7.1" /><label for="_toggle_7.1"></label><ol><li><a href="#sec-JSON-Serialization"><span class="spec-secid">7.1.1</span>JSON Serialization</a></li></ol></li><li><a href="#sec-Response-Format"><span class="spec-secid">7.2</span>Response Format</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7.2" /><label for="_toggle_7.2"></label><ol><li><a href="#sec-Data"><span class="spec-secid">7.2.1</span>Data</a></li><li><a href="#sec-Errors"><span class="spec-secid">7.2.2</span>Errors</a></li></ol></li></ol></li><li><a href="#sec-Appendix-Notation-Conventions"><span class="spec-secid">A</span>Appendix: Notation Conventions</a><input hidden class="toggle" type="checkbox" checked id="_toggle_A" /><label for="_toggle_A"></label><ol><li><a href="#sec-Context-Free-Grammar"><span class="spec-secid">A.1</span>Context-Free Grammar</a></li><li><a href="#sec-Lexical-and-Syntactical-Grammar"><span class="spec-secid">A.2</span>Lexical and Syntactical Grammar</a></li><li><a href="#sec-Grammar-Notation"><span class="spec-secid">A.3</span>Grammar Notation</a></li><li><a href="#sec-Grammar-Semantics"><span class="spec-secid">A.4</span>Grammar Semantics</a></li><li><a href="#sec-Algorithms"><span class="spec-secid">A.5</span>Algorithms</a></li></ol></li><li><a href="#sec-Appendix-Grammar-Summary"><span class="spec-secid">B</span>Appendix: Grammar Summary</a><input hidden class="toggle" type="checkbox" checked id="_toggle_B" /><label for="_toggle_B"></label><ol><li><a href="#sec-Appendix-Grammar-Summary.Ignored-Tokens"><span class="spec-secid">B.1</span>Ignored Tokens</a></li><li><a href="#sec-Appendix-Grammar-Summary.Lexical-Tokens"><span class="spec-secid">B.2</span>Lexical Tokens</a></li><li><a href="#sec-Appendix-Grammar-Summary.Query-Document"><span class="spec-secid">B.3</span>Query Document</a></li></ol></li><li><a href="#index"><span class="spec-secid">ยง</span>Index</a></li></ol></nav></header><section id="sec-Overview" secid="1"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Overview">1</a></span>Overview</h2><p>GraphQL is a query language designed to build client applications by providing an intuitive and flexible syntax and system for describing their data requirements and interactions.</p><p>For example, this GraphQL request will receive the name of the user with id 4 from the Facebook implementation of GraphQL.</p><pre><code><span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Which produces the resulting data (in JSON):</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"user"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>GraphQL is not a programming language capable of arbitrary computation, but is instead a language used to query application servers that have capabilities defined in this specification. GraphQL does not mandate a particular programming language or storage system for application servers that implement it. Instead, application servers take their capabilities and map them to a uniform language, type system, and philosophy that GraphQL encodes. This provides a unified interface friendly to product development and a powerful platform for tool&#8208;building.</p><p>GraphQL has a number of design principles:</p><ul><li><strong>Hierarchical</strong>: Most product development today involves the creation and manipulation of view hierarchies. To achieve congruence with the structure of these applications, a GraphQL query itself is structured hierarchically. The query is shaped just like the data it returns. It is a natural way for clients to describe data requirements.</li><li><strong>Product&#8208;centric</strong>: GraphQL is unapologetically driven by the requirements of views and the front&#8208;end engineers that write them. GraphQL starts with their way of thinking and requirements and build the language and runtime necessary to enable that.</li><li><strong>Strong&#8208;typing</strong>: Every GraphQL server defines an application&#8208;specific type system. Queries are executed within the context of that type system. Given a query, tools can ensure that the query is both syntactically correct and valid within the GraphQL type system before execution, i.e. at development time, and the server can make certain guarantees about the shape and nature of the response.</li><li><strong>Client&#8208;specified queries</strong>: Through its type system, a GraphQL server publishes the capabilities that its clients are allowed to consume. It is the client that is responsible for specifying exactly how it will consume those published capabilities. These queries are specified at field&#8208;level granularity. In the majority of client&#8208;server applications written without GraphQL, the server determines the data returned in its various scripted endpoints. A GraphQL query, on the other hand, returns exactly what a client asks for and no more.</li><li><strong>Introspective</strong>: GraphQL is introspective. A GraphQL server&rsquo;s type system must be queryable by the GraphQL language itself, as will be described in this specification. GraphQL introspection serves as a powerful platform for building common tools and client software libraries.</li></ul><p>Because of these principles, GraphQL is a powerful and productive environment for building client applications. Product developers and designers building applications against working GraphQL servers -- supported with quality tools -- can quickly become productive without reading extensive documentation and with little or no formal training. To enable that experience, there must be those that build those servers and tools.</p><p>The following formal specification serves as a reference for those builders. It describes the language and its grammar, the type system and the introspection system used to query it, and the execution and validation engines with the algorithms to power them. The goal of this specification is to provide a foundation and framework for an ecosystem of GraphQL tools, client libraries, and server implementations -- spanning both organizations and platforms -- that has yet to be built. We look forward to working with the community in order to do that. </p></section><section id="sec-Language" secid="2"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Language">2</a></span>Language</h2><p>Clients use the GraphQL query language to make requests to a GraphQL service. We refer to these request sources as documents. A document may contain operations (queries and mutations are both operations) as well as fragments, a common unit of composition allowing for query reuse.</p><p>A GraphQL document is defined as a syntactic grammar where terminal symbols are tokens (indivisible lexical units). These tokens are defined in a lexical grammar which matches patterns of source characters (defined by a double&#8208;colon <code>::</code>).</p><section id="sec-Source-Text" secid="2.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text">2.1</a></span>Source Text</h3><div class="spec-production d2" id="SourceCharacter"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-rx">/[\u0009\u000A\u000D\u0020-\uFFFF]/</span></div></div><p>GraphQL documents are expressed as a sequence of <a href="http://unicode.org/standard/standard.html">Unicode</a> characters. However, with few exceptions, most of GraphQL is expressed only in the original non&#8208;control ASCII range so as to be as widely compatible with as many existing tools, languages, and serialization formats as possible and avoid display issues in text editors and source control.</p><section id="sec-Unicode" secid="2.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Unicode">2.1.1</a></span>Unicode</h4><div class="spec-production d2" id="UnicodeBOM"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span><div class="spec-rhs"><span class="spec-prose">Byte Order Mark (U+FEFF)</span></div></div><p>Non&#8208;ASCII Unicode characters may freely appear within <span class="spec-nt"><a href="#StringValue">StringValue</a></span> and <span class="spec-nt"><a href="#Comment">Comment</a></span> portions of GraphQL.</p><p>The &ldquo;Byte Order Mark&rdquo; is a special Unicode character which may appear at the beginning of a file containing Unicode which programs may use to determine the fact that the text stream is Unicode, what endianness the text stream is in, and which of several Unicode encodings to interpret.</p></section><section id="sec-White-Space" secid="2.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-White-Space">2.1.2</a></span>White Space</h4><div class="spec-production d2" id="WhiteSpace"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Horizontal Tab (U+0009)</span></div><div class="spec-rhs"><span class="spec-prose">Space (U+0020)</span></div></div><p>White space is used to improve legibility of source text and act as separation between tokens, and any amount of white space may appear before or after any token. White space between tokens is not significant to the semantic meaning of a GraphQL query document, however white space characters may appear within a <span class="spec-nt">String</span> or <span class="spec-nt"><a href="#Comment">Comment</a></span> token.</p><div class="spec-note">GraphQL intentionally does not consider Unicode &ldquo;Zs&rdquo; category characters as white&#8208;space, avoiding misinterpretation by text editors and source control tools.</div></section><section id="sec-Line-Terminators" secid="2.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Line-Terminators">2.1.3</a></span>Line Terminators</h4><div class="spec-production d2" id="LineTerminator"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span><div class="spec-rhs"><span class="spec-prose">New Line (U+000A)</span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-lookahead not"><span class="spec-prose">New Line (U+000A)</span></span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-prose">New Line (U+000A)</span></div></div><p>Like white space, line terminators are used to improve the legibility of source text, any amount may appear before or after any other token and have no significance to the semantic meaning of a GraphQL query document. Line terminators are not found within any other token.</p><div class="spec-note">Any error reporting which provide the line number in the source of the offending syntax should use the preceding amount of <span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span> to produce the line number.</div></section><section id="sec-Comments" secid="2.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Comments">2.1.4</a></span>Comments</h4><div class="spec-production d2" id="Comment"><span class="spec-nt"><a href="#Comment">Comment</a></span><div class="spec-rhs"><span class="spec-t">#</span><span class="spec-quantified"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production d2" id="CommentChar"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div></div><p>GraphQL source documents may contain single&#8208;line comments, starting with the <span class="spec-t">#</span> marker.</p><p>A comment can contain any Unicode code point except <span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span> so a comment always consists of all code points starting with the <span class="spec-t">#</span> character up to but not including the line terminator.</p><p>Comments behave like white space and may appear after any token, or before a line terminator, and have no significance to the semantic meaning of a GraphQL query document.</p></section><section id="sec-Insignificant-Commas" secid="2.1.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Insignificant-Commas">2.1.5</a></span>Insignificant Commas</h4><div class="spec-production d2" id="Comma"><span class="spec-nt"><a href="#Comma">Comma</a></span><div class="spec-rhs"><span class="spec-t">,</span></div></div><p>Similar to white space and line terminators, commas (<span class="spec-t">,</span>) are used to improve the legibility of source text and separate lexical tokens but are otherwise syntactically and semantically insignificant within GraphQL query documents.</p><p>Non&#8208;significant comma characters ensure that the absence or presence of a comma does not meaningfully alter the interpreted syntax of the document, as this can be a common user&#8208;error in other languages. It also allows for the stylistic use of either trailing commas or line&#8208;terminators as list delimiters which are both often desired for legibility and maintainability of source code.</p></section><section id="sec-Source-Text.Lexical-Tokens" secid="2.1.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text.Lexical-Tokens">2.1.6</a></span>Lexical Tokens</h4><div class="spec-production d2" id="Token"><span class="spec-nt"><a href="#Token">Token</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div></div><p>A GraphQL document is comprised of several kinds of indivisible lexical tokens defined here in a lexical grammar by patterns of source Unicode characters.</p><p>Tokens are later used as terminal symbols in a GraphQL query document syntactic grammars.</p></section><section id="sec-Source-Text.Ignored-Tokens" secid="2.1.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text.Ignored-Tokens">2.1.7</a></span>Ignored Tokens</h4><div class="spec-production d2" id="Ignored"><span class="spec-nt"><a href="#Ignored">Ignored</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comment">Comment</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comma">Comma</a></span></div></div><p>Before and after every lexical token may be any amount of ignored tokens including <span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span> and <span class="spec-nt"><a href="#Comment">Comment</a></span>. No ignored regions of a source document are significant, however ignored source characters may appear within a lexical token in a significant way, for example a <span class="spec-nt">String</span> may contain white space characters.</p><p>No characters are ignored while parsing a given token, as an example no white space characters are permitted between the characters defining a <span class="spec-nt"><a href="#FloatValue">FloatValue</a></span>.</p></section><section id="sec-Punctuators" secid="2.1.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Punctuators">2.1.8</a></span>Punctuators</h4><div class="spec-production d2" id="Punctuator"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">!</span></td><td class="spec-rhs"><span class="spec-t">$</span></td><td class="spec-rhs"><span class="spec-t">(</span></td><td class="spec-rhs"><span class="spec-t">)</span></td><td class="spec-rhs"><span class="spec-t">...</span></td><td class="spec-rhs"><span class="spec-t">:</span></td><td class="spec-rhs"><span class="spec-t">=</span></td><td class="spec-rhs"><span class="spec-t">@</span></td><td class="spec-rhs"><span class="spec-t">[</span></td><td class="spec-rhs"><span class="spec-t">]</span></td><td class="spec-rhs"><span class="spec-t">{</span></td><td class="spec-rhs"><span class="spec-t">|</span></td><td class="spec-rhs"><span class="spec-t">}</span></td></tr></table></div></div><p>GraphQL documents include punctuation in order to describe structure. GraphQL is a data description language and not a programming language, therefore GraphQL lacks the punctuation often used to describe mathematical expressions.</p></section><section id="sec-Names" secid="2.1.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Names">2.1.9</a></span>Names</h4><div class="spec-production d2" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span><div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div></div><p>GraphQL query documents are full of named things: operations, fields, arguments, directives, fragments, and variables. All names must follow the same grammatical form.</p><p>Names in GraphQL are case&#8208;sensitive. That is to say <code>name</code>, <code>Name</code>, and <code>NAME</code> all refer to different names. Underscores are significant, which means <code>other_name</code> and <code>othername</code> are two different names.</p><p>Names in GraphQL are limited to this <acronym>ASCII</acronym> subset of possible characters to support interoperation with as many other systems as possible.</p></section></section><section id="sec-Language.Query-Document" secid="2.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Query-Document">2.2</a></span>Query Document</h3><div class="spec-production" id="Document"><span class="spec-nt"><a href="#Document">Document</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Definition">Definition</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production" id="Definition"><span class="spec-nt"><a href="#Definition">Definition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span></div></div><p>A GraphQL query document describes a complete file or request string received by a GraphQL service. A document contains multiple definitions of Operations and Fragments. GraphQL query documents are only executable by a server if they contain an operation. However documents which do not contain operations may still be parsed and validated to allow client to represent a single request across many documents.</p><p>If a document contains only one operation, that operation may be unnamed or represented in the shorthand form, which omits both the query keyword and operation name. Otherwise, if a GraphQL query document contains multiple operations, each operation must be named. When submitting a query document with multiple operations to a GraphQL service, the name of the desired operation to be executed must also be provided.</p></section><section id="sec-Language.Operations" secid="2.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Operations">2.3</a></span>Operations</h3><div class="spec-production" id="OperationDefinition"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="OperationType"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">query</span></td><td class="spec-rhs"><span class="spec-t">mutation</span></td></tr></table></div></div><p>There are two types of operations that GraphQL models:</p><ul><li>query &ndash; a read&#8208;only fetch.</li><li>mutation &ndash; a write followed by a fetch.</li></ul><p>Each operation is represented by an optional operation name and a selection set.</p><p>For example, this mutation operation might &ldquo;like&rdquo; a story and then retrieve the new number of likes:</p><pre><code>mutation {
  likeStory(storyID: 12345) {
    story {
      likeCount
    }
  }
}
</code></pre><p><strong>Query shorthand</strong></p><p>If a document contains only one query operation, and that query defines no variables and contains no directives, that operation may be represented in a short&#8208;hand form which omits the query keyword and query name.</p><p>For example, this unnamed query operation is written via query shorthand.</p><pre><code><span class="token punctuation">{</span>
  field
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">many examples below will use the query short&#8208;hand syntax.</div></section><section id="sec-Selection-Sets" secid="2.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Selection-Sets">2.4</a></span>Selection Sets</h3><div class="spec-production" id="SelectionSet"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#Selection">Selection</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="Selection"><span class="spec-nt"><a href="#Selection">Selection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Field">Field</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span></div></div><p>An operation selects the set of information it needs, and will receive exactly that information and nothing more, avoiding over&#8208;fetching and under&#8208;fetching data.</p><pre><code><span class="token punctuation">{</span>
  id
  firstName
  lastName
<span class="token punctuation">}</span>
</code></pre><p>In this query, the <code>id</code>, <code>firstName</code>, and <code>lastName</code> fields form a selection set. Selection sets may also contain fragment references.</p></section><section id="sec-Language.Fields" secid="2.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Fields">2.5</a></span>Fields</h3><div class="spec-production" id="Field"><span class="spec-nt"><a href="#Field">Field</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Alias">Alias</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><p>A selection set is primarily composed of fields. A field describes one discrete piece of information available to request within a selection set.</p><p>Some fields describe complex data or relationships to other data. In order to further explore this data, a field may itself contain a selection set, allowing for deeply nested requests. All GraphQL operations must specify their selections down to fields which return scalar values to ensure an unambiguously shaped response.</p><p>For example, this operation selects fields of complex data and relationships down to scalar values.</p><pre><code><span class="token punctuation">{</span>
  me <span class="token punctuation">{</span>
    id
    firstName
    lastName
    birthday <span class="token punctuation">{</span>
      month
      day
    <span class="token punctuation">}</span>
    friends <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Fields in the top&#8208;level selection set of an operation often represent some information that is globally accessible to your application and its current viewer. Some typical examples of these top fields include references to a current logged&#8208;in viewer, or accessing certain types of data referenced by a unique identifier.</p><pre><code><span class="token comment" spellcheck="true"># `me` could represent the currently logged in viewer.</span>
<span class="token punctuation">{</span>
  me <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true"># `user` represents one of many users in a graph of data, referred to by a</span>
<span class="token comment" spellcheck="true"># unique identifier.</span>
<span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Language.Arguments" secid="2.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Arguments">2.6</a></span>Arguments</h3><div class="spec-production" id="Arguments"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-quantified"><span class="spec-nt"><a href="#Argument">Argument</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="Argument"><span class="spec-nt"><a href="#Argument">Argument</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a></span></div></div><p>Fields are conceptually functions which return values, and occasionally accept arguments which alter their behavior. These arguments often map directly to function arguments within a GraphQL server&rsquo;s implementation.</p><p>In this example, we want to query a specific user (requested via the <code>id</code> argument) and their profile picture of a specific <code>size</code>:</p><pre><code><span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
    profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Many arguments can exist for a given field:</p><pre><code><span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
    profilePic<span class="token punctuation">(</span><span class="token attr-name">width</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token attr-name">height</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Arguments are unordered</strong></p><p>Arguments may be provided in any syntactic order and maintain identical semantic meaning.</p><p>These two queries are semantically identical:</p><pre><code><span class="token punctuation">{</span>
  picture<span class="token punctuation">(</span><span class="token attr-name">width</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token attr-name">height</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token punctuation">{</span>
  picture<span class="token punctuation">(</span><span class="token attr-name">height</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token attr-name">width</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Field-Alias" secid="2.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Field-Alias">2.7</a></span>Field Alias</h3><div class="spec-production" id="Alias"><span class="spec-nt"><a href="#Alias">Alias</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span></div></div><p>By default, the key in the response object will use the field name queried. However, you can define a different name by specifying an alias.</p><p>In this example, we can fetch two profile pictures of different sizes and ensure the resulting object will not have duplicate keys:</p><pre><code><span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
    <span class="token attr-name">smallPic</span><span class="token punctuation">:</span> profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">64</span><span class="token punctuation">)</span>
    <span class="token attr-name">bigPic</span><span class="token punctuation">:</span> profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">1024</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Which returns the result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"user"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span><span class="token punctuation">,</span>
    <span class="token string">"smallPic"</span><span class="token punctuation">:</span> <span class="token string">"https://cdn.site.io/pic-4-64.jpg"</span><span class="token punctuation">,</span>
    <span class="token string">"bigPic"</span><span class="token punctuation">:</span> <span class="token string">"https://cdn.site.io/pic-4-1024.jpg"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Since the top level of a query is a field, it also can be given an alias:</p><pre><code><span class="token punctuation">{</span>
  <span class="token attr-name">zuck</span><span class="token punctuation">:</span> user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Returns the result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"zuck"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>A field&rsquo;s response key is its alias if an alias is provided, and it is otherwise the field&rsquo;s name.</p></section><section id="sec-Language.Fragments" secid="2.8"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Fragments">2.8</a></span>Fragments</h3><div class="spec-production" id="FragmentSpread"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production" id="FragmentDefinition"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span><div class="spec-rhs"><span class="spec-t">fragment</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentName"><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">on</span></span></span></div></div><p>Fragments are the primary unit of composition in GraphQL.</p><p>Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the document. Inline Fragments can be used directly within a selection to condition upon a type condition when querying against an interface or union.</p><p>For example, if we wanted to fetch some common information about mutual friends as well as friends of some user:</p><pre><code><span class="token keyword">query</span> noFragments <span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    friends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      id
      name
      profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    mutualFriends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      id
      name
      profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The repeated fields could be extracted into a fragment and composed by a parent fragment or query.</p><pre><code><span class="token keyword">query</span> withFragments <span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    friends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>friendFields
    <span class="token punctuation">}</span>
    mutualFriends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>friendFields
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> friendFields <span class="token keyword">on</span> User <span class="token punctuation">{</span>
  id
  name
  profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>Fragments are consumed by using the spread operator (<code>...</code>). All fields selected by the fragment will be added to the query field selection at the same level as the fragment invocation. This happens through multiple levels of fragment spreads.</p><p>For example:</p><pre><code><span class="token keyword">query</span> withNestedFragments <span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    friends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>friendFields
    <span class="token punctuation">}</span>
    mutualFriends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>friendFields
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> friendFields <span class="token keyword">on</span> User <span class="token punctuation">{</span>
  id
  name
  <span class="token operator">...</span>standardProfilePic
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> standardProfilePic <span class="token keyword">on</span> User <span class="token punctuation">{</span>
  profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>The queries <code>noFragments</code>, <code>withFragments</code>, and <code>withNestedFragments</code> all produce the same response object.</p><section id="sec-Type-Conditions" secid="2.8.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Conditions">2.8.1</a></span>Type Conditions</h4><div class="spec-production" id="TypeCondition"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><div class="spec-rhs"><span class="spec-t">on</span><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div></div><p>Fragments must specify the type they apply to. In this example, <code>friendFields</code> can be used in the context of querying a <code>User</code>.</p><p>Fragments cannot be specified on any input value (scalar, enumeration, or input object).</p><p>Fragments can be specified on object types, interfaces, and unions.</p><p>Selections within fragments only return values when concrete type of the object it is operating on matches the type of the fragment.</p><p>For example in this query on the Facebook data model:</p><pre><code><span class="token keyword">query</span> FragmentTyping <span class="token punctuation">{</span>
  profiles<span class="token punctuation">(</span><span class="token attr-name">handles</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"zuck"</span><span class="token punctuation">,</span> <span class="token string">"cocacola"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    handle
    <span class="token operator">...</span>userFragment
    <span class="token operator">...</span>pageFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> userFragment <span class="token keyword">on</span> User <span class="token punctuation">{</span>
  friends <span class="token punctuation">{</span>
    count
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> pageFragment <span class="token keyword">on</span> Page <span class="token punctuation">{</span>
  likers <span class="token punctuation">{</span>
    count
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The <code>profiles</code> root field returns a list where each element could be a <code>Page</code> or a <code>User</code>. When the object in the <code>profiles</code> result is a <code>User</code>, <code>friends</code> will be present and <code>likers</code> will not. Conversely when the result is a <code>Page</code>, <code>likers</code> will be present and <code>friends</code> will not.</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"profiles"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string">"handle"</span><span class="token punctuation">:</span> <span class="token string">"zuck"</span><span class="token punctuation">,</span>
      <span class="token string">"friends"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"count"</span> <span class="token punctuation">:</span> <span class="token number">1234</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token string">"handle"</span><span class="token punctuation">:</span> <span class="token string">"cocacola"</span><span class="token punctuation">,</span>
      <span class="token string">"likers"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"count"</span> <span class="token punctuation">:</span> <span class="token number">90234512</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Inline-Fragments" secid="2.8.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Inline-Fragments">2.8.2</a></span>Inline Fragments</h4><div class="spec-production" id="InlineFragment"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-quantified"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><p>Fragments can be defined inline within a selection set. This is done to conditionally include fields based on their runtime type. This feature of standard fragment inclusion was demonstrated in the <code>query FragmentTyping</code> example. We could accomplish the same thing using inline fragments.</p><pre><code><span class="token keyword">query</span> inlineFragmentTyping <span class="token punctuation">{</span>
  profiles<span class="token punctuation">(</span><span class="token attr-name">handles</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"zuck"</span><span class="token punctuation">,</span> <span class="token string">"cocacola"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    handle
    <span class="token operator">...</span> <span class="token keyword">on</span> User <span class="token punctuation">{</span>
      friends <span class="token punctuation">{</span>
        count
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span> <span class="token keyword">on</span> Page <span class="token punctuation">{</span>
      likers <span class="token punctuation">{</span>
        count
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Inline fragments may also be used to apply a directive to a group of fields. If the TypeCondition is omitted, an inline fragment is considered to be of the same type as the enclosing context.</p><pre><code><span class="token keyword">query</span> inlineFragmentNoType<span class="token punctuation">(</span><span class="token variable">$expandedInfo</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">handle</span><span class="token punctuation">:</span> <span class="token string">"zuck"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
    <span class="token operator">...</span> <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$expandedInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      firstName
      lastName
      birthday
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Input-Values" secid="2.9"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Input-Values">2.9</a></span>Input Values</h3><div class="spec-production" id="Value"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-condition not">Const</span><span class="spec-nt"><a href="#Variable">Variable</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NullValue">NullValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div></div><p>Field and directive arguments accept input values of various literal primitives; input values can be scalars, enumeration values, lists, or input objects.</p><p>If not defined as constant (for example, in <span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span>), input values can be specified as a variable. List and inputs objects may also contain variables (unless defined to be constant).</p><section id="sec-Int-Value" secid="2.9.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Int-Value">2.9.1</a></span>Int Value</h4><div class="spec-production d2" id="IntValue"><span class="spec-nt"><a href="#IntValue">IntValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span></div></div><div class="spec-production d2" id="IntegerPart"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">0</span></div><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production d2" id="NegativeSign"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><div class="spec-rhs"><span class="spec-t">-</span></div></div><div class="spec-production d2" id="Digit"><span class="spec-nt"><a href="#Digit">Digit</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr></table></div></div><div class="spec-production d2" id="NonZeroDigit"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-butnot"><span class="spec-t">0</span></span></span></div></div><p>An Int number is specified without a decimal point or exponent (ex. <code>1</code>).</p></section><section id="sec-Float-Value" secid="2.9.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Float-Value">2.9.2</a></span>Float Value</h4><div class="spec-production d2" id="FloatValue"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div></div><div class="spec-production d2" id="FractionalPart"><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentPart"><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentIndicator"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr></table></div></div><div class="spec-production d2" id="Sign"><span class="spec-nt"><a href="#Sign">Sign</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr></table></div></div><p>A Float number includes either a decimal point (ex. <code>1.0</code>) or an exponent (ex. <code>1e50</code>) or both (ex. <code>6.0221413e23</code>).</p></section><section id="sec-Boolean-Value" secid="2.9.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Boolean-Value">2.9.3</a></span>Boolean Value</h4><div class="spec-production" id="BooleanValue"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">true</span></td><td class="spec-rhs"><span class="spec-t">false</span></td></tr></table></div></div><p>The two keywords <code>true</code> and <code>false</code> represent the two boolean values.</p></section><section id="sec-String-Value" secid="2.9.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-String-Value">2.9.4</a></span>String Value</h4><div class="spec-production d2" id="StringValue"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-quantified"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">&quot;</span></div></div><div class="spec-production d2" id="StringCharacter"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div></div><div class="spec-production d2" id="EscapedUnicode"><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span><div class="spec-rhs"><span class="spec-rx">/[0-9A-Fa-f]{4}/</span></div></div><div class="spec-production d2" id="EscapedCharacter"><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">&quot;</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr></table></div></div><p>Strings are sequences of characters wrapped in double&#8208;quotes (<code>&quot;</code>). (ex. <code>&quot;Hello World&quot;</code>). White space and other otherwise&#8208;ignored characters are significant within a string value.</p><div class="spec-note">Unicode characters are allowed within String value literals, however GraphQL source must not contain some ASCII control characters so escape sequences must be used to represent these characters.</div><p><strong>Semantics</strong></p><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><ol><li>Return an empty Unicode character sequence.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-quantified"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">&quot;</span></div><ol><li>Return the Unicode character sequence of all <span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span> Unicode character values.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><ol><li>Return the character value of <span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span>.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><ol><li>Return the character whose code unit value in the Unicode Basic Multilingual Plane is the 16&#8208;bit hexadecimal value <span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span>.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div><ol><li>Return the character value of <span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span> according to the table below.</li></ol></div><table><thead><tr><th>Escaped Character </th><th>Code Unit Value </th><th>Character Name </th></tr></thead><tbody><tr><td><code>&quot;</code> </td><td>U+0022 </td><td>double quote </td></tr><tr><td><code>\</code> </td><td>U+005C </td><td>reverse solidus (back slash) </td></tr><tr><td><code>/</code> </td><td>U+002F </td><td>solidus (forward slash) </td></tr><tr><td><code>b</code> </td><td>U+0008 </td><td>backspace </td></tr><tr><td><code>f</code> </td><td>U+000C </td><td>form feed </td></tr><tr><td><code>n</code> </td><td>U+000A </td><td>line feed (new line) </td></tr><tr><td><code>r</code> </td><td>U+000D </td><td>carriage return </td></tr><tr><td><code>t</code> </td><td>U+0009 </td><td>horizontal tab </td></tr></tbody></table></section><section id="sec-Null-Value" secid="2.9.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Null-Value">2.9.5</a></span>Null Value</h4><div class="spec-production" id="NullValue"><span class="spec-nt"><a href="#NullValue">NullValue</a></span><div class="spec-rhs"><span class="spec-t">null</span></div></div><p>Null values are represented as the keyword <span class="spec-keyword">null</span>.</p><p>GraphQL has two semantically different ways to represent the lack of a value:</p><ul><li>Explicitly providing the literal value: <span class="spec-keyword">null</span>.</li><li>Implicitly not providing a value at all.</li></ul><p>For example, these two field calls are similar, but are not identical:</p><pre><code><span class="token punctuation">{</span>
  field<span class="token punctuation">(</span><span class="token attr-name">arg</span><span class="token punctuation">:</span> null<span class="token punctuation">)</span>
  field
<span class="token punctuation">}</span>
</code></pre><p>The first has explictly provided <span class="spec-keyword">null</span> to the argument &ldquo;arg&rdquo;, while the second has implicitly not provided a value to the argument &ldquo;arg&rdquo;. These two forms may be interpreted differently. For example, a mutation representing deleting a field vs not altering a field, respectively. Niether form may be used for an input expecting a Non&#8208;Null type.</p><div class="spec-note">The same two methods of representing the lack of a value are possible via variables by either providing the a variable value as <span class="spec-keyword">null</span> and not providing a variable value at all.</div></section><section id="sec-Enum-Value" secid="2.9.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Enum-Value">2.9.6</a></span>Enum Value</h4><div class="spec-production" id="EnumValue"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span><span class="spec-t">null</span></span></span></div></div><p>Enum values are represented as unquoted names (ex. <code>MOBILE_WEB</code>). It is recommended that Enum values be &ldquo;all caps&rdquo;. Enum values are only used in contexts where the precise enumeration type is known. Therefore it&rsquo;s not necessary to supply an enumeration type name in the literal.</p></section><section id="sec-List-Value" secid="2.9.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-List-Value">2.9.7</a></span>List Value</h4><div class="spec-production" id="ListValue"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-quantified"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">]</span></div></div><p>Lists are ordered sequences of values wrapped in square&#8208;brackets <code>[ ]</code>. The values of a List literal may be any value literal or variable (ex. <code>[1, 2, 3]</code>).</p><p>Commas are optional throughout GraphQL so trailing commas are allowed and repeated commas do not represent missing values.</p><p><strong>Semantics</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#ListValue">ListValue</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><ol><li>Return a new empty list value.</li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#ListValue">ListValue</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-quantified"><span class="spec-nt"><a href="#Value">Value</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">]</span></div><ol><li>Let <var>inputList</var> be a new empty list value.</li><li>For each <span class="spec-quantified"><span class="spec-nt"><a href="#Value">Value</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><ol><li>Let <var>value</var> be the result of evaluating <span class="spec-nt"><a href="#Value">Value</a></span>.</li><li>Append <var>value</var> to <var>inputList</var>.</li></ol></li><li>Return <var>inputList</var></li></ol></div></section><section id="sec-Input-Object-Values" secid="2.9.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-Values">2.9.8</a></span>Input Object Values</h4><div class="spec-production" id="ObjectValue"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="ObjectField"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div></div><p>Input object literal values are unordered lists of keyed input values wrapped in curly&#8208;braces <code>{ }</code>. The values of an object literal may be any input value literal or variable (ex. <code>{ name: &quot;Hello world&quot;, score: 1.0 }</code>). We refer to literal representation of input objects as &ldquo;object literals.&rdquo;</p><p><strong>Input object fields are unordered</strong></p><p>Input object fields may be provided in any syntactic order and maintain identical semantic meaning.</p><p>These two queries are semantically identical:</p><pre><code><span class="token punctuation">{</span>
  nearestThing<span class="token punctuation">(</span><span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token attr-name">lon</span><span class="token punctuation">:</span> <span class="token number">12.43</span><span class="token punctuation">,</span> <span class="token attr-name">lat</span><span class="token punctuation">:</span> <span class="token number">-53.211</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><pre><code><span class="token punctuation">{</span>
  nearestThing<span class="token punctuation">(</span><span class="token attr-name">location</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token attr-name">lat</span><span class="token punctuation">:</span> <span class="token number">-53.211</span><span class="token punctuation">,</span> <span class="token attr-name">lon</span><span class="token punctuation">:</span> <span class="token number">12.43</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Semantics</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><ol><li>Return a new input object value with no fields.</li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#ObjectField">ObjectField</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div><ol><li>Let <var>inputObject</var> be a new input object value with no fields.</li><li>For each <var>field</var> in <span class="spec-quantified"><span class="spec-nt"><a href="#ObjectField">ObjectField</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><ol><li>Let <var>name</var> be <span class="spec-nt"><a href="#Name">Name</a></span> in <var>field</var>.</li><li>Let <var>value</var> be the result of evaluating <span class="spec-nt"><a href="#Value">Value</a></span> in <var>field</var>.</li><li>Add a field to <var>inputObject</var> of name <var>name</var> containing value <var>value</var>.</li></ol></li><li>Return <var>inputObject</var></li></ol></div></section></section><section id="sec-Language.Variables" secid="2.10"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Variables">2.10</a></span>Variables</h3><div class="spec-production" id="Variable"><span class="spec-nt"><a href="#Variable">Variable</a></span><div class="spec-rhs"><span class="spec-t">$</span><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="VariableDefinitions"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-quantified"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="VariableDefinition"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Variable">Variable</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production" id="DefaultValue"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><div class="spec-rhs"><span class="spec-t">=</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param">Const</span></span></span></div></div><p>A GraphQL query can be parameterized with variables, maximizing query reuse, and avoiding costly string building in clients at runtime.</p><p>If not defined as constant (for example, in <span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span>), a <span class="spec-nt"><a href="#Variable">Variable</a></span> can be supplied for an input value.</p><p>Variables must be defined at the top of an operation and are in scope throughout the execution of that operation.</p><p>In this example, we want to fetch a profile picture size based on the size of a particular device:</p><pre><code><span class="token keyword">query</span> getZuckProfile<span class="token punctuation">(</span><span class="token variable">$devicePicSize</span><span class="token punctuation">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  user<span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    id
    name
    profilePic<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token variable">$devicePicSize</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Values for those variables are provided to a GraphQL service along with a request so they may be substituted during execution. If providing JSON for the variables&rsquo; values, we could run this query and request profilePic of size <code>60</code> width:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"devicePicSize"</span><span class="token punctuation">:</span> <span class="token number">60</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Variable use within Fragments</strong></p><p>Query variables can be used within fragments. Query variables have global scope with a given operation, so a variable used within a fragment must be declared in any top&#8208;level operation that transitively consumes that fragment. If a variable is referenced in a fragment and is included by an operation that does not define that variable, the operation cannot be executed.</p></section><section id="sec-Input-Types" secid="2.11"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Input-Types">2.11</a></span>Input Types</h3><div class="spec-production" id="Type"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span></div></div><div class="spec-production" id="NamedType"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="ListType"><span class="spec-nt"><a href="#ListType">ListType</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div></div><div class="spec-production" id="NonNullType"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><span class="spec-t">!</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span><span class="spec-t">!</span></div></div><p>GraphQL describes the types of data expected by query variables. Input types may be lists of another input type, or a non&#8208;null variant of any other input type.</p><p><strong>Semantics</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><ol><li>Let <var>name</var> be the string value of <span class="spec-nt"><a href="#Name">Name</a></span></li><li>Let <var>type</var> be the type defined in the Schema named <var>name</var></li><li><var>type</var> must not be <span class="spec-keyword">null</span></li><li>Return <var>type</var></li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div><ol><li>Let <var>itemType</var> be the result of evaluating <span class="spec-nt"><a href="#Type">Type</a></span></li><li>Let <var>type</var> be a List type where <var>itemType</var> is the contained type.</li><li>Return <var>type</var></li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">!</span></div><ol><li>Let <var>nullableType</var> be the result of evaluating <span class="spec-nt"><a href="#Type">Type</a></span></li><li>Let <var>type</var> be a Non&#8208;Null type where <var>nullableType</var> is the contained type.</li><li>Return <var>type</var></li></ol></div></section><section id="sec-Language.Directives" secid="2.12"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language.Directives">2.12</a></span>Directives</h3><div class="spec-production" id="Directives"><span class="spec-nt"><a href="#Directives">Directives</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Directive">Directive</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production" id="Directive"><span class="spec-nt"><a href="#Directive">Directive</a></span><div class="spec-rhs"><span class="spec-t">@</span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><p>Directives provide a way to describe alternate runtime execution and type validation behavior in a GraphQL document.</p><p>In some cases, you need to provide options to alter GraphQL&rsquo;s execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.</p><p>Directives have a name along with a list of arguments which may accept values of any input type.</p><p>Directives can be used to describe additional information for fields, fragments, and operations.</p><p>As future versions of GraphQL adopt new configurable execution capabilities, they may be exposed via directives. </p></section></section><section id="sec-Type-System" secid="3"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Type-System">3</a></span>Type System</h2><p>The GraphQL Type system describes the capabilities of a GraphQL server and is used to determine if a query is valid. The type system also describes the input types of query variables to determine if values provided at runtime are valid.</p><p>A GraphQL server&rsquo;s capabilities are referred to as that server&rsquo;s &ldquo;schema&rdquo;. A schema is defined in terms of the types and directives it supports.</p><p>A given GraphQL schema must itself be internally valid. This section describes the rules for this validation process where relevant.</p><p>A GraphQL schema is represented by a root type for each kind of operation: query and mutation; this determines the place in the type system where those operations begin.</p><p>All types within a GraphQL schema must have unique names. No two provided types may have the same name. No provided type may have a name which conflicts with any built in types (including Scalar and Introspection types).</p><p>All directives within a GraphQL schema must have unique names. A directive and a type may share the same name, since there is no ambiguity between them.</p><section id="sec-Types" secid="3.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Types">3.1</a></span>Types</h3><p>The fundamental unit of any GraphQL Schema is the type. There are eight kinds of types in GraphQL.</p><p>The most basic type is a <code>Scalar</code>. A scalar represents a primitive value, like a string or an integer. Oftentimes, the possible responses for a scalar field are enumerable. GraphQL offers an <code>Enum</code> type in those cases, where the type specifies the space of valid responses.</p><p>Scalars and Enums form the leaves in response trees; the intermediate levels are <code>Object</code> types, which define a set of fields, where each field is another type in the system, allowing the definition of arbitrary type hierarchies.</p><p>GraphQL supports two abstract types: interfaces and unions.</p><p>An <code>Interface</code> defines a list of fields; <code>Object</code> types that implement that interface are guaranteed to implement those fields. Whenever the type system claims it will return an interface, it will return a valid implementing type.</p><p>A <code>Union</code> defines a list of possible types; similar to interfaces, whenever the type system claims a union will be returned, one of the possible types will be returned.</p><p>All of the types so far are assumed to be both nullable and singular: e.g. a scalar string returns either null or a singular string. The type system might want to define that it returns a list of other types; the <code>List</code> type is provided for this reason, and wraps another type. Similarly, the <code>Non-Null</code> type wraps another type, and denotes that the result will never be null. These two types are referred to as &ldquo;wrapping types&rdquo;; non&#8208;wrapping types are referred to as &ldquo;base types&rdquo;. A wrapping type has an underlying &ldquo;base type&rdquo;, found by continually unwrapping the type until a base type is found.</p><p>Finally, oftentimes it is useful to provide complex structs as inputs to GraphQL queries; the <code>Input Object</code> type allows the schema to define exactly what data is expected from the client in these queries.</p><section id="sec-Scalars" secid="3.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Scalars">3.1.1</a></span>Scalars</h4><p>As expected by the name, a scalar represents a primitive value in GraphQL. GraphQL responses take the form of a hierarchical tree; the leaves on these trees are GraphQL scalars.</p><p>All GraphQL scalars are representable as strings, though depending on the response format being used, there may be a more appropriate primitive for the given scalar type, and server should use those types when appropriate.</p><p>GraphQL provides a number of built&#8208;in scalars, but type systems can add additional scalars with semantic meaning. For example, a GraphQL system could define a scalar called <code>Time</code> which, while serialized as a string, promises to conform to ISO&#8208;8601. When querying a field of type <code>Time</code>, you can then rely on the ability to parse the result with an ISO&#8208;8601 parser and use a client&#8208;specific primitive for time. Another example of a potentially useful custom scalar is <code>Url</code>, which serializes as a string, but is guaranteed by the server to be a valid URL.</p><p>A server may omit any of the built&#8208;in scalars from its schema, for example if a schema does not refer to a floating&#8208;point number, then it will not include the <code>Float</code> type. However, if a schema includes a type with the name of one of the types described here, it must adhere to the behavior described. As an example, a server must not include a type called <code>Int</code> and use it to represent 128&#8208;bit numbers, or internationalization information.</p><p><strong>Result Coercion</strong></p><p>A GraphQL server, when preparing a field of a given scalar type, must uphold the contract the scalar type describes, either by coercing the value or producing an error.</p><p>For example, a GraphQL server could be preparing a field with the scalar type <code>Int</code> and encounter a floating&#8208;point number. Since the server must not break the contract by yielding a non&#8208;integer, the server should truncate the fractional value and only yield the integer value. If the server encountered a boolean <code>true</code> value, it should return <code>1</code>. If the server encountered a string, it may attempt to parse the string for a base&#8208;10 integer value. If the server encounters some value that cannot be reasonably coerced to an <code>Int</code>, then it must raise a field error.</p><p>Since this coercion behavior is not observable to clients of the GraphQL server, the precise rules of coercion are left to the implementation. The only requirement is that the server must yield values which adhere to the expected Scalar type.</p><p><strong>Input Coercion</strong></p><p>If a GraphQL server expects a scalar type as input to an argument, coercion is observable and the rules must be well defined. If an input value does not match a coercion rule, a query error must be raised.</p><p>GraphQL has different constant literals to represent integer and floating&#8208;point input values, and coercion rules may apply differently depending on which type of input value is encountered. GraphQL may be parameterized by query variables, the values of which are often serialized when sent over a transport like HTTP. Since some common serializations (ex. JSON) do not discriminate between integer and floating&#8208;point values, they are interpreted as an integer input value if they have an empty fractional part (ex. <code>1.0</code>) and otherwise as floating&#8208;point input value.</p><p>For all types below, with the exception of Non&#8208;Null, if the explicit value <span class="spec-keyword">null</span> is provided, then the result of input coercion is <span class="spec-keyword">null</span>.</p><p><strong>Built&#8208;in Scalars</strong></p><p>GraphQL provides a basic set of well&#8208;defined Scalar types. A GraphQL server should support all of these types, and a GraphQL server which provide a type by these names must adhere to the behavior described below.</p><section id="sec-Int" secid="3.1.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Int">3.1.1.1</a></span>Int</h5><p>The Int scalar type represents a signed 32&#8208;bit numeric non&#8208;fractional value. Response formats that support a 32&#8208;bit integer or a number type should use that type to represent this scalar.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers should coerce non&#8208;int raw values to Int when possible otherwise they must raise a field error. Examples of this may include returning <code>1</code> for the floating&#8208;point number <code>1.0</code>, or <code>2</code> for the string <code>&quot;2&quot;</code>.</p><p><strong>Input Coercion</strong></p><p>When expected as an input type, only integer input values are accepted. All other input values, including strings with numeric content, must raise a query error indicating an incorrect type. If the integer input value represents a value less than -2<sup>31</sup> or greater than or equal to 2<sup>31</sup>, a query error should be raised.</p><div class="spec-note">Numeric integer values larger than 32&#8208;bit should either use String or a custom&#8208;defined Scalar type, as not all platforms and transports support encoding integer numbers larger than 32&#8208;bit.</div></section><section id="sec-Float" secid="3.1.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Float">3.1.1.2</a></span>Float</h5><p>The Float scalar type represents signed double&#8208;precision fractional values as specified by <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>. Response formats that support an appropriate double&#8208;precision number type should use that type to represent this scalar.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers should coerce non&#8208;floating&#8208;point raw values to Float when possible otherwise they must raise a field error. Examples of this may include returning <code>1.0</code> for the integer number <code>1</code>, or <code>2.0</code> for the string <code>&quot;2&quot;</code>.</p><p><strong>Input Coercion</strong></p><p>When expected as an input type, both integer and float input values are accepted. Integer input values are coerced to Float by adding an empty fractional part, for example <code>1.0</code> for the integer input value <code>1</code>. All other input values, including strings with numeric content, must raise a query error indicating an incorrect type. If the integer input value represents a value not representable by IEEE 754, a query error should be raised.</p></section><section id="sec-String" secid="3.1.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-String">3.1.1.3</a></span>String</h5><p>The String scalar type represents textual data, represented as UTF&#8208;8 character sequences. The String type is most often used by GraphQL to represent free&#8208;form human&#8208;readable text. All response formats must support string representations, and that representation must be used here.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers should coerce non&#8208;string raw values to String when possible otherwise they must raise a field error. Examples of this may include returning the string <code>&quot;true&quot;</code> for a boolean true value, or the string <code>&quot;1&quot;</code> for the integer <code>1</code>.</p><p><strong>Input Coercion</strong></p><p>When expected as an input type, only valid UTF&#8208;8 string input values are accepted. All other input values must raise a query error indicating an incorrect type.</p></section><section id="sec-Boolean" secid="3.1.1.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Boolean">3.1.1.4</a></span>Boolean</h5><p>The Boolean scalar type represents <code>true</code> or <code>false</code>. Response formats should use a built&#8208;in boolean type if supported; otherwise, they should use their representation of the integers <code>1</code> and <code>0</code>.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers should coerce non&#8208;boolean raw values to Boolean when possible otherwise they must raise a field error. Examples of this may include returning <code>true</code> for any non&#8208;zero number.</p><p><strong>Input Coercion</strong></p><p>When expected as an input type, only boolean input values are accepted. All other input values must raise a query error indicating an incorrect type.</p></section><section id="sec-ID" secid="3.1.1.5"><h5><span class="spec-secid" title="link to this section"><a href="#sec-ID">3.1.1.5</a></span>ID</h5><p>The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a <code>String</code>; however, it is not intended to be human&#8208;readable. While it is often numeric, it should always serialize as a <code>String</code>.</p><p><strong>Result Coercion</strong></p><p>GraphQL is agnostic to ID format, and serializes to string to ensure consistency across many formats ID could represent, from small auto&#8208;increment numbers, to large 128&#8208;bit random numbers, to base64 encoded values, or string values of a format like <a href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a>.</p><p>GraphQL servers should coerce as appropriate given the ID formats they expect. When coercion is not possible they must raise a field error.</p><p><strong>Input Coercion</strong></p><p>When expected as an input type, any string (such as <code>&quot;4&quot;</code>) or integer (such as <code>4</code>) input value should be coerced to ID as appropriate for the ID formats a given GraphQL server expects. Any other input value, including float input values (such as <code>4.0</code>), must raise a query error indicating an incorrect type.</p></section></section><section id="sec-Objects" secid="3.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Objects">3.1.2</a></span>Objects</h4><p>GraphQL queries are hierarchical and composed, describing a tree of information. While Scalar types describe the leaf values of these hierarchical queries, Objects describe the intermediate levels.</p><p>GraphQL Objects represent a list of named fields, each of which yield a value of a specific type. Object values should be serialized as ordered maps, where the queried field names (or aliases) are the keys and the result of evaluating the field is the value, ordered by the order in which they appear in the query.</p><p>For example, a type <code>Person</code> could be described as:</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
}
</code></pre><p>Where <code>name</code> is a field that will yield a <code>String</code> value, and <code>age</code> is a field that will yield an <code>Int</code> value, and <code>picture</code> is a field that will yield a <code>Url</code> value.</p><p>A query of an object value must select at least one field. This selection of fields will yield an ordered map containing exactly the subset of the object queried, which should be represented in the order in which they were queried. Only fields that are declared on the object type may validly be queried on that object.</p><p>For example, selecting all the fields of <code>Person</code>:</p><pre><code><span class="token punctuation">{</span>
  name
  age
  picture
<span class="token punctuation">}</span>
</code></pre><p>Would yield the object:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span><span class="token punctuation">,</span>
  <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token string">"picture"</span><span class="token punctuation">:</span> <span class="token string">"http://some.cdn/picture.jpg"</span>
<span class="token punctuation">}</span>
</code></pre><p>While selecting a subset of fields:</p><pre><code><span class="token punctuation">{</span>
  age
  name
<span class="token punctuation">}</span>
</code></pre><p>Must only yield exactly that subset:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span>
<span class="token punctuation">}</span>
</code></pre><p>A field of an Object type may be a Scalar, Enum, another Object type, an Interface, or a Union. Additionally, it may be any wrapping type whose underlying base type is one of those five.</p><p>For example, the <code>Person</code> type might include a <code>relationship</code>:</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
  relationship: Person
}
</code></pre><p>Valid queries must supply a nested field set for a field that returns an object, so this query is not valid:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  name
  relationship
<span class="token punctuation">}</span>
</code></pre><p>However, this example is valid:</p><pre><code><span class="token punctuation">{</span>
  name
  relationship <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>And will yield the subset of each object type queried:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span><span class="token punctuation">,</span>
  <span class="token string">"relationship"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Priscilla Chan"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Field Ordering</strong></p><p>When querying an Object, the resulting mapping of fields are conceptually ordered in the same order in which they were encountered during query execution, excluding fragments for which the type does not apply and fields or fragments that are skipped via <code>@skip</code> or <code>@include</code> directives. This ordering is correctly produced when using the <span class="spec-call"><a href="#CollectFields()">CollectFields</a>()</span> algorithm.</p><p>Response serialization formats capable of representing ordered maps should maintain this ordering. Serialization formats which can only represent unordered maps should retain this order grammatically (such as JSON).</p><p>Producing a response where fields are represented in the same order in which they appear in the request improves human readability during debugging and enables more efficient parsing of responses if the order of properties can be anticipated.</p><p>If a fragment is spread before other fields, the fields that fragment specifies occur in the response before the following fields.</p><pre><code><span class="token punctuation">{</span>
  foo
  <span class="token operator">...</span>Frag
  qux
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> Frag on Query <span class="token punctuation">{</span>
  bar
  baz
<span class="token punctuation">}</span>
</code></pre><p>Produces the ordered result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"bar"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token string">"baz"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token string">"qux"</span><span class="token punctuation">:</span> <span class="token number">4</span>
<span class="token punctuation">}</span>
</code></pre><p>If a field is queried multiple times in a selection, it is ordered by the first time it is encountered. However fragments for which the type does not apply does not affect ordering.</p><pre><code><span class="token punctuation">{</span>
  foo
  <span class="token operator">...</span>Ignored
  <span class="token operator">...</span>Matching
  bar
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> Ignored on UnknownType <span class="token punctuation">{</span>
  qux
  baz
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> Matching on Query <span class="token punctuation">{</span>
  bar
  qux
  foo
<span class="token punctuation">}</span>
</code></pre><p>Produces the ordered result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"bar"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token string">"qux"</span><span class="token punctuation">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre><p>Also, if directives result in fields being excluded, they are not considered in the ordering of fields.</p><pre><code><span class="token punctuation">{</span>
  foo <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  bar
  foo
<span class="token punctuation">}</span>
</code></pre><p>Produces the ordered result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"bar"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Result Coercion</strong></p><p>Determining the result of coercing an object is the heart of the GraphQL executor, so this is covered in that section of the spec.</p><p><strong>Input Coercion</strong></p><p>Objects are never valid inputs.</p><section id="sec-Object-Field-Arguments" secid="3.1.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-Field-Arguments">3.1.2.1</a></span>Object Field Arguments</h5><p>Object fields are conceptually functions which yield values. Occasionally object fields can accept arguments to further specify the return value. Object field arguments are defined as a list of all possible argument names and their expected input types.</p><p>For example, a <code>Person</code> type with a <code>picture</code> field could accept an argument to determine what size of an image to return.</p><pre><code>type Person {
  name: String
  picture(size: Int): Url
}
</code></pre><p>GraphQL queries can optionally specify arguments to their fields to provide these arguments.</p><p>This example query:</p><pre><code><span class="token punctuation">{</span>
  name
  picture<span class="token punctuation">(</span><span class="token attr-name">size</span><span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>May yield the result:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Mark Zuckerberg"</span><span class="token punctuation">,</span>
  <span class="token string">"picture"</span><span class="token punctuation">:</span> <span class="token string">"http://some.cdn/picture_600.jpg"</span>
<span class="token punctuation">}</span>
</code></pre><p>The type of an object field argument can be any Input type.</p></section><section id="sec-Object-Field-deprecation" secid="3.1.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-Field-deprecation">3.1.2.2</a></span>Object Field deprecation</h5><p>Fields in an object may be marked as deprecated as deemed necessary by the application. It is still legal to query for these fields (to ensure existing clients are not broken by the change), but the fields should be appropriately treated in documentation and tooling.</p></section><section id="sec-Object-type-validation" secid="3.1.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-type-validation">3.1.2.3</a></span>Object type validation</h5><p>Object types have the potential to be invalid if incorrectly defined. This set of rules must be adhered to by every Object type in a GraphQL schema.</p><ol><li>An Object type must define one or more fields.</li><li>The fields of an Object type must have unique names within that Object type; no two fields may share the same name.</li><li>An object type must be a super&#8208;set of all interfaces it implements:<ol><li>The object type must include a field of the same name for every field defined in an interface.<ol><li>The object field must be of a type which is equal to or a sub&#8208;type of the interface field (covariant).<ol><li>An object field type is a valid sub&#8208;type if it is equal to (the same type as) the interface field type.</li><li>An object field type is a valid sub&#8208;type if it is an Object type and the interface field type is either an Interface type or a Union type and the object field type is a possible type of the interface field type.</li><li>An object field type is a valid sub&#8208;type if it is a List type and the interface field type is also a List type and the list&#8208;item type of the object field type is a valid sub&#8208;type of the list&#8208;item type of the interface field type.</li><li>An object field type is a valid sub&#8208;type if it is a Non&#8208;Null variant of a valid sub&#8208;type of the interface field type.</li></ol></li><li>The object field must include an argument of the same name for every argument defined in the interface field.<ol><li>The object field argument must accept the same type (invariant) as the interface field argument.</li></ol></li><li>The object field may include additional arguments not defined in the interface field, but any additional argument must not be required.</li></ol></li></ol></li></ol></section></section><section id="sec-Interfaces" secid="3.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Interfaces">3.1.3</a></span>Interfaces</h4><p>GraphQL Interfaces represent a list of named fields and their arguments. GraphQL objects can then implement an interface, which guarantees that they will contain the specified fields.</p><p>Fields on a GraphQL interface have the same rules as fields on a GraphQL object; their type can be Scalar, Object, Enum, Interface, or Union, or any wrapping type whose base type is one of those five.</p><p>For example, an interface may describe a required field and types such as <code>Person</code> or <code>Business</code> may then implement this interface.</p><pre><code>interface NamedEntity {
  name: String
}

type Person implements NamedEntity {
  name: String
  age: Int
}

type Business implements NamedEntity {
  name: String
  employeeCount: Int
}
</code></pre><p>Fields which yield an interface are useful when one of many Object types are expected, but some fields should be guaranteed.</p><p>To continue the example, a <code>Contact</code> might refer to <code>NamedEntity</code>.</p><pre><code>type Contact {
  entity: NamedEntity
  phoneNumber: String
  address: String
}
</code></pre><p>This allows us to write a query for a <code>Contact</code> that can select the common fields.</p><pre><code><span class="token punctuation">{</span>
  entity <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
  phoneNumber
<span class="token punctuation">}</span>
</code></pre><p>When querying for fields on an interface type, only those fields declared on the interface may be queried. In the above example, <code>entity</code> returns a <code>NamedEntity</code>, and <code>name</code> is defined on <code>NamedEntity</code>, so it is valid. However, the following would not be a valid query:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  entity <span class="token punctuation">{</span>
    name
    age
  <span class="token punctuation">}</span>
  phoneNumber
<span class="token punctuation">}</span>
</code></pre><p>because <code>entity</code> refers to a <code>NamedEntity</code>, and <code>age</code> is not defined on that interface. Querying for <code>age</code> is only valid when the result of <code>entity</code> is a <code>Person</code>; the query can express this using a fragment or an inline fragment:</p><pre><code><span class="token punctuation">{</span>
  entity <span class="token punctuation">{</span>
    name
    <span class="token operator">...</span> <span class="token keyword">on</span> Person <span class="token punctuation">{</span>
      age
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  phoneNumber
<span class="token punctuation">}</span>
</code></pre><p><strong>Result Coercion</strong></p><p>The interface type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the interface is the same as the result coercion of the object.</p><p><strong>Input Coercion</strong></p><p>Interfaces are never valid inputs.</p><section id="sec-Interface-type-validation" secid="3.1.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Interface-type-validation">3.1.3.1</a></span>Interface type validation</h5><p>Interface types have the potential to be invalid if incorrectly defined.</p><ol><li>An Interface type must define one or more fields.</li><li>The fields of an Interface type must have unique names within that Interface type; no two fields may share the same name.</li></ol></section></section><section id="sec-Unions" secid="3.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Unions">3.1.4</a></span>Unions</h4><p>GraphQL Unions represent an object that could be one of a list of GraphQL Object types, but provides for no guaranteed fields between those types. They also differ from interfaces in that Object types declare what interfaces they implement, but are not aware of what unions contain them.</p><p>With interfaces and objects, only those fields defined on the type can be queried directly; to query other fields on an interface, typed fragments must be used. This is the same as for unions, but unions do not define any fields, so <strong>no</strong> fields may be queried on this type without the use of typed fragments.</p><p>For example, we might have the following type system:</p><pre><code>union SearchResult = Photo | Person

type Person {
  name: String
  age: Int
}

type Photo {
  height: Int
  width: Int
}

type SearchQuery {
  firstSearchResult: SearchResult
}
</code></pre><p>When querying the <code>firstSearchResult</code> field of type <code>SearchQuery</code>, the query would ask for all fields inside of a fragment indicating the appropriate type. If the query wanted the name if the result was a Person, and the height if it was a photo, the following query is invalid, because the union itself defines no fields:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  firstSearchResult <span class="token punctuation">{</span>
    name
    height
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Instead, the query would be:</p><pre><code><span class="token punctuation">{</span>
  firstSearchResult <span class="token punctuation">{</span>
    <span class="token operator">...</span> <span class="token keyword">on</span> Person <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
    <span class="token operator">...</span> <span class="token keyword">on</span> Photo <span class="token punctuation">{</span>
      height
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>Result Coercion</strong></p><p>The union type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the union is the same as the result coercion of the object.</p><p><strong>Input Coercion</strong></p><p>Unions are never valid inputs.</p><section id="sec-Union-type-validation" secid="3.1.4.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Union-type-validation">3.1.4.1</a></span>Union type validation</h5><p>Union types have the potential to be invalid if incorrectly defined.</p><ol><li>The member types of a Union type must all be Object base types; Scalar, Interface and Union types may not be member types of a Union. Similarly, wrapping types may not be member types of a Union.</li><li>A Union type must define one or more member types.</li></ol></section></section><section id="sec-Enums" secid="3.1.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Enums">3.1.5</a></span>Enums</h4><p>GraphQL Enums are a variant on the Scalar type, which represents one of a finite set of possible values.</p><p>GraphQL Enums are not references for a numeric value, but are unique values in their own right. They serialize as a string: the name of the represented value.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers must return one of the defined set of possible values. If a reasonable coercion is not possible they must raise a field error.</p><p><strong>Input Coercion</strong></p><p>GraphQL has a constant literal to represent enum input values. GraphQL string literals must not be accepted as an enum input and instead raise a query error.</p><p>Query variable transport serializations which have a different representation for non&#8208;string symbolic values (for example, <a href="https://github.com/edn-format/edn">EDN</a>) should only allow such values as enum input values. Otherwise, for most transport serializations that do not, strings may be interpreted as the enum input value with the same name.</p></section><section id="sec-Input-Objects" secid="3.1.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Objects">3.1.6</a></span>Input Objects</h4><p>Fields can define arguments that the client passes up with the query, to configure their behavior. These inputs can be Strings or Enums, but they sometimes need to be more complex than this.</p><p>The <code>Object</code> type defined above is inappropriate for re&#8208;use here, because <code>Object</code>s can contain fields that express circular references or references to interfaces and unions, neither of which is appropriate for use as an input argument. For this reason, input objects have a separate type in the system.</p><p>An <code>Input Object</code> defines a set of input fields; the input fields are either scalars, enums, or other input objects. This allows arguments to accept arbitrarily complex structs.</p><p><strong>Result Coercion</strong></p><p>An input object is never a valid result.</p><p><strong>Input Coercion</strong></p><p>The value for an input object should be an input object literal or an unordered map, otherwise an error should be thrown. This unordered map should not contain any entries with names not defined by a field of this input object type, otherwise an error should be thrown.</p><p>If any non&#8208;nullable fields defined by the input object do not have corresponding entries in the original value, were provided a variable for which a value was not provided, or for which the value <span class="spec-keyword">null</span> was provided, an error should be thrown.</p><p>The result of coercion is an environment&#8208;specific unordered map defining slots for each field both defined by the input object type and provided by the original value.</p><p>For each field of the input object type, if the original value has an entry with the same name, and the value at that entry is a literal value or a variable which was provided a runtime value, an entry is added to the result with the name of the field.</p><p>The value of that entry in the result is the outcome of input coercing the original entry value according to the input coercion rules of the type declared by the input field.</p><p>Following are examples of Input Object coercion for the type:</p><pre><code>input ExampleInputObject <span class="token punctuation">{</span>
  <span class="token attr-name">a</span><span class="token punctuation">:</span> String
  <span class="token attr-name">b</span><span class="token punctuation">:</span> Int<span class="token operator">!</span>
<span class="token punctuation">}</span>
</code></pre><table><thead><tr><th>Original Value </th><th>Variables </th><th>Coerced Value</th></tr></thead><tbody><tr><td><code>{ a: &quot;abc&quot;, b: 123 }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: &quot;abc&quot;, b: 123 }</code></td></tr><tr><td><code>{ a: 123, b: &quot;123&quot; }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: &quot;123&quot;, b: 123 }</code></td></tr><tr><td><code>{ a: &quot;abc&quot; }</code> </td><td><span class="spec-keyword">null</span> </td><td>Error: Missing required field <var>b</var></td></tr><tr><td><code>{ a: &quot;abc&quot;, b: null }</code> </td><td><span class="spec-keyword">null</span> </td><td>Error: <var>b</var> must be non&#8208;null.</td></tr><tr><td><code>{ a: null, b: 1 }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: null, b: 1 }</code></td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{ var: 123 }</code> </td><td><code>{ b: 123 }</code></td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{}</code> </td><td>Error: Missing required field <var>b</var>.</td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{ var: null }</code> </td><td>Error: <var>b</var> must be non&#8208;null.</td></tr><tr><td><code>{ a: $var, b: 1 }</code> </td><td><code>{ var: null }</code> </td><td><code>{ a: null, b: 1 }</code></td></tr><tr><td><code>{ a: $var, b: 1 }</code> </td><td><code>{}</code> </td><td><code>{ b: 1 }</code></td></tr></tbody></table><div class="spec-note">there is a semantic difference between the input value explicitly declaring an input field&rsquo;s value as the value <span class="spec-keyword">null</span> vs having not declared the input field at all.</div><section id="sec-Input-Object-type-validation" secid="3.1.6.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-type-validation">3.1.6.1</a></span>Input Object type validation</h5><ol><li>An Input Object type must define one or more fields.</li><li>The fields of an Input Object type must have unique names within that Input Object type; no two fields may share the same name.</li><li>The return types of each defined field must be an Input type.</li></ol></section></section><section id="sec-Lists" secid="3.1.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Lists">3.1.7</a></span>Lists</h4><p>A GraphQL list is a special collection type which declares the type of each item in the List (referred to as the <em>item type</em> of the list). List values are serialized as ordered lists, where each item in the list is serialized as per the item type. To denote that a field uses a List type the item type is wrapped in square brackets like this: <code>pets: [Pet]</code>.</p><p><strong>Result Coercion</strong></p><p>GraphQL servers must return an ordered list as the result of a list type. Each item in the list must be the result of a result coercion of the item type. If a reasonable coercion is not possible they must raise a field error. In particular, if a non&#8208;list is returned, the coercion should fail, as this indicates a mismatch in expectations between the type system and the implementation.</p><p><strong>Input Coercion</strong></p><p>When expected as an input, list values are accepted only when each item in the list can be accepted by the list&rsquo;s item type.</p><p>If the value passed as an input to a list type is <em>not</em> a list and not the <span class="spec-keyword">null</span> value, it should be coerced as though the input was a list of size one, where the value passed is the only item in the list. This is to allow inputs that accept a &ldquo;var args&rdquo; to declare their input type as a list; if only one argument is passed (a common case), the client can just pass that value rather than constructing the list.</p><div class="spec-note">that when a <span class="spec-keyword">null</span> value is provided via a runtime variable value for a list type that it is interpretted as no list being provided, and not a list of size one with the value <span class="spec-keyword">null</span>.</div></section><section id="sec-Types.Non-Null" secid="3.1.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Types.Non-Null">3.1.8</a></span>Non-Null</h4><p>By default, all types in GraphQL are nullable; the <span class="spec-keyword">null</span> value is a valid response for all of the above types. To declare a type that disallows null, the GraphQL Non&#8208;Null type can be used. This type wraps an underlying type, and this type acts identically to that wrapped type, with the exception that <span class="spec-keyword">null</span> is not a valid response for the wrapping type. A trailing exclamation mark is used to denote a field that uses a Non&#8208;Null type like this: <code>name: String!</code>.</p><p><strong>Nullable vs. Optional</strong></p><p>Fields are <em>always</em> optional within the context of a query, a field may be omitted and the query is still valid. However fields that return Non&#8208;Null types will never return the value <span class="spec-keyword">null</span> if queried.</p><p>Inputs (such as field arguments), are always optional by default. However a non&#8208;null input type is required. In addition to not accepting the value <span class="spec-keyword">null</span>, it also does not accept omission. For the sake of simplicity nullable types are always optional and non&#8208;null types are always required.</p><p><strong>Result Coercion</strong></p><p>In all of the above result coercions, <span class="spec-keyword">null</span> was considered a valid value. To coerce the result of a Non&#8208;Null type, the coercion of the wrapped type should be performed. If that result was not <span class="spec-keyword">null</span>, then the result of coercing the Non&#8208;Null type is that result. If that result was <span class="spec-keyword">null</span>, then a field error must be raised.</p><p><strong>Input Coercion</strong></p><p>If an argument or input&#8208;object field of a Non&#8208;Null type is not provided, is provided with the literal value <span class="spec-keyword">null</span>, or is provided with a variable that was either not provided a value at runtime, or was provided the value <span class="spec-keyword">null</span>, then a query error must be raised.</p><p>If the value provided to the Non&#8208;Null type is provided with a literal value other than <span class="spec-keyword">null</span>, or a Non&#8208;Null variable value, it is coerced using the input coercion for the wrapped type.</p><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span><div class="spec-rhs"><span class="spec-nt">A</span><span class="spec-t">non-null</span><span class="spec-t">argument</span><span class="spec-t">cannot</span><span class="spec-t">be</span><span class="spec-t">omitted.</span></div></div><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  fieldWithNonNullArg
<span class="token punctuation">}</span>
</code></pre><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span><div class="spec-rhs"><span class="spec-nt">The</span><span class="spec-t">value</span><span class="spec-t">{null</span><span class="spec-t">}</span><span class="spec-t">cannot</span><span class="spec-t">be</span><span class="spec-t">provided</span><span class="spec-t">to</span><span class="spec-t">a</span><span class="spec-t">non-null</span><span class="spec-t">argument.</span></div></div><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  fieldWithNonNullArg<span class="token punctuation">(</span><span class="token attr-name">nonNullArg</span><span class="token punctuation">:</span> null<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span><div class="spec-rhs"><span class="spec-nt">A</span><span class="spec-t">variable</span><span class="spec-t">of</span><span class="spec-t">a</span><span class="spec-t">nullable</span><span class="spec-t">type</span><span class="spec-t">cannot</span><span class="spec-t">be</span><span class="spec-t">provided</span><span class="spec-t">to</span><span class="spec-t">a</span><span class="spec-t">non-null</span><span class="spec-t">argument.</span></div></div><pre><code><span class="token keyword">query</span> withNullableVariable<span class="token punctuation">(</span><span class="token variable">$var</span><span class="token punctuation">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fieldWithNonNullArg<span class="token punctuation">(</span><span class="token attr-name">nonNullArg</span><span class="token punctuation">:</span> <span class="token variable">$var</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">The Validation section defines providing a nullable variable type to a non&#8208;null input type as invalid.</div><p><strong>Non&#8208;Null type validation</strong></p><ol><li>A Non&#8208;Null type must not wrap another Non&#8208;Null type.</li></ol></section></section><section id="sec-Type-System.Directives" secid="3.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Type-System.Directives">3.2</a></span>Directives</h3><p>A GraphQL schema includes a list of the directives the execution engine supports.</p><p>GraphQL implementations should provide the <code>@skip</code> and <code>@include</code> directives.</p><section id="sec--skip" secid="3.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec--skip">3.2.1</a></span>@skip</h4><p>The <code>@skip</code> directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.</p><p>In this example <code>experimentalField</code> will be queried only if the <code>$someTest</code> is provided a <code>false</code> value.</p><pre><code><span class="token keyword">query</span> myQuery<span class="token punctuation">(</span><span class="token variable">$someTest</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  experimentalField <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$someTest</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec--include" secid="3.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec--include">3.2.2</a></span>@include</h4><p>The <code>@include</code> directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.</p><p>In this example <code>experimentalField</code> will be queried only if the <code>$someTest</code> is provided a <code>true</code> value.</p><pre><code><span class="token keyword">query</span> myQuery<span class="token punctuation">(</span><span class="token variable">$someTest</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  experimentalField <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$someTest</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="spec-note">Neither <code>@skip</code> nor <code>@include</code> has precedence over the other. In the case that both the <code>@skip</code> and <code>@include</code> directives are provided in on the same the field or fragment, it <em>must</em> be queried only if the <code>@skip</code> condition is false <em>and</em> the <code>@include</code> condition is true. Stated conversely, the field or fragment must <em>not</em> be queried if either the <code>@skip</code> condition is true <em>or</em> the <code>@include</code> condition is false.</div></section></section><section id="sec-Initial-types" secid="3.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Initial-types">3.3</a></span>Initial types</h3><p>A GraphQL schema includes types, indicating where query and mutation operations start. This provides the initial entry points into the type system. The query type must always be provided, and is an Object base type. The mutation type is optional; if it is null, that means the system does not support mutations. If it is provided, it must be an object base type.</p><p>The fields on the query type indicate what fields are available at the top level of a GraphQL query. For example, a basic GraphQL query like this one:</p><pre><code><span class="token keyword">query</span> getMe <span class="token punctuation">{</span>
  me
<span class="token punctuation">}</span>
</code></pre><p>Is valid when the type provided for the query starting type has a field named &ldquo;me&rdquo;. Similarly</p><pre><code><span class="token keyword">mutation</span> setName <span class="token punctuation">{</span>
  setName<span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Zuck"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newName
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Is valid when the type provided for the mutation starting type is not null, and has a field named &ldquo;setName&rdquo; with a string argument named &ldquo;name&rdquo;. </p></section></section><section id="sec-Introspection" secid="4"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Introspection">4</a></span>Introspection</h2><p>A GraphQL server supports introspection over its schema. This schema is queried using GraphQL itself, creating a powerful platform for tool&#8208;building.</p><p>Take an example query for a trivial app. In this case there is a User type with three fields: id, name, and birthday.</p><p>For example, given a server with the following type definition:</p><pre><code>type User {
  id: String
  name: String
  birthday: Date
}
</code></pre><p>The query</p><pre><code><span class="token punctuation">{</span>
  __type<span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"User"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
    fields <span class="token punctuation">{</span>
      name
      type <span class="token punctuation">{</span>
        name
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>would return</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"__type"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"User"</span><span class="token punctuation">,</span>
    <span class="token string">"fields"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"id"</span><span class="token punctuation">,</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"String"</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"String"</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"birthday"</span><span class="token punctuation">,</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Date"</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><section id="sec-General-Principles" secid="4.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-General-Principles">4.1</a></span>General Principles</h3><section id="sec-Naming-conventions" secid="4.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Naming-conventions">4.1.1</a></span>Naming conventions</h4><p>Types and fields required by the GraphQL introspection system that are used in the same context as user&#8208;defined types and fields are prefixed with two underscores. This in order to avoid naming collisions with user&#8208;defined GraphQL types. Conversely, GraphQL type system authors must not define any types, fields, arguments, or any other type system artifact with two leading underscores.</p></section><section id="sec-Documentation" secid="4.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Documentation">4.1.2</a></span>Documentation</h4><p>All types in the introspection system provide a <code>description</code> field of type <code>String</code> to allow type designers to publish documentation in addition to capabilities. A GraphQL server may return the <code>description</code> field using Markdown syntax. Therefore it is recommended that any tool that displays description use a Markdown renderer.</p></section><section id="sec-Deprecation" secid="4.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Deprecation">4.1.3</a></span>Deprecation</h4><p>To support the management of backwards compatibility, GraphQL fields and enum values can indicate whether or not they are deprecated (<code>isDeprecated: Boolean</code>) and a description of why it is deprecated (<code>deprecationReason: String</code>).</p><p>Tools built using GraphQL introspection should respect deprecation by discouraging deprecated use through information hiding or developer&#8208;facing warnings.</p></section><section id="sec-Type-Name-Introspection" secid="4.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Name-Introspection">4.1.4</a></span>Type Name Introspection</h4><p>GraphQL supports type name introspection at any point within a query by the meta field <code>__typename: String!</code> when querying against any Object, Interface, or Union. It returns the name of the object type currently being queried.</p><p>This is most often used when querying against Interface or Union types to identify which actual type of the possible types has been returned.</p><p>This field is implicit and does not appear in the fields list in any defined type.</p></section></section><section id="sec-Schema-Introspection" secid="4.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Schema-Introspection">4.2</a></span>Schema Introspection</h3><p>The schema introspection system is accessible from the meta&#8208;fields <code>__schema</code> and <code>__type</code> which are accessible from the type of the root of a query operation.</p><pre><code>__schema: __Schema!
__type(name: String!): __Type
</code></pre><p>These fields are implicit and do not appear in the fields list in the root type of the query operation.</p><p>The schema of the GraphQL schema introspection system:</p><pre><code>type __Schema {
  types: [__Type!]!
  queryType: __Type!
  mutationType: __Type
  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!
  name: String
  description: String

  # OBJECT and INTERFACE only
  fields(includeDeprecated: Boolean = false): [__Field!]

  # OBJECT only
  interfaces: [__Type!]

  # INTERFACE and UNION only
  possibleTypes: [__Type!]

  # ENUM only
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  # INPUT_OBJECT only
  inputFields: [__InputValue!]

  # NON_NULL and LIST only
  ofType: __Type
}

type __Field {
  name: String!
  description: String
  args: [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

type __InputValue {
  name: String!
  description: String
  type: __Type!
  defaultValue: String
}

type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

type __Directive {
  name: String!
  description: String
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
}

enum __DirectiveLocation {
  QUERY
  MUTATION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
}
</code></pre><section id="sec-The-__Type-Type" secid="4.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Type-Type">4.2.1</a></span>The __Type Type</h4><p><code>__Type</code> is at the core of the type introspection system. It represents scalars, interfaces, object types, unions, enums in the system.</p><p><code>__Type</code> also represents type modifiers, which are used to modify a type that it refers to (<code>ofType: __Type</code>). This is how we represent lists, non&#8208;nullable types, and the combinations thereof.</p></section><section id="sec-Type-Kinds" secid="4.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Kinds">4.2.2</a></span>Type Kinds</h4><p>There are several different kinds of type. In each kind, different fields are actually valid. These kinds are listed in the <code>__TypeKind</code> enumeration.</p><section id="sec-Scalar" secid="4.2.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Scalar">4.2.2.1</a></span>Scalar</h5><p>Represents scalar types such as Int, String, and Boolean. Scalars cannot have fields.</p><p>A GraphQL type designer should describe the data format and scalar coercion rules in the description field of any scalar.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.SCALAR</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Object" secid="4.2.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object">4.2.2.2</a></span>Object</h5><p>Object types represent concrete instantiations of sets of fields. The introspection types (e.g. <code>__Type</code>, <code>__Field</code>, etc) are examples of objects.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.OBJECT</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li><code>fields</code>: The set of fields query&#8208;able on this type.<ul><li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated fields are also returned.</li></ul></li><li><code>interfaces</code>: The set of interfaces that an object implements.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Union" secid="4.2.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Union">4.2.2.3</a></span>Union</h5><p>Unions are an abstract type where no common fields are declared. The possible types of a union are explicitly listed out in <code>possibleTypes</code>. Types can be made parts of unions without modification of that type.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.UNION</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li><code>possibleTypes</code> returns the list of types that can be represented within this union. They must be object types.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Interface" secid="4.2.2.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Interface">4.2.2.4</a></span>Interface</h5><p>Interfaces are an abstract type where there are common fields declared. Any type that implements an interface must define all the fields with names and types exactly matching. The implementations of this interface are explicitly listed out in <code>possibleTypes</code>.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.INTERFACE</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li><code>fields</code>: The set of fields required by this interface.<ul><li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated fields are also returned.</li></ul></li><li><code>possibleTypes</code> returns the list of types that implement this interface. They must be object types.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Enum" secid="4.2.2.5"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Enum">4.2.2.5</a></span>Enum</h5><p>Enums are special scalars that can only have a defined set of values.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.ENUM</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li><code>enumValues</code>: The list of <code>EnumValue</code>. There must be at least one and they must have unique names.<ul><li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated enum values are also returned.</li></ul></li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Input-Object" secid="4.2.2.6"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object">4.2.2.6</a></span>Input Object</h5><p>Input objects are composite types used as inputs into queries defined as a list of named input values.</p><p>For example the input object <code>Point</code> could be defined as:</p><pre><code>type Point {
  x: Int
  y: Int
}
</code></pre><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.INPUT_OBJECT</code>.</li><li><code>name</code> must return a String.</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li><li><code>inputFields</code>: a list of <code>InputValue</code>.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-List" secid="4.2.2.7"><h5><span class="spec-secid" title="link to this section"><a href="#sec-List">4.2.2.7</a></span>List</h5><p>Lists represent sequences of values in GraphQL. A List type is a type modifier: it wraps another type instance in the <code>ofType</code> field, which defines the type of each item in the list.</p><p>Fields</p><ul><li><code>kind</code> must return <code>__TypeKind.LIST</code>.</li><li><code>ofType</code>: Any type.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Type-Kinds.Non-Null" secid="4.2.2.8"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Type-Kinds.Non-Null">4.2.2.8</a></span>Non-Null</h5><p>GraphQL types are nullable. The value <span class="spec-keyword">null</span> is a valid response for field type.</p><p>A Non&#8208;null type is a type modifier: it wraps another type instance in the <code>ofType</code> field. Non&#8208;null types do not allow <span class="spec-keyword">null</span> as a response, and indicate required inputs for arguments and input object fields.</p><ul><li><code>kind</code> must return <code>__TypeKind.NON_NULL</code>.</li><li><code>ofType</code>: Any type except Non&#8208;null.</li><li>All other fields must return <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-Combining-List-and-Non-Null" secid="4.2.2.9"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Combining-List-and-Non-Null">4.2.2.9</a></span>Combining List and Non-Null</h5><p>List and Non&#8208;Null can compose, representing more complex types.</p><p>If the modified type of a List is Non&#8208;Null, then that List may not contain any <span class="spec-keyword">null</span> items.</p><p>If the modified type of a Non&#8208;Null is List, then <span class="spec-keyword">null</span> is not accepted, however an empty list is accepted.</p><p>If the modified type of a List is a List, then each item in the first List is another List of the second List&rsquo;s type.</p><p>A Non&#8208;Null type cannot modify another Non&#8208;Null type.</p></section></section><section id="sec-The-__Field-Type" secid="4.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Field-Type">4.2.3</a></span>The __Field Type</h4><p>The <code>__Field</code> type represents each field in an Object or Interface type.</p><p>Fields</p><ul><li><code>name</code> must return a String</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span></li><li><code>args</code> returns a List of <code>__InputValue</code> representing the arguments this field accepts.</li><li><code>type</code> must return a <code>__Type</code> that represents the type of value returned by this field.</li><li><code>isDeprecated</code> returns <span class="spec-keyword">true</span> if this field should no longer be used, otherwise <span class="spec-keyword">false</span>.</li><li><code>deprecationReason</code> optionally provides a reason why this field is deprecated.</li></ul></section><section id="sec-The-__InputValue-Type" secid="4.2.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__InputValue-Type">4.2.4</a></span>The __InputValue Type</h4><p>The <code>__InputValue</code> type represents field and directive arguments as well as the <code>inputFields</code> of an input object.</p><p>Fields</p><ul><li><code>name</code> must return a String</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span></li><li><code>type</code> must return a <code>__Type</code> that represents the type this input value expects.</li><li><code>defaultValue</code> may return a String encoding (using the GraphQL language) of the default value used by this input value in the condition a value is not provided at runtime. If this input value has no default value, returns <span class="spec-keyword">null</span>.</li></ul></section><section id="sec-The-__Directive-Type" secid="4.2.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Directive-Type">4.2.5</a></span>The __Directive Type</h4><p>The <code>__Directive</code> type represents a Directive that a server supports.</p><p>Fields</p><ul><li><code>name</code> must return a String</li><li><code>description</code> may return a String or <span class="spec-keyword">null</span></li><li><code>locations</code> returns a List of <code>__DirectiveLocation</code> representing the valid locations this directive may be placed.</li><li><code>args</code> returns a List of <code>__InputValue</code> representing the arguments this directive accepts. </li></ul></section></section></section><section id="sec-Validation" secid="5"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Validation">5</a></span>Validation</h2><p>GraphQL does not just verify if a request is syntactically correct, but also ensures that it is unambiguous and mistake&#8208;free in the context of a given GraphQL schema.</p><p>An invalid request is still technically executable, and will always produce a stable result as defined by the procedures in the Execution section, however that result may be ambiguous, surprising, or unexpected relative to the request containing validation errors, so execution should not occur for invalid requests.</p><p>Typically validation is performed in the context of a request immediately before execution, however a GraphQL service may execute a request without explicitly validating it if that exact same request is known to have been validated before. For example: the request may be validated during development, provided it does not later change, or a service may validate a request once and memoize the result to avoid validating the same request again in the future. Any client&#8208;side or development&#8208;time tool should report validation errors and not allow the formulation or execution of requests known to be invalid at that given point in time.</p><p><strong>Type system evolution</strong></p><p>As GraphQL type system schema evolve over time by adding new types and new fields, it is possible that a request which was previously valid could later become invalid. Any change that can cause a previously valid request to become invalid is considered a <em>breaking change</em>. GraphQL services and schema maintainers are encouraged to avoid breaking changes, however in order to be more resilient to these breaking changes, sophisticated GraphQL systems may still allow for the execution of requests which <em>at some point</em> were known to be free of any validation errors, and have not changed since.</p><p><strong>Examples</strong></p><p>For this section of this schema, we will assume the following type system in order to demonstrate examples:</p><pre><code>enum DogCommand { SIT, DOWN, HEEL }

type Dog implements Pet {
  name: String!
  nickname: String
  barkVolume: Int
  doesKnowCommand(dogCommand: DogCommand!): Boolean!
  isHousetrained(atOtherHomes: Boolean): Boolean!
  owner: Human
}

interface Sentient {
  name: String!
}

interface Pet {
  name: String!
}

type Alien implements Sentient {
  name: String!
  homePlanet: String
}

type Human implements Sentient {
  name: String!
}

enum CatCommand { JUMP }

type Cat implements Pet {
  name: String!
  nickname: String
  doesKnowCommand(catCommand: CatCommand!): Boolean!
  meowVolume: Int
}

union CatOrDog = Cat | Dog
union DogOrHuman = Dog | Human
union HumanOrAlien = Human | Alien

type QueryRoot {
  dog: Dog
}
</code></pre><section id="sec-Validation.Operations" secid="5.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Operations">5.1</a></span>Operations</h3><section id="sec-Named-Operation-Definitions" secid="5.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Named-Operation-Definitions">5.1.1</a></span>Named Operation Definitions</h4><section id="sec-Operation-Name-Uniqueness" secid="5.1.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Operation-Name-Uniqueness">5.1.1.1</a></span>Operation Name Uniqueness</h5><p><strong>Formal Specification</strong></p><ul><li>For each operation definition <var>operation</var> in the document</li><li>Let <var>operationName</var> be the name of <var>operation</var>.</li><li>If <var>operationName</var> exists<ul><li>Let <var>operations</var> be all operation definitions in the document named <var>operationName</var>.</li><li><var>operations</var> must be a set of one.</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Each named operation definition must be unique within a document when referred to by its name.</p><p>For example the following document is valid:</p><pre><code><span class="token keyword">query</span> getDogName <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> getOwnerName <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    owner <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>While this document is invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> getName <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> getName <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    owner <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>It is invalid even if the type of each operation is different:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> dogOperation <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">mutation</span> dogOperation <span class="token punctuation">{</span>
  mutateDog <span class="token punctuation">{</span>
    id
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Anonymous-Operation-Definitions" secid="5.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Anonymous-Operation-Definitions">5.1.2</a></span>Anonymous Operation Definitions</h4><section id="sec-Lone-Anonymous-Operation" secid="5.1.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Lone-Anonymous-Operation">5.1.2.1</a></span>Lone Anonymous Operation</h5><p><strong>Formal Specification</strong></p><ul><li>Let <var>operations</var> be all operation definitions in the document.</li><li>Let <var>anonymous</var> be all anonymous operation definitions in the document.</li><li>If <var>operations</var> is a set of more than 1:<ul><li><var>anonymous</var> must be empty.</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>GraphQL allows a short&#8208;hand form for defining query operations when only that one operation exists in the document.</p><p>For example the following document is valid:</p><pre><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>While this document is invalid:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> getName <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    owner <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section></section></section><section id="sec-Validation.Fields" secid="5.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Fields">5.2</a></span>Fields</h3><section id="sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types" secid="5.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types">5.2.1</a></span>Field Selections on Objects, Interfaces, and Unions Types</h4><p><strong>Formal Specification</strong></p><ul><li>For each <var>selection</var> in the document.</li><li>Let <var>fieldName</var> be the target field of <var>selection</var></li><li><var>fieldName</var> must be defined on type in scope</li></ul><p><strong>Explanatory Text</strong></p><p>The target field of a field selection must be defined on the scoped type of the selection set. There are no limitations on alias names.</p><p>For example the following fragment would not pass validation:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> fieldNotDefined <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  meowVolume
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> aliasedLyingFieldTargetNotDefined <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token attr-name">barkVolume</span><span class="token punctuation">:</span> kawVolume
<span class="token punctuation">}</span>
</code></pre><p>For interfaces, direct field selection can only be done on fields. Fields of concrete implementors are not relevant to the validity of the given interface&#8208;typed selection set.</p><p>For example, the following is valid:</p><pre><code><span class="token keyword">fragment</span> interfaceFieldSelection <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>
</code></pre><p>and the following is invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> definedOnImplementorsButNotInterface <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  nickname
<span class="token punctuation">}</span>
</code></pre><p>Because unions do not define fields, fields may not be directly selected from a union&#8208;typed selection set, with the exception of the meta&#8208;field <var>__typename</var>. Fields from a union&#8208;typed selection set must only be queried indirectly via a fragment.</p><p>For example the following is valid:</p><pre><code><span class="token keyword">fragment</span> inDirectFieldSelectionOnUnion <span class="token keyword">on</span> CatOrDog <span class="token punctuation">{</span>
  __typename
  <span class="token operator">...</span> <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    barkVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>But the following is invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> directFieldSelectionOnUnion <span class="token keyword">on</span> CatOrDog <span class="token punctuation">{</span>
  name
  barkVolume
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Field-Selection-Merging" secid="5.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Selection-Merging">5.2.2</a></span>Field Selection Merging</h4><p><strong>Formal Specification</strong></p><ul><li>Let <var>set</var> be any selection set defined in the GraphQL document.</li><li><span class="spec-call"><a href="#FieldsInSetCanMerge()">FieldsInSetCanMerge</a>(<var>set</var>)</span> must be true.</li></ul><div class="spec-algo" id="FieldsInSetCanMerge()"><span class="spec-call"><a href="#FieldsInSetCanMerge()">FieldsInSetCanMerge</a>(<var>set</var>)</span><ol><li>Let <var>fieldsForName</var> be the set of selections with a given response name in <var>set</var> including visiting fragments and inline fragments.</li><li>Given each pair of members <var>fieldA</var> and <var>fieldB</var> in <var>fieldsForName</var>:<ol><li><span class="spec-call"><a href="#SameResponseShape()">SameResponseShape</a>(<var>fieldA</var>, <var>fieldB</var>)</span> must be true.</li><li>If the parent types of <var>fieldA</var> and <var>fieldB</var> are equal or if either is not an Object Type:<ol><li><var>fieldA</var> and <var>fieldB</var> must have identical field names.</li><li><var>fieldA</var> and <var>fieldB</var> must have identical sets of arguments.</li><li>Let <var>mergedSet</var> be the result of adding the selection set of <var>fieldA</var> and the selection set of <var>fieldB</var>.</li><li><span class="spec-call"><a href="#FieldsInSetCanMerge()">FieldsInSetCanMerge</a>(<var>mergedSet</var>)</span> must be true.</li></ol></li></ol></li></ol></div><div class="spec-algo" id="SameResponseShape()"><span class="spec-call"><a href="#SameResponseShape()">SameResponseShape</a>(<var>fieldA</var>, <var>fieldB</var>)</span><ol><li>Let <var>typeA</var> be the return type of <var>fieldA</var>.</li><li>Let <var>typeB</var> be the return type of <var>fieldB</var>.</li><li>If <var>typeA</var> or <var>typeB</var> is Non&#8208;Null.<ol><li><var>typeA</var> and <var>typeB</var> must both be Non&#8208;Null.</li><li>Let <var>typeA</var> be the nullable type of <var>typeA</var></li><li>Let <var>typeB</var> be the nullable type of <var>typeB</var></li></ol></li><li>If <var>typeA</var> or <var>typeB</var> is List.<ol><li><var>typeA</var> and <var>typeB</var> must both be List.</li><li>Let <var>typeA</var> be the item type of <var>typeA</var></li><li>Let <var>typeB</var> be the item type of <var>typeB</var></li><li>Repeat from step 3.</li></ol></li><li>If <var>typeA</var> or <var>typeB</var> is Scalar or Enum.<ol><li><var>typeA</var> and <var>typeB</var> must be the same type.</li></ol></li><li>Assert: <var>typeA</var> and <var>typeB</var> are both composite types.</li><li>Let <var>mergedSet</var> be the result of adding the selection set of <var>fieldA</var> and the selection set of <var>fieldB</var>.</li><li>Let <var>fieldsForName</var> be the set of selections with a given response name in <var>mergedSet</var> including visiting fragments and inline fragments.</li><li>Given each pair of members <var>subfieldA</var> and <var>subfieldB</var> in <var>fieldsForName</var>:<ol><li><span class="spec-call"><a href="#SameResponseShape()">SameResponseShape</a>(<var>subfieldA</var>, <var>subfieldB</var>)</span> must be true.</li></ol></li></ol></div><p><strong>Explanatory Text</strong></p><p>If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.</p><p>For simple hand&#8208;written GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually.</p><p>The following selections correctly merge:</p><pre><code><span class="token keyword">fragment</span> mergeIdenticalFields <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> mergeIdenticalAliasesAndFields <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token attr-name">otherName</span><span class="token punctuation">:</span> name
  <span class="token attr-name">otherName</span><span class="token punctuation">:</span> name
<span class="token punctuation">}</span>
</code></pre><p>The following is not able to merge:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> conflictingBecauseAlias <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token attr-name">name</span><span class="token punctuation">:</span> nickname
  name
<span class="token punctuation">}</span>
</code></pre><p>Identical arguments are also merged if they have identical arguments. Both values and variables can be correctly merged.</p><p>For example the following correctly merge:</p><pre><code><span class="token keyword">fragment</span> mergeIdenticalFieldsWithIdenticalArgs <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> mergeIdenticalFieldsWithIdenticalValues <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> <span class="token variable">$dogCommand</span><span class="token punctuation">)</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> <span class="token variable">$dogCommand</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>The following do not correctly merge:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> conflictingArgsOnValues <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> HEEL<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> conflictingArgsValueAndVar <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> <span class="token variable">$dogCommand</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> conflictingArgsWithVars <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> <span class="token variable">$varOne</span><span class="token punctuation">)</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> <span class="token variable">$varTwo</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> differingArgs <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
  doesKnowCommand
<span class="token punctuation">}</span>
</code></pre><p>The following fields would not merge together, however both cannot be encountered against the same object, so they are safe:</p><pre><code><span class="token keyword">fragment</span> safeDifferingFields <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    <span class="token attr-name">volume</span><span class="token punctuation">:</span> barkVolume
  <span class="token punctuation">}</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    <span class="token attr-name">volume</span><span class="token punctuation">:</span> meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> safeDifferingArgs <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">catCommand</span><span class="token punctuation">:</span> JUMP<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>However, the field responses must be shapes which can be merged. For example, scalar values must not differ. In this example, <code>someValue</code> might be a <code>String</code> or an <code>Int</code>:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> conflictingDifferingResponses <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    <span class="token attr-name">someValue</span><span class="token punctuation">:</span> nickname
  <span class="token punctuation">}</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    <span class="token attr-name">someValue</span><span class="token punctuation">:</span> meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Leaf-Field-Selections" secid="5.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Leaf-Field-Selections">5.2.3</a></span>Leaf Field Selections</h4><p><strong>Formal Specification</strong></p><ul><li>For each <var>selection</var> in the document</li><li>Let <var>selectionType</var> be the result type of <var>selection</var></li><li>If <var>selectionType</var> is a scalar:<ul><li>The subselection set of that selection must be empty</li></ul></li><li>If <var>selectionType</var> is an interface, union, or object<ul><li>The subselection set of that selection must NOT BE empty</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Field selections on scalars are never allowed: scalars are the leaf nodes of any GraphQL query.</p><p>The following is valid.</p><pre><code><span class="token keyword">fragment</span> scalarSelection <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  barkVolume
<span class="token punctuation">}</span>
</code></pre><p>The following is invalid.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> scalarSelectionsNotAllowedOnBoolean <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  barkVolume <span class="token punctuation">{</span>
    sinceWhen
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Conversely the leaf field selections of GraphQL queries must be scalars. Leaf selections on objects, interfaces, and unions without subfields are disallowed.</p><p>Let&rsquo;s assume the following additions to the query root type of the schema:</p><pre><code>extend type QueryRoot {
  human: Human
  pet: Pet
  catOrDog: CatOrDog
}
</code></pre><p>The following examples are invalid</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> directQueryOnObjectWithoutSubFields <span class="token punctuation">{</span>
  human
<span class="token punctuation">}</span>

<span class="token keyword">query</span> directQueryOnInterfaceWithoutSubFields <span class="token punctuation">{</span>
  pet
<span class="token punctuation">}</span>

<span class="token keyword">query</span> directQueryOnUnionWithoutSubFields <span class="token punctuation">{</span>
  catOrDog
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Validation.Arguments" secid="5.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Arguments">5.3</a></span>Arguments</h3><p>Arguments are provided to both fields and directives. The following validation rules apply in both cases.</p><section id="sec-Argument-Names" secid="5.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Names">5.3.1</a></span>Argument Names</h4><p><strong>Formal Specification</strong></p><ul><li>For each <var>argument</var> in the document</li><li>Let <var>argumentName</var> be the Name of <var>argument</var>.</li><li>Let <var>argumentDefinition</var> be the argument definition provided by the parent field or definition named <var>argumentName</var>.</li><li><var>argumentDefinition</var> must exist.</li></ul><p><strong>Explanatory Text</strong></p><p>Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive.</p><p>For example the following are valid:</p><pre><code><span class="token keyword">fragment</span> argOnRequiredArg <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">dogCommand</span><span class="token punctuation">:</span> SIT<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> argOnOptional <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>the following is invalid since <code>command</code> is not defined on <code>DogCommand</code>.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> invalidArgName <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  doesKnowCommand<span class="token punctuation">(</span><span class="token attr-name">command</span><span class="token punctuation">:</span> CLEAN_UP_HOUSE<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>and this is also invalid as <code>unless</code> is not defined on <code>@include</code>.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> invalidArgName <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">unless</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>In order to explore more complicated argument examples, let&rsquo;s add the following to our type system:</p><pre><code>type Arguments {
  multipleReqs(x: Int!, y: Int!): Int!
  booleanArgField(booleanArg: Boolean): Boolean
  floatArgField(floatArg: Float): Float
  intArgField(intArg: Int): Int
  nonNullBooleanArgField(nonNullBooleanArg: Boolean!): Boolean!
  booleanListArgField(booleanListArg: [Boolean]!): [Boolean]
}

extend type QueryRoot {
  arguments: Arguments
}
</code></pre><p>Order does not matter in arguments. Therefore both the following example are valid.</p><pre><code><span class="token keyword">fragment</span> multipleArgs <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  multipleReqs<span class="token punctuation">(</span><span class="token attr-name">x</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token attr-name">y</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> multipleArgsReverseOrder <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  multipleReqs<span class="token punctuation">(</span><span class="token attr-name">y</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token attr-name">x</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Argument-Uniqueness" secid="5.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Uniqueness">5.3.2</a></span>Argument Uniqueness</h4><p>Fields and directives treat arguments as a mapping of argument name to value. More than one argument with the same name in an argument set is ambiguous and invalid.</p><p><strong>Formal Specification</strong></p><ul><li>For each <var>argument</var> in the Document.</li><li>Let <var>argumentName</var> be the Name of <var>argument</var>.</li><li>Let <var>arguments</var> be all Arguments named <var>argumentName</var> in the Argument Set which contains <var>argument</var>.</li><li><var>arguments</var> must be the set containing only <var>argument</var>.</li></ul></section><section id="sec-Argument-Values-Type-Correctness" secid="5.3.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Values-Type-Correctness">5.3.3</a></span>Argument Values Type Correctness</h4><section id="sec-Compatible-Values" secid="5.3.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Compatible-Values">5.3.3.1</a></span>Compatible Values</h5><p><strong>Formal Specification</strong></p><ul><li>For each <var>argument</var> in the document</li><li>Let <var>value</var> be the Value of <var>argument</var></li><li>If <var>value</var> is not a Variable<ul><li>Let <var>argumentName</var> be the Name of <var>argument</var>.</li><li>Let <var>argumentDefinition</var> be the argument definition provided by the parent field or definition named <var>argumentName</var>.</li><li>Let <var>type</var> be the type expected by <var>argumentDefinition</var>.</li><li>The type of <var>literalArgument</var> must be coercible to <var>type</var>.</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System chapter.</p><p>For example, an Int can be coerced into a Float.</p><pre><code><span class="token keyword">fragment</span> goodBooleanArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  booleanArgField<span class="token punctuation">(</span><span class="token attr-name">booleanArg</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> coercedIntIntoFloatArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  floatArgField<span class="token punctuation">(</span><span class="token attr-name">floatArg</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>An incoercible conversion, is string to int. Therefore, the following example is invalid.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> stringIntoInt <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  intArgField<span class="token punctuation">(</span><span class="token attr-name">intArg</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Required-Non-Null-Arguments" secid="5.3.3.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Required-Non-Null-Arguments">5.3.3.2</a></span>Required Non-Null Arguments</h5><ul><li>For each Field or Directive in the document.</li><li>Let <var>arguments</var> be the arguments provided by the Field or Directive.</li><li>Let <var>argumentDefinitions</var> be the set of argument definitions of that Field or Directive.</li><li>For each <var>definition</var> in <var>argumentDefinitions</var>:<ul><li>Let <var>type</var> be the expected type of <var>definition</var>.</li><li>If <var>type</var> is Non&#8208;Null:<ul><li>Let <var>argumentName</var> be the name of <var>definition</var>.</li><li>Let <var>argument</var> be the argument in <var>arguments</var> named <var>argumentName</var></li><li><var>argument</var> must exist.</li><li>Let <var>value</var> be the value of <var>argument</var>.</li><li><var>value</var> must not be the <span class="spec-keyword">null</span> literal.</li></ul></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Arguments can be required. Arguments are required if the type of the argument is non&#8208;null. If it is not non&#8208;null, the argument is optional. When an argument type is non&#8208;null, and is required, the explicit value <span class="spec-keyword">null</span> may also not be provided.</p><p>For example the following are valid:</p><pre><code><span class="token keyword">fragment</span> goodBooleanArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  booleanArgField<span class="token punctuation">(</span><span class="token attr-name">booleanArg</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> goodNonNullArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  nonNullBooleanArgField<span class="token punctuation">(</span><span class="token attr-name">nonNullBooleanArg</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>The argument can be omitted from a field with a nullable argument.</p><p>Therefore the following query is valid:</p><pre><code><span class="token keyword">fragment</span> goodBooleanArgDefault <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  booleanArgField
<span class="token punctuation">}</span>
</code></pre><p>but this is not valid on a non&#8208;null argument.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> missingRequiredArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  nonNullBooleanArgField
<span class="token punctuation">}</span>
</code></pre><p>Providing the explicit value <span class="spec-keyword">null</span> is also not valid.</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> missingRequiredArg <span class="token keyword">on</span> Arguments <span class="token punctuation">{</span>
  notNullBooleanArgField<span class="token punctuation">(</span><span class="token attr-name">nonNullBooleanArg</span><span class="token punctuation">:</span> null<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section></section></section><section id="sec-Validation.Fragments" secid="5.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Fragments">5.4</a></span>Fragments</h3><section id="sec-Fragment-Declarations" secid="5.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Declarations">5.4.1</a></span>Fragment Declarations</h4><section id="sec-Fragment-Name-Uniqueness" secid="5.4.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Name-Uniqueness">5.4.1.1</a></span>Fragment Name Uniqueness</h5><p><strong>Formal Specification</strong></p><ul><li>For each fragment definition <var>fragment</var> in the document</li><li>Let <var>fragmentName</var> be the name of <var>fragment</var>.</li><li>Let <var>fragments</var> be all fragment definitions in the document named <var>fragmentName</var>.</li><li><var>fragments</var> must be a set of one.</li></ul><p><strong>Explanatory Text</strong></p><p>Fragment definitions are referenced in fragment spreads by name. To avoid ambiguity, each fragment&rsquo;s name must be unique within a document.</p><p>Inline fragments are not considered fragment definitions, and are unaffected by this validation rule.</p><p>For example the following document is valid:</p><pre><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>fragmentOne
    <span class="token operator">...</span>fragmentTwo
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragmentOne <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragmentTwo <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  owner <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>While this document is invalid:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>fragmentOne
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragmentOne <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragmentOne <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  owner <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Fragment-Spread-Type-Existence" secid="5.4.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Spread-Type-Existence">5.4.1.2</a></span>Fragment Spread Type Existence</h5><p><strong>Formal Specification</strong></p><ul><li>For each named spread <var>namedSpread</var> in the document</li><li>Let <var>fragment</var> be the target of <var>namedSpread</var></li><li>The target type of <var>fragment</var> must be defined in the schema</li></ul><p><strong>Explanatory Text</strong></p><p>Fragments must be specified on types that exist in the schema. This applies for both named and inline fragments. If they are not defined in the schema, the query does not validate.</p><p>For example the following fragments are valid:</p><pre><code><span class="token keyword">fragment</span> correctType <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> inlineFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> inlineFragment2 <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>and the following do not validate:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> notOnExistingType <span class="token keyword">on</span> NotInSchema <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> inlineNotExistingType <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> NotInSchema <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Fragments-On-Composite-Types" secid="5.4.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragments-On-Composite-Types">5.4.1.3</a></span>Fragments On Composite Types</h5><p><strong>Formal Specification</strong></p><ul><li>For each <var>fragment</var> defined in the document.</li><li>The target type of fragment must have kind <span class="spec-nt">UNION</span>, <span class="spec-nt">INTERFACE</span>, or <span class="spec-nt">OBJECT</span>.</li></ul><p><strong>Explanatory Text</strong></p><p>Fragments can only be declared on unions, interfaces, and objects. They are invalid on scalars. They can only be applied on non&#8208;leaf fields. This rule applies to both inline and named fragments.</p><p>The following fragment declarations are valid:</p><pre><code><span class="token keyword">fragment</span> fragOnObject <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragOnInterface <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> fragOnUnion <span class="token keyword">on</span> CatOrDog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>and the following are invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> fragOnScalar <span class="token keyword">on</span> Int <span class="token punctuation">{</span>
  something
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> inlineFragOnScalar <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Boolean <span class="token punctuation">{</span>
    somethingElse
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Fragments-Must-Be-Used" secid="5.4.1.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragments-Must-Be-Used">5.4.1.4</a></span>Fragments Must Be Used</h5><p><strong>Formal Specification</strong></p><ul><li>For each <var>fragment</var> defined in the document.</li><li><var>fragment</var> must be the target of at least one spread in the document</li></ul><p><strong>Explanatory Text</strong></p><p>Defined fragments must be used within a query document.</p><p>For example the following is an invalid query document:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> nameFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span> <span class="token comment" spellcheck="true"># unused</span>
  name
<span class="token punctuation">}</span>

<span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Fragment-Spreads" secid="5.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Spreads">5.4.2</a></span>Fragment Spreads</h4><p>Field selection is also determined by spreading fragments into one another. The selection set of the target fragment is unioned with the selection set at the level at which the target fragment is referenced.</p><section id="sec-Fragment-spread-target-defined" secid="5.4.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spread-target-defined">5.4.2.1</a></span>Fragment spread target defined</h5><p><strong>Formal Specification</strong></p><ul><li>For every <var>namedSpread</var> in the document.</li><li>Let <var>fragment</var> be the target of <var>namedSpread</var></li><li><var>fragment</var> must be defined in the document</li></ul><p><strong>Explanatory Text</strong></p><p>Named fragment spreads must refer to fragments defined within the document. If the target of a spread is not defined, this is an error:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>undefinedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Fragment-spreads-must-not-form-cycles" secid="5.4.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spreads-must-not-form-cycles">5.4.2.2</a></span>Fragment spreads must not form cycles</h5><p><strong>Formal Specification</strong></p><ul><li>For each <var>fragmentDefinition</var> in the document</li><li>Let <var>visited</var> be the empty set.</li><li><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span></li></ul><p><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span> :</p><ul><li>Let <var>spreads</var> be all fragment spread descendants of <var>fragmentDefinition</var></li><li>For each <var>spread</var> in <var>spreads</var><ul><li><var>visited</var> must not contain <var>spread</var></li><li>Let <var>nextVisited</var> be the set including <var>spread</var> and members of <var>visited</var></li><li>Let <var>nextFragmentDefinition</var> be the target of <var>spread</var></li><li><span class="spec-call">DetectCycles(<var>nextFragmentDefinition</var>, <var>nextVisited</var>)</span></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.</p><p>This invalidates fragments that would result in an infinite spread:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>nameFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> nameFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
  <span class="token operator">...</span>barkVolumeFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> barkVolumeFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  barkVolume
  <span class="token operator">...</span>nameFragment
<span class="token punctuation">}</span>
</code></pre><p>If the above fragments were inlined, this would result in the infinitely large:</p><pre><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    name
    barkVolume
    name
    barkVolume
    name
    barkVolume
    name
    <span class="token comment" spellcheck="true"># forever...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>This also invalidates fragments that would result in an infinite recursion when executed against cyclic data:</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>dogFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> dogFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
  owner <span class="token punctuation">{</span>
    <span class="token operator">...</span>ownerFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> ownerFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  name
  pets <span class="token punctuation">{</span>
    <span class="token operator">...</span>dogFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Fragment-spread-is-possible" secid="5.4.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spread-is-possible">5.4.2.3</a></span>Fragment spread is possible</h5><p><strong>Formal Specification</strong></p><ul><li>For each <var>spread</var> (named or inline) defined in the document.</li><li>Let <var>fragment</var> be the target of <var>spread</var></li><li>Let <var>fragmentType</var> be the type condition of <var>fragment</var></li><li>Let <var>parentType</var> be the type of the selection set containing <var>spread</var></li><li>Let <var>applicableTypes</var> be the intersection of <span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>fragmentType</var>)</span> and <span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>parentType</var>)</span></li><li><var>applicableTypes</var> must not be empty.</li></ul><div class="spec-algo" id="GetPossibleTypes()"><span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>type</var>)</span><ol><li>If <var>type</var> is an object type, return a set containing <var>type</var></li><li>If <var>type</var> is an interface type, return the set of types implementing <var>type</var></li><li>If <var>type</var> is a union type, return the set of possible types of <var>type</var></li></ol></div><p><strong>Explanatory Text</strong></p><p>Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.</p><section id="sec-Object-Spreads-In-Object-Scope" secid="5.4.2.3.1"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Object-Spreads-In-Object-Scope">5.4.2.3.1</a></span>Object Spreads In Object Scope</h6><p>In the scope of an object type, the only valid object type fragment spread is one that applies to the same type that is in scope.</p><p>For example</p><pre><code><span class="token keyword">fragment</span> dogFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    barkVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>and the following is invalid</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> catInDogFragmentInvalid <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Abstract-Spreads-in-Object-Scope" secid="5.4.2.3.2"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Abstract-Spreads-in-Object-Scope">5.4.2.3.2</a></span>Abstract Spreads in Object Scope</h6><p>In scope of an object type, unions or interface spreads can be used if the object type implements the interface or is a member of the union.</p><p>For example</p><pre><code><span class="token keyword">fragment</span> petNameFragment <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> interfaceWithinObjectFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span>petNameFragment
<span class="token punctuation">}</span>
</code></pre><p>is valid because <span class="spec-nt">Dog</span> implements Pet.</p><p>Likewise</p><pre><code><span class="token keyword">fragment</span> catOrDogNameFragment <span class="token keyword">on</span> CatOrDog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> unionWithObjectFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span>catOrDogNameFragment
<span class="token punctuation">}</span>
</code></pre><p>is valid because <span class="spec-nt">Dog</span> is a member of the <span class="spec-nt">CatOrDog</span> union. It is worth noting that if one inspected the contents of the <span class="spec-nt">CatOrDogNameFragment</span> you could note that no valid results would ever be returned. However we do not specify this as invalid because we only consider the fragment declaration, not its body.</p></section><section id="sec-Object-Spreads-In-Abstract-Scope" secid="5.4.2.3.3"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Object-Spreads-In-Abstract-Scope">5.4.2.3.3</a></span>Object Spreads In Abstract Scope</h6><p>Union or interface spreads can be used within the context of an object type fragment, but only if the object type is one of the possible types of that interface or union.</p><p>For example, the following fragments are valid:</p><pre><code><span class="token keyword">fragment</span> petFragment <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  name
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    barkVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> catOrDogFragment <span class="token keyword">on</span> CatOrDog <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><var>petFragment</var> is valid because <span class="spec-nt">Dog</span> implements the interface <span class="spec-nt">Pet</span>. <var>catOrDogFragment</var> is valid because <span class="spec-nt">Cat</span> is a member of the <span class="spec-nt">CatOrDog</span> union.</p><p>By contrast the following fragments are invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> sentientFragment <span class="token keyword">on</span> Sentient <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    barkVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> humanOrAlienFragment <span class="token keyword">on</span> HumanOrAlien <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Cat <span class="token punctuation">{</span>
    meowVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><span class="spec-nt">Dog</span> does not implement the interface <span class="spec-nt">Sentient</span> and therefore <var>sentientFragment</var> can never return meaningful results. Therefore the fragment is invalid. Likewise <span class="spec-nt">Cat</span> is not a member of the union <span class="spec-nt">HumanOrAlien</span>, and it can also never return meaningful results, making it invalid.</p></section><section id="sec-Abstract-Spreads-in-Abstract-Scope" secid="5.4.2.3.4"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Abstract-Spreads-in-Abstract-Scope">5.4.2.3.4</a></span>Abstract Spreads in Abstract Scope</h6><p>Union or interfaces fragments can be used within each other. As long as there exists at least <em>one</em> object type that exists in the intersection of the possible types of the scope and the spread, the spread is considered valid.</p><p>So for example</p><pre><code><span class="token keyword">fragment</span> unionWithInterface <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  <span class="token operator">...</span>dogOrHumanFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> dogOrHumanFragment <span class="token keyword">on</span> DogOrHuman <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
    barkVolume
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>is consider valid because <span class="spec-nt">Dog</span> implements interface <span class="spec-nt">Pet</span> and is a member of <span class="spec-nt">DogOrHuman</span>.</p><p>However</p><pre class="spec-counter-example"><code><span class="token keyword">fragment</span> nonIntersectingInterfaces <span class="token keyword">on</span> Pet <span class="token punctuation">{</span>
  <span class="token operator">...</span>sentientFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> sentientFragment <span class="token keyword">on</span> Sentient <span class="token punctuation">{</span>
  name
<span class="token punctuation">}</span>
</code></pre><p>is not valid because there exists no type that implements both <span class="spec-nt">Pet</span> and <span class="spec-nt">Sentient</span>.</p></section></section></section></section><section id="sec-Values" secid="5.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Values">5.5</a></span>Values</h3><section id="sec-Input-Object-Field-Uniqueness" secid="5.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-Field-Uniqueness">5.5.1</a></span>Input Object Field Uniqueness</h4><p><strong>Formal Specification</strong></p><ul><li>For each input object value <var>inputObject</var> in the document.</li><li>For every <var>inputField</var> in <var>inputObject</var><ul><li>Let <var>name</var> be the Name of <var>inputField</var>.</li><li>Let <var>fields</var> be all Input Object Fields named <var>name</var> in <var>inputObject</var>.</li><li><var>fields</var> must be the set containing only <var>inputField</var>.</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Input objects must not contain more than one field of the same name, otherwise an ambiguity would exist which includes an ignored portion of syntax.</p><p>For example the following query will not pass validation.</p><pre class="spec-counter-example"><code><span class="token punctuation">{</span>
  field<span class="token punctuation">(</span><span class="token attr-name">arg</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token attr-name">field</span><span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Validation.Directives" secid="5.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Directives">5.6</a></span>Directives</h3><section id="sec-Directives-Are-Defined" secid="5.6.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-Defined">5.6.1</a></span>Directives Are Defined</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>directive</var> in a document.</li><li>Let <var>directiveName</var> be the name of <var>directive</var>.</li><li>Let <var>directiveDefinition</var> be the directive named <var>directiveName</var>.</li><li><var>directiveDefinition</var> must exist.</li></ul><p><strong>Explanatory Text</strong></p><p>GraphQL servers define what directives they support. For each usage of a directive, the directive must be available on that server.</p></section><section id="sec-Directives-Are-In-Valid-Locations" secid="5.6.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-In-Valid-Locations">5.6.2</a></span>Directives Are In Valid Locations</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>directive</var> in a document.</li><li>Let <var>directiveName</var> be the name of <var>directive</var>.</li><li>Let <var>directiveDefinition</var> be the directive named <var>directiveName</var>.</li><li>Let <var>locations</var> be the valid locations for <var>directiveDefinition</var>.</li><li>Let <var>adjacent</var> be the AST node the directive affects.</li><li><var>adjacent</var> must be represented by an item within <var>locations</var>.</li></ul><p><strong>Explanatory Text</strong></p><p>GraphQL servers define what directives they support and where they support them. For each usage of a directive, the directive must be used in a location that the server has declared support for.</p><p>For example the following query will not pass validation because <code>@skip</code> does not provide <code>QUERY</code> as a valid location.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  field
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Directives-Are-Unique-Per-Location" secid="5.6.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-Unique-Per-Location">5.6.3</a></span>Directives Are Unique Per Location</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>location</var> in the document for which Directives can apply:<ul><li>Let <var>directives</var> be the set of Directives which apply to <var>location</var>.</li><li>For each <var>directive</var> in <var>directives</var>:<ul><li>Let <var>directiveName</var> be the name of <var>directive</var>.</li><li>Let <var>namedDirectives</var> be the set of all Directives named <var>directiveName</var> in <var>directives</var>.</li><li><var>namedDirectives</var> must be a set of one.</li></ul></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Directives are used to describe some metadata or behavioral change on the definition they apply to. When more than one directive of the same name is used, the expected metadata or behavior becomes ambiguous, therefore only one of each directive is allowed per location.</p><p>For example, the following query will not pass validation because <code>@skip</code> has been used twice for the same field:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> <span class="token punctuation">(</span><span class="token variable">$foo</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token variable">$bar</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  field <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$foo</span><span class="token punctuation">)</span> <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$bar</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>However the following example is valid because <code>@skip</code> has been used only once per location, despite being used twice in the query and on the same named field:</p><pre><code><span class="token keyword">query</span> <span class="token punctuation">(</span><span class="token variable">$foo</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token variable">$bar</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  field <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    subfieldA
  <span class="token punctuation">}</span>
  field <span class="token directive function">@skip</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$bar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    subfieldB
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section></section><section id="sec-Validation.Variables" secid="5.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation.Variables">5.7</a></span>Variables</h3><section id="sec-Variable-Uniqueness" secid="5.7.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variable-Uniqueness">5.7.1</a></span>Variable Uniqueness</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>operation</var> in the document<ul><li>For every <var>variable</var> defined on <var>operation</var><ul><li>Let <var>variableName</var> be the name of <var>variable</var></li><li>Let <var>variables</var> be the set of all variables named <var>variableName</var> on <var>operation</var></li><li><var>variables</var> must be a set of one</li></ul></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>If any operation defines more than one variable with the same name, it is ambiguous and invalid. It is invalid even if the type of the duplicate variable is the same.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> houseTrainedQuery<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>It is valid for multiple operations to define a variable with the same name. If two operations reference the same fragment, it might actually be necessary:</p><pre><code><span class="token keyword">query</span> A<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>HouseTrainedFragment
<span class="token punctuation">}</span>

<span class="token keyword">query</span> B<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>HouseTrainedFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> HouseTrainedFragment <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Variable-Default-Values-Are-Correctly-Typed" secid="5.7.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variable-Default-Values-Are-Correctly-Typed">5.7.2</a></span>Variable Default Values Are Correctly Typed</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>operation</var> in a document</li><li>For every <var>variable</var> on each <var>operation</var><ul><li>Let <var>variableType</var> be the type of <var>variable</var></li><li>If <var>variableType</var> is non&#8208;null it cannot have a default value</li><li>If <var>variable</var> has a default value it must be of the same type or able to be coerced to <var>variableType</var></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Variables defined by operations are allowed to define default values if the type of that variable is not non&#8208;null.</p><p>For example the following query will pass validation.</p><pre><code><span class="token keyword">query</span> houseTrainedQuery<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>However if the variable is defined as non&#8208;null, default values are unreachable. Therefore queries such as the following fail validation</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> houseTrainedQuery<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token operator">!</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Default values must be compatible with the types of variables. Types must match or they must be coercible to the type.</p><p>Non&#8208;matching types fail, such as in the following example:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> houseTrainedQuery<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>However if a type is coercible the query will pass validation.</p><p>For example:</p><pre><code><span class="token keyword">query</span> intToFloatQuery<span class="token punctuation">(</span><span class="token variable">$floatVar</span><span class="token punctuation">:</span> Float <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    floatArgField<span class="token punctuation">(</span><span class="token attr-name">floatArg</span><span class="token punctuation">:</span> <span class="token variable">$floatVar</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Variables-Are-Input-Types" secid="5.7.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variables-Are-Input-Types">5.7.3</a></span>Variables Are Input Types</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>operation</var> in a <var>document</var></li><li>For every <var>variable</var> on each <var>operation</var><ul><li>Let <var>variableType</var> be the type of <var>variable</var></li><li>While <var>variableType</var> is <span class="spec-nt">LIST</span> or <span class="spec-nt">NON_NULL</span><ul><li>Let <var>variableType</var> be the referenced type of <var>variableType</var></li></ul></li><li><var>variableType</var> must be of kind <span class="spec-nt">SCALAR</span>, <span class="spec-nt">ENUM</span> or <span class="spec-nt">INPUT_OBJECT</span></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Variables can only be scalars, enums, input objects, or lists and non&#8208;null variants of those types. These are known as input types. Objects, unions, and interfaces cannot be used as inputs.</p><p>For these examples, consider the following typesystem additions:</p><pre><code>input ComplexInput { name: String, owner: String }

extend type QueryRoot {
  findDog(complex: ComplexInput): Dog
  booleanList(booleanListArg: [Boolean!]): Boolean
}
</code></pre><p>The following queries are valid:</p><pre><code><span class="token keyword">query</span> takesBoolean<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> takesComplexInput<span class="token punctuation">(</span><span class="token variable">$complexInput</span><span class="token punctuation">:</span> ComplexInput<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  findDog<span class="token punctuation">(</span><span class="token attr-name">complex</span><span class="token punctuation">:</span> <span class="token variable">$complexInput</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> TakesListOfBooleanBang<span class="token punctuation">(</span><span class="token variable">$booleans</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Boolean<span class="token operator">!</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  booleanList<span class="token punctuation">(</span><span class="token attr-name">booleanListArg</span><span class="token punctuation">:</span> <span class="token variable">$booleans</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>The following queries are invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> takesCat<span class="token punctuation">(</span><span class="token variable">$cat</span><span class="token punctuation">:</span> Cat<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true"># ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> takesDogBang<span class="token punctuation">(</span><span class="token variable">$dog</span><span class="token punctuation">:</span> Dog<span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true"># ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> takesListOfPet<span class="token punctuation">(</span><span class="token variable">$pets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Pet<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true"># ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> takesCatOrDog<span class="token punctuation">(</span><span class="token variable">$catOrDog</span><span class="token punctuation">:</span> CatOrDog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true"># ...</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-All-Variable-Uses-Defined" secid="5.7.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variable-Uses-Defined">5.7.4</a></span>All Variable Uses Defined</h4><p><strong>Formal Specification</strong></p><ul><li>For each <var>operation</var> in a document<ul><li>For each <var>variableUsage</var> in scope, variable must be in <var>operation</var>&lsquo;s variable list.</li><li>Let <var>fragments</var> be every fragment referenced by that <var>operation</var> transitively</li><li>For each <var>fragment</var> in <var>fragments</var><ul><li>For each <var>variableUsage</var> in scope of <var>fragment</var>, variable must be in <var>operation</var>&lsquo;s variable list.</li></ul></li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Variables are scoped on a per&#8208;operation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation</p><p>For example:</p><pre><code><span class="token keyword">query</span> variableIsDefined<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>is valid. $<var>atOtherHomes</var> is defined by the operation.</p><p>By contrast the following query is invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> variableIsNotDefined <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>$<var>atOtherHomes</var> is not defined by the operation.</p><p>Fragments complicate this rule. Any fragment transitively included by an operation has access to the variables defined by that operation. Fragments can appear within multiple operations and therefore variable usages must correspond to variable definitions in all of those operations.</p><p>For example the following is valid:</p><pre><code><span class="token keyword">query</span> variableIsDefinedUsedInSingleFragment<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>since <var>isHousetrainedFragment</var> is used within the context of the operation <var>variableIsDefinedUsedInSingleFragment</var> and the variable is defined by that operation.</p><p>On the other hand, if a fragment is included within an operation that does not define a referenced variable, the query is invalid.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> variableIsNotDefinedUsedInSingleFragment <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>This applies transitively as well, so the following also fails:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> variableIsNotDefinedUsedInNestedFragment <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>outerHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> outerHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  <span class="token operator">...</span>isHousetrainedFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>Variables must be defined in all operations in which a fragment is used.</p><pre><code><span class="token keyword">query</span> housetrainedQueryOne<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> housetrainedQueryTwo<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>However the following does not validate:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> housetrainedQueryOne<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> housetrainedQueryTwoNotDefined <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>This is because <var>housetrainedQueryTwoNotDefined</var> does not define a variable $<var>atOtherHomes</var> but that variable is used by <var>isHousetrainedFragment</var> which is included in that operation.</p></section><section id="sec-All-Variables-Used" secid="5.7.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variables-Used">5.7.5</a></span>All Variables Used</h4><p><strong>Formal Specification</strong></p><ul><li>For every <var>operation</var> in the document.</li><li>Let <var>variables</var> be the variables defined by that <var>operation</var></li><li>Each <var>variable</var> in <var>variables</var> must be used at least once in either the operation scope itself or any fragment transitively referenced by that operation.</li></ul><p><strong>Explanatory Text</strong></p><p>All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error.</p><p>For example the following is invalid:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> variableUnused<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    isHousetrained
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>because $<var>atOtherHomes</var> is not referenced.</p><p>These rules apply to transitive fragment spreads as well:</p><pre><code><span class="token keyword">query</span> variableUsedInFragment<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>The above is valid since $<var>atOtherHomes</var> is used in <var>isHousetrainedFragment</var> which is included by <var>variableUsedInFragment</var>.</p><p>If that fragment did not have a reference to $<var>atOtherHomes</var> it would be not valid:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> variableNotUsedWithinFragment<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>isHousetrainedWithoutVariableFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedWithoutVariableFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained
<span class="token punctuation">}</span>
</code></pre><p>All operations in a document must use all of their variables.</p><p>As a result, the following document does not validate.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> queryWithUsedVar<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">query</span> queryWithExtraVar<span class="token punctuation">(</span><span class="token variable">$atOtherHomes</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span> <span class="token variable">$extra</span><span class="token punctuation">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog <span class="token punctuation">{</span>
    <span class="token operator">...</span>isHousetrainedFragment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> isHousetrainedFragment <span class="token keyword">on</span> Dog <span class="token punctuation">{</span>
  isHousetrained<span class="token punctuation">(</span><span class="token attr-name">atOtherHomes</span><span class="token punctuation">:</span> <span class="token variable">$atOtherHomes</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>This document is not valid because <var>queryWithExtraVar</var> defines an extraneous variable.</p></section><section id="sec-All-Variable-Usages-are-Allowed" secid="5.7.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variable-Usages-are-Allowed">5.7.6</a></span>All Variable Usages are Allowed</h4><p><strong>Formal Specification</strong></p><ul><li>For each <var>operation</var> in <var>document</var></li><li>Let <var>variableUsages</var> be all usages transitively included in the <var>operation</var></li><li>For each <var>variableUsage</var> in <var>variableUsages</var><ul><li>Let <var>variableType</var> be the type of variable definition in the <var>operation</var></li><li>Let <var>argumentType</var> be the type of the argument the variable is passed to.</li><li>Let <var>hasDefault</var> be true if the variable definition defines a default.</li><li>AreTypesCompatible(<var>argumentType</var>, <var>variableType</var>, <var>hasDefault</var>) must be true</li></ul></li><li>AreTypesCompatible(<var>argumentType</var>, <var>variableType</var>, <var>hasDefault</var>):<ul><li>If <var>hasDefault</var> is true, treat the <var>variableType</var> as non&#8208;null.</li><li>If inner type of <var>argumentType</var> and <var>variableType</var> are different, return false</li><li>If <var>argumentType</var> and <var>variableType</var> have different list dimensions, return false</li><li>If any list level of <var>variableType</var> is not non&#8208;null, and the corresponding level in <var>argument</var> is non&#8208;null, the types are not compatible.</li></ul></li></ul><p><strong>Explanatory Text</strong></p><p>Variable usages must be compatible with the arguments they are passed to.</p><p>Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a non&#8208;null argument type.</p><p>Types must match:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> intCannotGoIntoBoolean<span class="token punctuation">(</span><span class="token variable">$intArg</span><span class="token punctuation">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    booleanArgField<span class="token punctuation">(</span><span class="token attr-name">booleanArg</span><span class="token punctuation">:</span> <span class="token variable">$intArg</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>$<var>intArg</var> typed as <span class="spec-nt">Int</span> cannot be used as a argument to <var>booleanArg</var>, typed as <span class="spec-nt">Boolean</span>.</p><p>List cardinality must also be the same. For example, lists cannot be passed into singular values.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> booleanListCannotGoIntoBoolean<span class="token punctuation">(</span><span class="token variable">$booleanListArg</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Boolean<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    booleanArgField<span class="token punctuation">(</span><span class="token attr-name">booleanArg</span><span class="token punctuation">:</span> <span class="token variable">$booleanListArg</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Nullability must also be respected. In general a nullable variable cannot be passed to a non&#8208;null argument.</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> booleanArgQuery<span class="token punctuation">(</span><span class="token variable">$booleanArg</span><span class="token punctuation">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    nonNullBooleanArgField<span class="token punctuation">(</span><span class="token attr-name">nonNullBooleanArg</span><span class="token punctuation">:</span> <span class="token variable">$booleanArg</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>A notable exception is when default arguments are provided. They are, in effect, treated as non&#8208;nulls.</p><pre><code><span class="token keyword">query</span> booleanArgQueryWithDefault<span class="token punctuation">(</span><span class="token variable">$booleanArg</span><span class="token punctuation">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    nonNullBooleanArgField<span class="token punctuation">(</span><span class="token attr-name">nonNullBooleanArg</span><span class="token punctuation">:</span> <span class="token variable">$booleanArg</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>For list types, the same rules around nullability apply to both outer types and inner types. A nullable list cannot be passed to a non&#8208;null list, and a list of nullable values cannot be passed to a list of non&#8208;null values. The following is valid:</p><pre><code><span class="token keyword">query</span> nonNullListToList<span class="token punctuation">(</span><span class="token variable">$nonNullBooleanList</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Boolean<span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    booleanListArgField<span class="token punctuation">(</span><span class="token attr-name">booleanListArg</span><span class="token punctuation">:</span> <span class="token variable">$nonNullBooleanList</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>However, a nullable list cannot be passed to a non&#8208;null list:</p><pre class="spec-counter-example"><code><span class="token keyword">query</span> listToNonNullList<span class="token punctuation">(</span><span class="token variable">$booleanList</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Boolean<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments <span class="token punctuation">{</span>
    nonNullBooleanListField<span class="token punctuation">(</span><span class="token attr-name">nonNullBooleanListArg</span><span class="token punctuation">:</span> <span class="token variable">$booleanList</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>This would fail validation because a <code>[T]</code> cannot be passed to a <code>[T]!</code>.</p><p>Similarly a <code>[T]</code> cannot be passed to a <code>[T!]</code>. </p></section></section></section><section id="sec-Execution" secid="6"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Execution">6</a></span>Execution</h2><p>GraphQL generates a response from a request via execution.</p><p>A request for execution consists of a few pieces of information:</p><ul><li>The schema to use, typically solely provided by the GraphQL service.</li><li>A Document containing GraphQL Operations and Fragments to execute.</li><li>Optionally: The name of the Operation in the Document to execute.</li><li>Optionally: Values for any Variables defined by the Operation.</li><li>An initial value corresponding to the root type being executed. Conceptually, an initial value represents the &ldquo;universe&rdquo; of data available via a GraphQL Service. It is common for a GraphQL Service to always use the same initial value for every request.</li></ul><p>Given this information, the result of <span class="spec-call"><a href="#ExecuteRequest()">ExecuteRequest</a>()</span> produces the response, to be formatted according to the Response section below.</p><section id="sec-Executing-Requests" secid="6.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Requests">6.1</a></span>Executing Requests</h3><p>To execute a request, the executor must have a parsed <code>Document</code> (as defined in the &ldquo;Query Language&rdquo; part of this spec) and a selected operation name to run if the document defines multiple operations, otherwise the document is expected to only contain a single operation. The result of the request is determined by the result of executing this operation according to the &ldquo;Executing Operations&rdquo; section below.</p><div class="spec-algo" id="ExecuteRequest()"><span class="spec-call"><a href="#ExecuteRequest()">ExecuteRequest</a>(<var>schema</var>, <var>document</var>, <var>operationName</var>, <var>variableValues</var>, <var>initialValue</var>)</span><ol><li>Let <var>operation</var> be the result of <span class="spec-call"><a href="#GetOperation()">GetOperation</a>(<var>document</var>, <var>operationName</var>)</span>.</li><li>Let <var>coercedVariableValues</var> be the result of <span class="spec-call"><a href="#CoerceVariableValues()">CoerceVariableValues</a>(<var>schema</var>, <var>operation</var>, <var>variableValues</var>)</span>.</li><li>If <var>operation</var> is a query operation:<ol><li>Return <span class="spec-call"><a href="#ExecuteQuery()">ExecuteQuery</a>(<var>operation</var>, <var>schema</var>, <var>coercedVariableValues</var>, <var>initialValue</var>)</span>.</li></ol></li><li>Otherwise if <var>operation</var> is a mutation operation:<ol><li>Return <span class="spec-call"><a href="#ExecuteMutation()">ExecuteMutation</a>(<var>operation</var>, <var>schema</var>, <var>coercedVariableValues</var>, <var>initialValue</var>)</span>.</li></ol></li></ol></div><div class="spec-algo" id="GetOperation()"><span class="spec-call"><a href="#GetOperation()">GetOperation</a>(<var>document</var>, <var>operationName</var>)</span><ol><li>If <var>operationName</var> is <span class="spec-keyword">null</span>:<ol><li>If <var>document</var> contains exactly one operation.<ol><li>Return the Operation contained in the <var>document</var>.</li></ol></li><li>Otherwise produce a query error requiring <var>operationName</var>.</li></ol></li><li>Otherwise:<ol><li>Let <var>operation</var> be the Operation named <var>operationName</var> in <var>document</var>.</li><li>If <var>operation</var> was not found, produce a query error.</li><li>Return <var>operation</var>.</li></ol></li></ol></div><section id="sec-Validating-Requests" secid="6.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Validating-Requests">6.1.1</a></span>Validating Requests</h4><p>As explained in the Validation section, only requests which pass all validation rules should be executed. If validation errors are known, they should be reported in the list of &ldquo;errors&rdquo; in the response and the request must fail without execution.</p><p>Typically validation is performed in the context of a request immediately before execution, however a GraphQL service may execute a request without immediately validating it if that exact same request is known to have been validated before. A GraphQL service should only execute requests which <em>at some point</em> were known to be free of any validation errors, and have since not changed.</p><p>For example: the request may be validated during development, provided it does not later change, or a service may validate a request once and memoize the result to avoid validating the same request again in the future.</p></section><section id="sec-Coercing-Variable-Values" secid="6.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Coercing-Variable-Values">6.1.2</a></span>Coercing Variable Values</h4><p>If the operation has defined any variables, then the values for those variables need to be coerced using the input coercion rules of variable&rsquo;s declared type. If a query error is encountered during input coercion of variable values, then the operation fails without execution.</p><div class="spec-algo" id="CoerceVariableValues()"><span class="spec-call"><a href="#CoerceVariableValues()">CoerceVariableValues</a>(<var>schema</var>, <var>operation</var>, <var>variableValues</var>)</span><ol><li>Let <var>coercedValues</var> be an empty unordered Map.</li><li>Let <var>variableDefinitions</var> be the variables defined by <var>operation</var>.</li><li>For each <var>variableDefinition</var> in <var>variableDefinitions</var>:<ol><li>Let <var>variableName</var> be the name of <var>variableDefinition</var>.</li><li>Let <var>variableType</var> be the expected type of <var>variableDefinition</var>.</li><li>Let <var>defaultValue</var> be the default value for <var>variableDefinition</var>.</li><li>Let <var>value</var> be the value provided in <var>variableValues</var> for the name <var>variableName</var>.</li><li>If <var>value</var> does not exist (was not provided in <var>variableValues</var>):<ol><li>If <var>defaultValue</var> exists (including <span class="spec-keyword">null</span>):<ol><li>Add an entry to <var>coercedValues</var> named <var>variableName</var> with the value <var>defaultValue</var>.</li></ol></li><li>Otherwise if <var>variableType</var> is a Non&#8208;Nullable type, throw a query error.</li><li>Otherwise, continue to the next variable definition.</li></ol></li><li>Otherwise, if <var>value</var> cannot be coerced according to the input coercion rules of <var>variableType</var>, throw a query error.</li><li>Let <var>coercedValue</var> be the result of coercing <var>value</var> according to the input coercion rules of <var>variableType</var>.</li><li>Add an entry to <var>coercedValues</var> named <var>variableName</var> with the value <var>coercedValue</var>.</li></ol></li><li>Return <var>coercedValues</var>.</li></ol></div><div class="spec-note">This algorithm is very similar to <span class="spec-call"><a href="#CoerceArgumentValues()">CoerceArgumentValues</a>()</span>.</div></section></section><section id="sec-Executing-Operations" secid="6.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Operations">6.2</a></span>Executing Operations</h3><p>The type system, as described in the &ldquo;Type System&rdquo; section of the spec, must provide a query root object type. If mutations are supported, it must also provide a mutation root object type.</p><p>If the operation is a query, the result of the operation is the result of executing the query&rsquo;s top level selection set with the query root object type.</p><p>An initial value may be provided when executing a query.</p><div class="spec-algo" id="ExecuteQuery()"><span class="spec-call"><a href="#ExecuteQuery()">ExecuteQuery</a>(<var>query</var>, <var>schema</var>, <var>variableValues</var>, <var>initialValue</var>)</span><ol><li>Let <var>queryType</var> be the root Query type in <var>schema</var>.</li><li>Assert: <var>queryType</var> is an Object type.</li><li>Let <var>selectionSet</var> be the top level Selection Set in <var>query</var>.</li><li>Let <var>data</var> be the result of running <span class="spec-call"><a href="#ExecuteSelectionSet()">ExecuteSelectionSet</a>(<var>selectionSet</var>, <var>queryType</var>, <var>initialValue</var>, <var>variableValues</var>)</span> <em>normally</em> (allowing parallelization).</li><li>Let <var>errors</var> be any <em>field errors</em> produced while executing the selection set.</li><li>Return an unordered map containing <var>data</var> and <var>errors</var>.</li></ol></div><p>If the operation is a mutation, the result of the operation is the result of executing the mutation&rsquo;s top level selection set on the mutation root object type. This selection set should be executed serially.</p><p>It is expected that the top level fields in a mutation operation perform side&#8208;effects on the underlying data system. Serial execution of the provided mutations ensures against race conditions during these side&#8208;effects.</p><div class="spec-algo" id="ExecuteMutation()"><span class="spec-call"><a href="#ExecuteMutation()">ExecuteMutation</a>(<var>mutation</var>, <var>schema</var>, <var>variableValues</var>, <var>initialValue</var>)</span><ol><li>Let <var>mutationType</var> be the root Mutation type in <var>schema</var>.</li><li>Assert: <var>mutationType</var> is an Object type.</li><li>Let <var>selectionSet</var> be the top level Selection Set in <var>mutation</var>.</li><li>Let <var>data</var> be the result of running <span class="spec-call"><a href="#ExecuteSelectionSet()">ExecuteSelectionSet</a>(<var>selectionSet</var>, <var>mutationType</var>, <var>initialValue</var>, <var>variableValues</var>)</span> <em>serially</em>.</li><li>Let <var>errors</var> be any <em>field errors</em> produced while executing the selection set.</li><li>Return an unordered map containing <var>data</var> and <var>errors</var>.</li></ol></div></section><section id="sec-Executing-Selection-Sets" secid="6.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Selection-Sets">6.3</a></span>Executing Selection Sets</h3><p>To execute a selection set, the object value being evaluated and the object type need to be known, as well as whether it must be executed serially, or may be executed in parallel.</p><p>First, the selection set is turned into a grouped field set; then, each represented field in the grouped field set produces an entry into a response map.</p><div class="spec-algo" id="ExecuteSelectionSet()"><span class="spec-call"><a href="#ExecuteSelectionSet()">ExecuteSelectionSet</a>(<var>selectionSet</var>, <var>objectType</var>, <var>objectValue</var>, <var>variableValues</var>)</span><ol><li>Let <var>groupedFieldSet</var> be the result of <span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>selectionSet</var>, <var>variableValues</var>)</span>.</li><li>Initialize <var>resultMap</var> to an empty ordered map.</li><li>For each <var>groupedFieldSet</var> as <var>responseKey</var> and <var>fields</var>:<ol><li>Let <var>fieldName</var> be the name of the first entry in <var>fields</var>. Note: This value is unaffected if an alias is used.</li><li>Let <var>fieldType</var> be the return type defined for the field <var>fieldName</var> of <var>objectType</var>.</li><li>If <var>fieldType</var> is <span class="spec-keyword">null</span>:<ol><li>Continue to the next iteration of <var>groupedFieldSet</var>.</li></ol></li><li>Let <var>responseValue</var> be <span class="spec-call"><a href="#ExecuteField()">ExecuteField</a>(<var>objectType</var>, <var>objectValue</var>, <var>fields</var>, <var>fieldType</var>, <var>variableValues</var>)</span>.</li><li>Set <var>responseValue</var> as the value for <var>responseKey</var> in <var>resultMap</var>.</li></ol></li><li>Return <var>resultMap</var>.</li></ol></div><div class="spec-note"><var>responseMap</var> is ordered by which fields appear first in the query. This is explained in greater detail in the Field Collection section below.</div><section id="sec-Normal-and-Serial-Execution" secid="6.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Normal-and-Serial-Execution">6.3.1</a></span>Normal and Serial Execution</h4><p>Normally the executor can execute the entries in a grouped field set in whatever order it chooses (often in parallel). Because the resolution of fields other than top&#8208;level mutation fields must always be side effect&#8208;free and idempotent, the execution order must not affect the result, and hence the server has the freedom to execute the field entries in whatever order it deems optimal.</p><p>For example, given the following grouped field set to be executed normally:</p><pre><code><span class="token punctuation">{</span>
  birthday <span class="token punctuation">{</span>
    month
  <span class="token punctuation">}</span>
  address <span class="token punctuation">{</span>
    street
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>A valid GraphQL executor can resolve the four fields in whatever order it chose (however of course <code>birthday</code> must be resolved before <code>month</code>, and <code>address</code> before <code>street</code>).</p><p>When executing a mutation, the selections in the top most selection set will be executed in serial order.</p><p>When executing a grouped field set serially, the executor must consider each entry from the grouped field set in the order provided in the grouped field set. It must determine the corresponding entry in the result map for each item to completion before it continues on to the next item in the grouped field set:</p><p>For example, given the following selection set to be executed serially:</p><pre><code><span class="token punctuation">{</span>
  changeBirthday<span class="token punctuation">(</span><span class="token attr-name">birthday</span><span class="token punctuation">:</span> <span class="token variable">$newBirthday</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    month
  <span class="token punctuation">}</span>
  changeAddress<span class="token punctuation">(</span><span class="token attr-name">address</span><span class="token punctuation">:</span> <span class="token variable">$newAddress</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    street
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The executor must, in serial:</p><ul><li>Run <span class="spec-call"><a href="#ExecuteField()">ExecuteField</a>()</span> for <code>changeBirthday</code>, which during <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>()</span> will execute the <code>{ month }</code> sub&#8208;selection set normally.</li><li>Run <span class="spec-call"><a href="#ExecuteField()">ExecuteField</a>()</span> for <code>changeAddress</code>, which during <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>()</span> will execute the <code>{ street }</code> sub&#8208;selection set normally.</li></ul><p>As an illustrative example, let&rsquo;s assume we have a mutation field <code>changeTheNumber</code> that returns an object containing one field, <code>theNumber</code>. If we execute the following selection set serially:</p><pre><code><span class="token punctuation">{</span>
  <span class="token attr-name">first</span><span class="token punctuation">:</span> changeTheNumber<span class="token punctuation">(</span><span class="token attr-name">newNumber</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    theNumber
  <span class="token punctuation">}</span>
  <span class="token attr-name">second</span><span class="token punctuation">:</span> changeTheNumber<span class="token punctuation">(</span><span class="token attr-name">newNumber</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    theNumber
  <span class="token punctuation">}</span>
  <span class="token attr-name">third</span><span class="token punctuation">:</span> changeTheNumber<span class="token punctuation">(</span><span class="token attr-name">newNumber</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    theNumber
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The executor will execute the following serially:</p><ul><li>Resolve the <code>changeTheNumber(newNumber: 1)</code> field</li><li>Execute the <code>{ theNumber }</code> sub&#8208;selection set of <code>first</code> normally</li><li>Resolve the <code>changeTheNumber(newNumber: 3)</code> field</li><li>Execute the <code>{ theNumber }</code> sub&#8208;selection set of <code>second</code> normally</li><li>Resolve the <code>changeTheNumber(newNumber: 2)</code> field</li><li>Execute the <code>{ theNumber }</code> sub&#8208;selection set of <code>third</code> normally</li></ul><p>A correct executor must generate the following result for that selection set:</p><pre><code><span class="token punctuation">{</span>
  <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"theNumber"</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"second"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"theNumber"</span><span class="token punctuation">:</span> <span class="token number">3</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">"third"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"theNumber"</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></section><section id="sec-Field-Collection" secid="6.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Collection">6.3.2</a></span>Field Collection</h4><p>Before execution, the selection set is converted to a grouped field set by calling <span class="spec-call"><a href="#CollectFields()">CollectFields</a>()</span>. Each entry in the grouped field set is a list of fields that share a response key. This ensures all fields with the same response key (alias or field name) included via referenced fragments are executed at the same time.</p><p>As an example, collecting the fields of this selection set would collect two instances of the field <code>a</code> and one of field <code>b</code>:</p><pre><code><span class="token punctuation">{</span>
  a <span class="token punctuation">{</span>
    subfield1
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>ExampleFragment
<span class="token punctuation">}</span>

<span class="token keyword">fragment</span> ExampleFragment on Query <span class="token punctuation">{</span>
  a <span class="token punctuation">{</span>
    subfield2
  <span class="token punctuation">}</span>
  b
<span class="token punctuation">}</span>
</code></pre><p>The depth&#8208;first&#8208;search order of the field groups produced by <span class="spec-call"><a href="#CollectFields()">CollectFields</a>()</span> is maintained through execution, ensuring that fields appear in the executed response in a stable and predictable order.</p><div class="spec-algo" id="CollectFields()"><span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>selectionSet</var>, <var>variableValues</var>, <var>visitedFragments</var>)</span><ol><li>If <var>visitedFragments</var> if not provided, initialize it to the empty set.</li><li>Initialize <var>groupedFields</var> to an empty ordered map of lists.</li><li>For each <var>selection</var> in <var>selectionSet</var>:<ol><li>If <var>selection</var> provides the directive <code>@skip</code>, let <var>skipDirective</var> be that directive.<ol><li>If <var>skipDirective</var>&lsquo;s <var>if</var> argument is <span class="spec-keyword">true</span> or is a variable in <var>variableValues</var> with the value <span class="spec-keyword">true</span>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li></ol></li><li>If <var>selection</var> provides the directive <code>@include</code>, let <var>includeDirective</var> be that directive.<ol><li>If <var>includeDirective</var>&lsquo;s <var>if</var> argument is not <span class="spec-keyword">true</span> and is not a variable in <var>variableValues</var> with the value <span class="spec-keyword">true</span>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li></ol></li><li>If <var>selection</var> is a <span class="spec-nt"><a href="#Field">Field</a></span>:<ol><li>Let <var>responseKey</var> be the response key of <var>selection</var>.</li><li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li><li>Append <var>selection</var> to the <var>groupForResponseKey</var>.</li></ol></li><li>If <var>selection</var> is a <span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span>:<ol><li>Let <var>fragmentSpreadName</var> be the name of <var>selection</var>.</li><li>If <var>fragmentSpreadName</var> is in <var>visitedFragments</var>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li><li>Add <var>fragmentSpreadName</var> to <var>visitedFragments</var>.</li><li>Let <var>fragment</var> be the Fragment in the current Document whose name is <var>fragmentSpreadName</var>.</li><li>If no such <var>fragment</var> exists, continue with the next <var>selection</var> in <var>selectionSet</var>.</li><li>Let <var>fragmentType</var> be the type condition on <var>fragment</var>.</li><li>If <span class="spec-call"><a href="#DoesFragmentTypeApply()">DoesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span> is false, continue with the next <var>selection</var> in <var>selectionSet</var>.</li><li>Let <var>fragmentSelectionSet</var> be the top&#8208;level selection set of <var>fragment</var>.</li><li>Let <var>fragmentGroupedFieldSet</var> be the result of calling <span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>fragmentSelectionSet</var>, <var>visitedFragments</var>)</span>.</li><li>For each <var>fragmentGroup</var> in <var>fragmentGroupedFieldSet</var>:<ol><li>Let <var>responseKey</var> be the response key shared by all fields in <var>fragmentGroup</var></li><li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li><li>Append all items in <var>fragmentGroup</var> to <var>groupForResponseKey</var>.</li></ol></li></ol></li><li>If <var>selection</var> is an <span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span>:<ol><li>Let <var>fragmentType</var> be the type condition on <var>selection</var>.</li><li>If <var>fragmentType</var> is not <span class="spec-keyword">null</span> and <span class="spec-call"><a href="#DoesFragmentTypeApply()">DoesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span> is false, continue with the next <var>selection</var> in <var>selectionSet</var>.</li><li>Let <var>fragmentSelectionSet</var> be the top&#8208;level selection set of <var>selection</var>.</li><li>Let <var>fragmentGroupedFieldSet</var> be the result of calling <span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>fragmentSelectionSet</var>, <var>variableValues</var>, <var>visitedFragments</var>)</span>.</li><li>For each <var>fragmentGroup</var> in <var>fragmentGroupedFieldSet</var>:<ol><li>Let <var>responseKey</var> be the response key shared by all fields in <var>fragmentGroup</var></li><li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li><li>Append all items in <var>fragmentGroup</var> to <var>groupForResponseKey</var>.</li></ol></li></ol></li></ol></li><li>Return <var>groupedFields</var>.</li></ol></div><div class="spec-algo" id="DoesFragmentTypeApply()"><span class="spec-call"><a href="#DoesFragmentTypeApply()">DoesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span><ol><li>If <var>fragmentType</var> is an Object Type:<ol><li>if <var>objectType</var> and <var>fragmentType</var> are the same type, return <span class="spec-keyword">true</span>, otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is an Interface Type:<ol><li>if <var>objectType</var> is an implementation of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is a Union:<ol><li>if <var>objectType</var> is a possible type of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li></ol></div></section></section><section id="sec-Executing-Fields" secid="6.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Fields">6.4</a></span>Executing Fields</h3><p>Each field requested in the grouped field set that is defined on the selected objectType will result in an entry in the response map. Field execution first coerces any provided argument values, then resolves a value for the field, and finally completes that value either by recursively executing another selection set or coercing a scalar value.</p><div class="spec-algo" id="ExecuteField()"><span class="spec-call"><a href="#ExecuteField()">ExecuteField</a>(<var>objectType</var>, <var>objectValue</var>, <var>fieldType</var>, <var>fields</var>, <var>variableValues</var>)</span><ol><li>Let <var>field</var> be the first entry in <var>fields</var>.</li><li>Let <var>argumentValues</var> be the result of <span class="spec-call"><a href="#CoerceArgumentValues()">CoerceArgumentValues</a>(<var>objectType</var>, <var>field</var>, <var>variableValues</var>)</span></li><li>Let <var>resolvedValue</var> be <span class="spec-call"><a href="#ResolveFieldValue()">ResolveFieldValue</a>(<var>objectType</var>, <var>objectValue</var>, <var>fieldName</var>, <var>argumentValues</var>)</span>.</li><li>Return the result of <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>fieldType</var>, <var>fields</var>, <var>resolvedValue</var>, <var>variableValues</var>)</span>.</li></ol></div><section id="sec-Coercing-Field-Arguments" secid="6.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Coercing-Field-Arguments">6.4.1</a></span>Coercing Field Arguments</h4><p>Fields may include arguments which are provided to the underlying runtime in order to correctly produce a value. These arguments are defined by the field in the type system to have a specific input type: Scalars, Enum, Input Object, or List or Non&#8208;Null wrapped variations of these three.</p><p>At each argument position in a query may be a literal value or a variable to be provided at runtime.</p><div class="spec-algo" id="CoerceArgumentValues()"><span class="spec-call"><a href="#CoerceArgumentValues()">CoerceArgumentValues</a>(<var>objectType</var>, <var>field</var>, <var>variableValues</var>)</span><ol><li>Let <var>coercedValues</var> be an empty unordered Map.</li><li>Let <var>argumentValues</var> be the argument values provided in <var>field</var>.</li><li>Let <var>fieldName</var> be the name of <var>field</var>.</li><li>Let <var>argumentDefinitions</var> be the arguments defined by <var>objectType</var> for the field named <var>fieldName</var>.</li><li>For each <var>argumentDefinition</var> in <var>argumentDefinitions</var>:<ol><li>Let <var>argumentName</var> be the name of <var>argumentDefinition</var>.</li><li>Let <var>argumentType</var> be the expected type of <var>argumentDefinition</var>.</li><li>Let <var>defaultValue</var> be the default value for <var>argumentDefinition</var>.</li><li>Let <var>value</var> be the value provided in <var>argumentValues</var> for the name <var>argumentName</var>.</li><li>If <var>value</var> is a Variable:<ol><li>Let <var>variableName</var> be the name of Variable <var>value</var>.</li><li>Let <var>variableValue</var> be the value provided in <var>variableValues</var> for the name <var>variableName</var>.</li><li>If <var>variableValue</var> exists (including <span class="spec-keyword">null</span>):<ol><li>Add an entry to <var>coercedValues</var> named <var>argName</var> with the value <var>variableValue</var>.</li></ol></li><li>Otherwise, if <var>defaultValue</var> exists (including <span class="spec-keyword">null</span>):<ol><li>Add an entry to <var>coercedValues</var> named <var>argName</var> with the value <var>defaultValue</var>.</li></ol></li><li>Otherwise, if <var>argumentType</var> is a Non&#8208;Nullable type, throw a field error.</li><li>Otherwise, continue to the next argument definition.</li></ol></li><li>Otherwise, if <var>value</var> does not exist (was not provided in <var>argumentValues</var>:<ol><li>If <var>defaultValue</var> exists (including <span class="spec-keyword">null</span>):<ol><li>Add an entry to <var>coercedValues</var> named <var>argName</var> with the value <var>defaultValue</var>.</li></ol></li><li>Otherwise, if <var>argumentType</var> is a Non&#8208;Nullable type, throw a field error.</li><li>Otherwise, continue to the next argument definition.</li></ol></li><li>Otherwise, if <var>value</var> cannot be coerced according to the input coercion rules of <var>argType</var>, throw a field error.</li><li>Let <var>coercedValue</var> be the result of coercing <var>value</var> according to the input coercion rules of <var>argType</var>.</li><li>Add an entry to <var>coercedValues</var> named <var>argName</var> with the value <var>coercedValue</var>.</li></ol></li><li>Return <var>coercedValues</var>.</li></ol></div><div class="spec-note">Variable values are not coerced because they are expected to be coerced before executing the operation in <span class="spec-call"><a href="#CoerceVariableValues()">CoerceVariableValues</a>()</span>, and valid queries must only allow usage of variables of appropriate types.</div></section><section id="sec-Value-Resolution" secid="6.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Value-Resolution">6.4.2</a></span>Value Resolution</h4><p>While nearly all of GraphQL execution can be described generically, ultimately the internal system exposing the GraphQL interface must provide values. This is exposed via <span class="spec-nt">ResolveFieldValue</span>, which produces a value for a given field on a type for a real value.</p><p>As an example, this might accept the <var>objectType</var> <code>Person</code>, the <var>field</var> <span class="spec-string">"soulMate"</span>, and the <var>objectValue</var> representing John Lennon. It would be expected to yield the value representing Yoko Ono.</p><div class="spec-algo" id="ResolveFieldValue()"><span class="spec-call"><a href="#ResolveFieldValue()">ResolveFieldValue</a>(<var>objectType</var>, <var>objectValue</var>, <var>fieldName</var>, <var>argumentValues</var>)</span><ol><li>Let <var>resolver</var> be the internal function provided by <var>objectType</var> for determining the resolved value of a field named <var>fieldName</var>.</li><li>Return the result of calling <var>resolver</var>, providing <var>objectValue</var> and <var>argumentValues</var>.</li></ol></div><div class="spec-note">It is common for <var>resolver</var> to be asynchronous due to relying on reading an underlying database or networked service to produce a value. This necessitates the rest of a GraphQL executor to handle an asynchronous execution flow.</div></section><section id="sec-Value-Completion" secid="6.4.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Value-Completion">6.4.3</a></span>Value Completion</h4><p>After resolving the value for a field, it is completed by ensuring it adheres to the expected return type. If the return type is another Object type, then the field execution process continues recursively.</p><div class="spec-algo" id="CompleteValue()"><span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>fieldType</var>, <var>fields</var>, <var>result</var>, <var>variableValues</var>)</span><ol><li>If the <var>fieldType</var> is a Non&#8208;Null type:<ol><li>Let <var>innerType</var> be the inner type of <var>fieldType</var>.</li><li>Let <var>completedResult</var> be the result of calling <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>innerType</var>, <var>fields</var>, <var>result</var>, <var>variableValues</var>)</span>.</li><li>If <var>completedResult</var> is <span class="spec-keyword">null</span>, throw a field error.</li><li>Return <var>completedResult</var>.</li></ol></li><li>If <var>result</var> is <span class="spec-keyword">null</span> (or another internal value similar to <span class="spec-keyword">null</span> such as <span class="spec-keyword">undefined</span> or <span class="spec-nt">NaN</span>), return <span class="spec-keyword">null</span>.</li><li>If <var>fieldType</var> is a List type:<ol><li>If <var>result</var> is not a collection of values, throw a field error.</li><li>Let <var>innerType</var> be the inner type of <var>fieldType</var>.</li><li>Return a list where each list item is the result of calling <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>innerType</var>, <var>fields</var>, <var>resultItem</var>, <var>variableValues</var>)</span>, where <var>resultItem</var> is each item in <var>result</var>.</li></ol></li><li>If <var>fieldType</var> is a Scalar or Enum type:<ol><li>Return the result of &ldquo;coercing&rdquo; <var>result</var>, ensuring it is a legal value of <var>fieldType</var>, otherwise <span class="spec-keyword">null</span>.</li></ol></li><li>If <var>fieldType</var> is an Object, Interface, or Union type:<ol><li>If <var>fieldType</var> is an Object type.<ol><li>Let <var>objectType</var> be <var>fieldType</var>.</li></ol></li><li>Otherwise if <var>fieldType</var> is an Interface or Union type.<ol><li>Let <var>objectType</var> be ResolveAbstractType(<var>fieldType</var>, <var>result</var>).</li></ol></li><li>Let <var>subSelectionSet</var> be the result of calling <span class="spec-call"><a href="#MergeSelectionSets()">MergeSelectionSets</a>(<var>fields</var>)</span>.</li><li>Return the result of evaluating ExecuteSelectionSet(subSelectionSet, objectType, result, variableValues) <em>normally</em> (allowing for parallelization).</li></ol></li></ol></div><p><strong>Resolving Abstract Types</strong></p><p>When completing a field with an abstract return type, that is an Interface or Union return type, first the abstract type must be resolved to a relevant Object type. This determination is made by the internal system using whatever means appropriate.</p><div class="spec-note">A common method of determining the Object type for an <var>objectValue</var> in object&#8208;oriented environments, such as Java or C#, is to use the class name of the <var>objectValue</var>.</div><div class="spec-algo" id="ResolveAbstractType()"><span class="spec-call"><a href="#ResolveAbstractType()">ResolveAbstractType</a>(<var>abstractType</var>, <var>objectValue</var>)</span><ol><li>Return the result of calling the internal method provided by the type system for determining the Object type of <var>abstractType</var> given the value <var>objectValue</var>.</li></ol></div><p><strong>Merging Selection Sets</strong></p><p>When more than one fields of the same name are executed in parallel, their selection sets are merged together when completing the value in order to continue execution of the sub&#8208;selection sets.</p><p>An example query illustrating parallel fields with the same name with sub&#8208;selections.</p><pre><code><span class="token punctuation">{</span>
  me <span class="token punctuation">{</span>
    firstName
  <span class="token punctuation">}</span>
  me <span class="token punctuation">{</span>
    lastName
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>After resolving the value for <code>me</code>, the selection sets are merged together so <code>firstName</code> and <code>lastName</code> can be resolved for one value.</p><div class="spec-algo" id="MergeSelectionSets()"><span class="spec-call"><a href="#MergeSelectionSets()">MergeSelectionSets</a>(<var>fields</var>)</span><ol><li>Let <var>selectionSet</var> be an empty list.</li><li>For each <var>field</var> in <var>fields</var>:<ol><li>Let <var>fieldSelectionSet</var> be the selection set of <var>field</var>.</li><li>If <var>fieldSelectionSet</var> is null or empty, continue to the next field.</li><li>Append all selections in <var>fieldSelectionSet</var> to <var>selectionSet</var>.</li></ol></li><li>Return <var>selectionSet</var>.</li></ol></div></section><section id="sec-Errors-and-Non-Nullability" secid="6.4.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Errors-and-Non-Nullability">6.4.4</a></span>Errors and Non-Nullability</h4><p>If an error is thrown while resolving a field, it should be treated as though the field returned <span class="spec-keyword">null</span>, and an error must be added to the <span class="spec-string">"errors"</span> list in the response.</p><p>If the result of resolving a field is <span class="spec-keyword">null</span> (either because the function to resolve the field returned <span class="spec-keyword">null</span> or because an error occurred), and that field is of a <code>Non-Null</code> type, then a field error is thrown. The error must be added to the <span class="spec-string">"errors"</span> list in the response.</p><p>If the field returns <span class="spec-keyword">null</span> because of an error which has already been added to the <span class="spec-string">"errors"</span> list in the response, the <span class="spec-string">"errors"</span> list must not be further affected. That is, only one error should be added to the errors list per field.</p><p>Since <code>Non-Null</code> type fields cannot be <span class="spec-keyword">null</span>, field errors are propagated to be handled by the parent field. If the parent field may be <span class="spec-keyword">null</span> then it resolves to <span class="spec-keyword">null</span>, otherwise if it is a <code>Non-Null</code> type, the field error is further propagated to it&rsquo;s parent field.</p><p>If all fields from the root of the request to the source of the error return <code>Non-Null</code> types, then the <span class="spec-string">"data"</span> entry in the response should be <span class="spec-keyword">null</span>. </p></section></section></section><section id="sec-Response" secid="7"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Response">7</a></span>Response</h2><p>When a GraphQL server receives a request, it must return a well&#8208;formed response. The server&rsquo;s response describes the result of executing the requested operation if successful, and describes any errors encountered during the request.</p><p>A response may contain both a partial response as well as encountered errors in the case that an error occurred on a field which was replaced with null.</p><section id="sec-Serialization-Format" secid="7.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Serialization-Format">7.1</a></span>Serialization Format</h3><p>GraphQL does not require a specific serialization format. However, clients should use a serialization format that supports the major primitives in the GraphQL response. In particular, the serialization format must support representations of the following four primitives:</p><ul><li>Map</li><li>List</li><li>String</li><li>Null</li></ul><p>Serialization formats which can represent an ordered map should preserve the order of requested fields as defined by <span class="spec-call"><a href="#CollectFields()">CollectFields</a>()</span> in the Execution section. Serialization formats which can only represent unordered maps should retain this order grammatically (such as JSON).</p><p>Producing a response where fields are represented in the same order in which they appear in the request improves human readability during debugging and enables more efficient parsing of responses if the order of properties can be anticipated.</p><p>A serialization format may support the following primitives, however, strings may be used as a substitute for those primitives.</p><ul><li>Boolean</li><li>Int</li><li>Float</li><li>Enum Value</li></ul><section id="sec-JSON-Serialization" secid="7.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-JSON-Serialization">7.1.1</a></span>JSON Serialization</h4><p>JSON is the preferred serialization format for GraphQL, though as noted above, GraphQL does not require a specific serialization format. For consistency and ease of notation, examples of the response are given in JSON throughout the spec. In particular, in our JSON examples, we will represent primitives using the following JSON concepts:</p><table><thead><tr><th>GraphQL Value </th><th>JSON Value </th></tr></thead><tbody><tr><td>Map </td><td>Object </td></tr><tr><td>List </td><td>Array </td></tr><tr><td>Null </td><td><span class="spec-keyword">null</span> </td></tr><tr><td>String </td><td>String </td></tr><tr><td>Boolean </td><td><span class="spec-keyword">true</span> or <span class="spec-keyword">false</span> </td></tr><tr><td>Int </td><td>Number </td></tr><tr><td>Float </td><td>Number </td></tr><tr><td>Enum Value </td><td>String </td></tr></tbody></table><p><strong>Object Property Ordering</strong></p><p>While JSON Objects are specified as an <a href="https://tools.ietf.org/html/rfc7159#section-4">unordered collection of key&#8208;value pairs</a> the pairs are represented in an ordered manner. In other words, while the JSON strings <code>{ &quot;name&quot;: &quot;Mark&quot;, &quot;age&quot;: 30 }</code> and <code>{ &quot;age&quot;: 30, &quot;name&quot;: &quot;Mark&quot; }</code> encode the same value, they also have observably different property orderings.</p><p>Since the result of evaluating a selection set is ordered, the JSON object serialized should preserve this order by writing the object properties in the same order as those fields were requested as defined by query execution.</p><p>For example, if the query was <code>{ name, age }</code>, a GraphQL server responding in JSON should respond with <code>{ &quot;name&quot;: &quot;Mark&quot;, &quot;age&quot;: 30 }</code> and should not respond with <code>{ &quot;age&quot;: 30, &quot;name&quot;: &quot;Mark&quot; }</code>.</p><div class="spec-note">This does not violate the JSON spec, as clients may still interpret objects in the response as unordered Maps and arrive at a valid value.</div></section></section><section id="sec-Response-Format" secid="7.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Response-Format">7.2</a></span>Response Format</h3><p>A response to a GraphQL operation must be a map.</p><p>If the operation included execution, the response map must contain a first entry with key <code>data</code>. The value of this entry is described in the &ldquo;Data&rdquo; section. If the operation failed before execution, due to a syntax error, missing information, or validation error, this entry must not be present.</p><p>If the operation encountered any errors, the response map must contain a next entry with key <code>errors</code>. The value of this entry is described in the &ldquo;Errors&rdquo; section. If the operation completed without encountering any errors, this entry must not be present.</p><p>The response map may also contain an entry with key <code>extensions</code>. This entry, if set, must have a map as its value. This entry is reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents.</p><p>To ensure future changes to the protocol do not break existing servers and clients, the top level response map must not contain any entries other than the three described above.</p><section id="sec-Data" secid="7.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Data">7.2.1</a></span>Data</h4><p>The <code>data</code> entry in the response will be the result of the execution of the requested operation. If the operation was a query, this output will be an object of the schema&rsquo;s query root type; if the operation was a mutation, this output will be an object of the schema&rsquo;s mutation root type.</p><p>If an error was encountered before execution begins, the <code>data</code> entry should not be present in the result.</p><p>If an error was encountered during the execution that prevented a valid response, the <code>data</code> entry in the response should be <code>null</code>.</p></section><section id="sec-Errors" secid="7.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Errors">7.2.2</a></span>Errors</h4><p>The <code>errors</code> entry in the response is a non&#8208;empty list of errors, where each error is a map.</p><p>If no errors were encountered during the requested operation, the <code>errors</code> entry should not be present in the result.</p><p>Every error must contain an entry with the key <code>message</code> with a string description of the error intended for the developer as a guide to understand and correct the error.</p><p>If an error can be associated to a particular point in the requested GraphQL document, it should contain an entry with the key <code>locations</code> with a list of locations, where each location is a map with the keys <code>line</code> and <code>column</code>, both positive numbers starting from <code>1</code> which describe the beginning of an associated syntax element.</p><p>GraphQL servers may provide additional entries to error as they choose to produce more helpful or machine&#8208;readable errors, however future versions of the spec may describe additional entries to errors.</p><p>If the <code>data</code> entry in the response is <code>null</code> or not present, the <code>errors</code> entry in the response must not be empty. It must contain at least one error. The errors it contains should indicate why no data was able to be returned.</p><p>If the <code>data</code> entry in the response is not <code>null</code>, the <code>errors</code> entry in the response may contain any errors that occurred during execution. If errors occurred during execution, it should contain those errors. </p></section></section></section><section id="sec-Appendix-Notation-Conventions" secid="A"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Notation-Conventions">A</a></span>Appendix: Notation Conventions</h2><p>This specification document contains a number of notation conventions used to describe technical concepts such as language grammar and semantics as well as runtime algorithms.</p><p>This appendix seeks to explain these notations in greater detail to avoid ambiguity.</p><section id="sec-Context-Free-Grammar" secid="A.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Context-Free-Grammar">A.1</a></span>Context-Free Grammar</h3><p>A context&#8208;free grammar consists of a number of productions. Each production has an abstract symbol called a &ldquo;non&#8208;terminal&rdquo; as its left&#8208;hand side, and zero or more possible sequences of non&#8208;terminal symbols and or terminal characters as its right&#8208;hand side.</p><p>Starting from a single goal non&#8208;terminal symbol, a context&#8208;free grammar describes a language: the set of possible sequences of characters that can be described by repeatedly replacing any non&#8208;terminal in the goal sequence with one of the sequences it is defined by, until all non&#8208;terminal symbols have been replaced by terminal characters.</p><p>Terminals are represented in this document in a monospace font in two forms: a specific Unicode character or sequence of Unicode characters (ex. <span class="spec-t">=</span> or <span class="spec-t">terminal</span>), and a pattern of Unicode characters defined by a regular expression (ex <span class="spec-rx">/[0-9]+/</span>).</p><p>Non&#8208;terminal production rules are represented in this document using the following notation for a non&#8208;terminal with a single definition:</p><div class="spec-production" id="NonTerminalWithSingleDefinition"><span class="spec-nt"><a href="#NonTerminalWithSingleDefinition">NonTerminalWithSingleDefinition</a></span><div class="spec-rhs"><span class="spec-nt">NonTerminal</span><span class="spec-t">terminal</span></div></div><p>While using the following notation for a production with a list of definitions:</p><div class="spec-production" id="NonTerminalWithManyDefinitions"><span class="spec-nt"><a href="#NonTerminalWithManyDefinitions">NonTerminalWithManyDefinitions</a></span><div class="spec-rhs"><span class="spec-nt">OtherNonTerminal</span><span class="spec-t">terminal</span></div><div class="spec-rhs"><span class="spec-t">terminal</span></div></div><p>A definition may refer to itself, which describes repetitive sequences, for example:</p><div class="spec-production" id="ListOfLetterA"><span class="spec-nt"><a href="#ListOfLetterA">ListOfLetterA</a></span><div class="spec-rhs"><span class="spec-t">a</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListOfLetterA">ListOfLetterA</a></span><span class="spec-t">a</span></div></div></section><section id="sec-Lexical-and-Syntactical-Grammar" secid="A.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Lexical-and-Syntactical-Grammar">A.2</a></span>Lexical and Syntactical Grammar</h3><p>The GraphQL language is defined in a syntactic grammar where terminal symbols are tokens. Tokens are defined in a lexical grammar which matches patterns of source characters. The result of parsing a sequence of source Unicode characters produces a GraphQL AST.</p><p>A Lexical grammar production describes non&#8208;terminal &ldquo;tokens&rdquo; by patterns of terminal Unicode characters. No &ldquo;whitespace&rdquo; or other ignored characters may appear between any terminal Unicode characters in the lexical grammar production. A lexical grammar production is distinguished by a two colon <code>::</code> definition.</p><div class="spec-production d2" id="Word"><span class="spec-nt"><a href="#Word">Word</a></span><div class="spec-rhs"><span class="spec-rx">/[A-Za-z]+/</span></div></div><p>A Syntactical grammar production describes non&#8208;terminal &ldquo;rules&rdquo; by patterns of terminal Tokens. Whitespace and other ignored characters may appear before or after any terminal Token. A syntactical grammar production is distinguished by a one colon <code>:</code> definition.</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span></div></div></section><section id="sec-Grammar-Notation" secid="A.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Grammar-Notation">A.3</a></span>Grammar Notation</h3><p>This specification uses some additional notation to describe common patterns, such as optional or repeated patterns, or parameterized alterations of the definition of a non&#8208;terminal. This section explains these short&#8208;hand notations and their expanded definitions in the context&#8208;free grammar.</p><p><strong>Constraints</strong></p><p>A grammar production may specify that certain expansions are not permitted by using the phrase &ldquo;but not&rdquo; and then indicating the expansions to be excluded.</p><p>For example, the production:</p><div class="spec-production" id="SafeName"><span class="spec-nt"><a href="#SafeName">SafeName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-nt">SevenCarlinWords</span></span></span></div></div><p>means that the nonterminal <span class="spec-nt"><a href="#SafeName">SafeName</a></span> may be replaced by any sequence of characters that could replace <span class="spec-nt"><a href="#Name">Name</a></span> provided that the same sequence of characters could not replace <span class="spec-nt">SevenCarlinWords</span>.</p><p>A grammar may also list a number of restrictions after &ldquo;but not&rdquo; separated by &ldquo;or&rdquo;.</p><p>For example:</p><div class="spec-production" id="NonBooleanName"><span class="spec-nt"><a href="#NonBooleanName">NonBooleanName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span></span></span></div></div><p><strong>Optionality and Lists</strong></p><p>A subscript suffix &ldquo;<span class="spec-quantified"><span class="spec-nt">Symbol</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span>&rdquo; is shorthand for two possible sequences, one including that symbol and one excluding it.</p><p>As an example:</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-quantified"><span class="spec-nt">Adverb</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><p>is shorthand for</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span></div><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-nt">Adverb</span></div></div><p>A subscript suffix &ldquo;<span class="spec-quantified"><span class="spec-nt">Symbol</span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span>&rdquo; is shorthand for a list of one or more of that symbol.</p><p>As an example:</p><div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span><div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-quantified"><span class="spec-nt">Page</span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-nt">Cover</span></div></div><p>is shorthand for</p><div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span><div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Cover</span></div></div><div class="spec-production" id="Page_list"><span class="spec-nt"><a href="#Page_list">Page_list</a></span><div class="spec-rhs"><span class="spec-nt">Page</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Page</span></div></div><p><strong>Parameterized Grammar Productions</strong></p><p>A symbol definition subscript suffix parameter in braces &ldquo;<span class="spec-nt">Symbol<span class="spec-params"><span class="spec-param">Param</span></span></span>&rdquo; is shorthand for two symbol definitions, one appended with that parameter name, the other without. The same subscript suffix on a symbol is shorthand for that variant of the definition. If the parameter starts with &ldquo;?&rdquo;, that form of the symbol is used if in a symbol definition with the same parameter. Some possible sequences can be included or excluded conditionally when respectively prefixed with &ldquo;[+Param]&rdquo; and &ldquo;[~Param]&rdquo;.</p><p>As an example:</p><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a><span class="spec-params"><span class="spec-param">Param</span></span></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B<span class="spec-params"><span class="spec-param">Param</span></span></span></div><div class="spec-rhs"><span class="spec-nt">C<span class="spec-params"><span class="spec-param conditional">Param</span></span></span></div><div class="spec-rhs"><span class="spec-condition">Param</span><span class="spec-nt">D</span></div><div class="spec-rhs"><span class="spec-condition not">Param</span><span class="spec-nt">E</span></div></div><p>is shorthand for</p><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B_param</span></div><div class="spec-rhs"><span class="spec-nt">C</span></div><div class="spec-rhs"><span class="spec-nt">E</span></div></div><div class="spec-production" id="Example_param"><span class="spec-nt"><a href="#Example_param">Example_param</a></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B_param</span></div><div class="spec-rhs"><span class="spec-nt">C_param</span></div><div class="spec-rhs"><span class="spec-nt">D</span></div></div></section><section id="sec-Grammar-Semantics" secid="A.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Grammar-Semantics">A.4</a></span>Grammar Semantics</h3><p>This specification describes the semantic value of many grammar productions in the form of a list of algorithmic steps.</p><p>For example, this describes how a parser should interpret a string literal:</p><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><ol><li>Return an empty Unicode character sequence.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-quantified"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">&quot;</span></div><ol><li>Return the Unicode character sequence of all <span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span> Unicode character values.</li></ol></div></section><section id="sec-Algorithms" secid="A.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Algorithms">A.5</a></span>Algorithms</h3><p>This specification describes some algorithms used by the static and runtime semantics, they&rsquo;re defined in the form of a function&#8208;like syntax along with a list of algorithmic steps to take.</p><p>For example, this describes if a fragment should be spread into place given a runtime <var>objectType</var> and the fragment&rsquo;s <var>fragmentType</var>:</p><div class="spec-algo" id="doesFragmentTypeApply()"><span class="spec-call"><a href="#doesFragmentTypeApply()">doesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span><ol><li>If <var>fragmentType</var> is an Object Type:<ol><li>if <var>objectType</var> and <var>fragmentType</var> are the same type, return <span class="spec-keyword">true</span>, otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is an Interface Type:<ol><li>if <var>objectType</var> is an implementation of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is a Union:<ol><li>if <var>objectType</var> is a possible type of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li></ol></div></section></section><section id="sec-Appendix-Grammar-Summary" secid="B"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary">B</a></span>Appendix: Grammar Summary</h2><div class="spec-production d2" id="SourceCharacter"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-rx">/[\u0009\u000A\u000D\u0020-\uFFFF]/</span></div></div><section id="sec-Appendix-Grammar-Summary.Ignored-Tokens" secid="B.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary.Ignored-Tokens">B.1</a></span>Ignored Tokens</h3><div class="spec-production d2" id="Ignored"><span class="spec-nt"><a href="#Ignored">Ignored</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comment">Comment</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comma">Comma</a></span></div></div><div class="spec-production d2" id="UnicodeBOM"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span><div class="spec-rhs"><span class="spec-prose">Byte Order Mark (U+FEFF)</span></div></div><div class="spec-production d2" id="WhiteSpace"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Horizontal Tab (U+0009)</span></div><div class="spec-rhs"><span class="spec-prose">Space (U+0020)</span></div></div><div class="spec-production d2" id="LineTerminator"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span><div class="spec-rhs"><span class="spec-prose">New Line (U+000A)</span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-lookahead not"><span class="spec-prose">New Line (U+000A)</span></span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-prose">New Line (U+000A)</span></div></div><div class="spec-production d2" id="Comment"><span class="spec-nt"><a href="#Comment">Comment</a></span><div class="spec-rhs"><span class="spec-t">#</span><span class="spec-quantified"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production d2" id="CommentChar"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div></div><div class="spec-production d2" id="Comma"><span class="spec-nt"><a href="#Comma">Comma</a></span><div class="spec-rhs"><span class="spec-t">,</span></div></div></section><section id="sec-Appendix-Grammar-Summary.Lexical-Tokens" secid="B.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary.Lexical-Tokens">B.2</a></span>Lexical Tokens</h3><div class="spec-production d2" id="Token"><span class="spec-nt"><a href="#Token">Token</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div></div><div class="spec-production d2" id="Punctuator"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">!</span></td><td class="spec-rhs"><span class="spec-t">$</span></td><td class="spec-rhs"><span class="spec-t">(</span></td><td class="spec-rhs"><span class="spec-t">)</span></td><td class="spec-rhs"><span class="spec-t">...</span></td><td class="spec-rhs"><span class="spec-t">:</span></td><td class="spec-rhs"><span class="spec-t">=</span></td><td class="spec-rhs"><span class="spec-t">@</span></td><td class="spec-rhs"><span class="spec-t">[</span></td><td class="spec-rhs"><span class="spec-t">]</span></td><td class="spec-rhs"><span class="spec-t">{</span></td><td class="spec-rhs"><span class="spec-t">|</span></td><td class="spec-rhs"><span class="spec-t">}</span></td></tr></table></div></div><div class="spec-production d2" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span><div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div></div><div class="spec-production d2" id="IntValue"><span class="spec-nt"><a href="#IntValue">IntValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span></div></div><div class="spec-production d2" id="IntegerPart"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">0</span></div><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production d2" id="NegativeSign"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><div class="spec-rhs"><span class="spec-t">-</span></div></div><div class="spec-production d2" id="Digit"><span class="spec-nt"><a href="#Digit">Digit</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr></table></div></div><div class="spec-production d2" id="NonZeroDigit"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-butnot"><span class="spec-t">0</span></span></span></div></div><div class="spec-production d2" id="FloatValue"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div></div><div class="spec-production d2" id="FractionalPart"><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentPart"><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentIndicator"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr></table></div></div><div class="spec-production d2" id="Sign"><span class="spec-nt"><a href="#Sign">Sign</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr></table></div></div><div class="spec-production d2" id="StringValue"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-quantified"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">&quot;</span></div></div><div class="spec-production d2" id="StringCharacter"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div></div><div class="spec-production d2" id="EscapedUnicode"><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span><div class="spec-rhs"><span class="spec-rx">/[0-9A-Fa-f]{4}/</span></div></div><div class="spec-production d2" id="EscapedCharacter"><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">&quot;</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr></table></div></div></section><section id="sec-Appendix-Grammar-Summary.Query-Document" secid="B.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary.Query-Document">B.3</a></span>Query Document</h3><div class="spec-production" id="Document"><span class="spec-nt"><a href="#Document">Document</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Definition">Definition</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production" id="Definition"><span class="spec-nt"><a href="#Definition">Definition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span></div></div><div class="spec-production" id="OperationDefinition"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="OperationType"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">query</span></td><td class="spec-rhs"><span class="spec-t">mutation</span></td></tr></table></div></div><div class="spec-production" id="SelectionSet"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#Selection">Selection</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="Selection"><span class="spec-nt"><a href="#Selection">Selection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Field">Field</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span></div></div><div class="spec-production" id="Field"><span class="spec-nt"><a href="#Field">Field</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Alias">Alias</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production" id="Alias"><span class="spec-nt"><a href="#Alias">Alias</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span></div></div><div class="spec-production" id="Arguments"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-quantified"><span class="spec-nt"><a href="#Argument">Argument</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="Argument"><span class="spec-nt"><a href="#Argument">Argument</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a></span></div></div><div class="spec-production" id="FragmentSpread"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production" id="InlineFragment"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-quantified"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentDefinition"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span><div class="spec-rhs"><span class="spec-t">fragment</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Directives">Directives</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentName"><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">on</span></span></span></div></div><div class="spec-production" id="TypeCondition"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><div class="spec-rhs"><span class="spec-t">on</span><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div></div><div class="spec-production" id="Value"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-condition not">Const</span><span class="spec-nt"><a href="#Variable">Variable</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NullValue">NullValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div></div><div class="spec-production" id="BooleanValue"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">true</span></td><td class="spec-rhs"><span class="spec-t">false</span></td></tr></table></div></div><div class="spec-production" id="NullValue"><span class="spec-nt"><a href="#NullValue">NullValue</a></span><div class="spec-rhs"><span class="spec-t">null</span></div></div><div class="spec-production" id="EnumValue"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span><span class="spec-t">null</span></span></span></div></div><div class="spec-production" id="ListValue"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-quantified"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">]</span></div></div><div class="spec-production" id="ObjectValue"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="ObjectField"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-params"><span class="spec-param">Const</span></span></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></div></div><div class="spec-production" id="VariableDefinitions"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-quantified"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="VariableDefinition"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Variable">Variable</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div><div class="spec-production" id="Variable"><span class="spec-nt"><a href="#Variable">Variable</a></span><div class="spec-rhs"><span class="spec-t">$</span><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="DefaultValue"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><div class="spec-rhs"><span class="spec-t">=</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-params"><span class="spec-param">Const</span></span></span></div></div><div class="spec-production" id="Type"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span></div></div><div class="spec-production" id="NamedType"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="ListType"><span class="spec-nt"><a href="#ListType">ListType</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div></div><div class="spec-production" id="NonNullType"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><span class="spec-t">!</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span><span class="spec-t">!</span></div></div><div class="spec-production" id="Directives"><span class="spec-nt"><a href="#Directives">Directives</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Directive">Directive</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div></div><div class="spec-production" id="Directive"><span class="spec-nt"><a href="#Directive">Directive</a></span><div class="spec-rhs"><span class="spec-t">@</span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div></div></section></section><section id="index" secid="index" class="spec-index"><h1><span class="spec-secid" title="link to the index"><a href="#index">ยง</a></span>Index</h1><ol><li><a href="#Alias">Alias</a></li><li><a href="#Argument">Argument</a></li><li><a href="#Arguments">Arguments</a></li><li><a href="#BooleanValue">BooleanValue</a></li><li><a href="#CoerceArgumentValues()">CoerceArgumentValues</a></li><li><a href="#CoerceVariableValues()">CoerceVariableValues</a></li><li><a href="#CollectFields()">CollectFields</a></li><li><a href="#Comma">Comma</a></li><li><a href="#Comment">Comment</a></li><li><a href="#CommentChar">CommentChar</a></li><li><a href="#CompleteValue()">CompleteValue</a></li><li><a href="#DefaultValue">DefaultValue</a></li><li><a href="#Definition">Definition</a></li><li><a href="#Digit">Digit</a></li><li><a href="#Directive">Directive</a></li><li><a href="#Directives">Directives</a></li><li><a href="#Document">Document</a></li><li><a href="#DoesFragmentTypeApply()">DoesFragmentTypeApply</a></li><li><a href="#EnumValue">EnumValue</a></li><li><a href="#EscapedCharacter">EscapedCharacter</a></li><li><a href="#EscapedUnicode">EscapedUnicode</a></li><li><a href="#Example">Example</a></li><li><a href="#ExecuteField()">ExecuteField</a></li><li><a href="#ExecuteMutation()">ExecuteMutation</a></li><li><a href="#ExecuteQuery()">ExecuteQuery</a></li><li><a href="#ExecuteRequest()">ExecuteRequest</a></li><li><a href="#ExecuteSelectionSet()">ExecuteSelectionSet</a></li><li><a href="#ExponentIndicator">ExponentIndicator</a></li><li><a href="#ExponentPart">ExponentPart</a></li><li><a href="#Field">Field</a></li><li><a href="#FieldsInSetCanMerge()">FieldsInSetCanMerge</a></li><li><a href="#FloatValue">FloatValue</a></li><li><a href="#FractionalPart">FractionalPart</a></li><li><a href="#FragmentDefinition">FragmentDefinition</a></li><li><a href="#FragmentName">FragmentName</a></li><li><a href="#FragmentSpread">FragmentSpread</a></li><li><a href="#GetOperation()">GetOperation</a></li><li><a href="#GetPossibleTypes()">GetPossibleTypes</a></li><li><a href="#Ignored">Ignored</a></li><li><a href="#InlineFragment">InlineFragment</a></li><li><a href="#IntValue">IntValue</a></li><li><a href="#IntegerPart">IntegerPart</a></li><li><a href="#LineTerminator">LineTerminator</a></li><li><a href="#ListType">ListType</a></li><li><a href="#ListValue">ListValue</a></li><li><a href="#MergeSelectionSets()">MergeSelectionSets</a></li><li><a href="#Name">Name</a></li><li><a href="#NamedType">NamedType</a></li><li><a href="#NegativeSign">NegativeSign</a></li><li><a href="#NonNullType">NonNullType</a></li><li><a href="#NonZeroDigit">NonZeroDigit</a></li><li><a href="#NullValue">NullValue</a></li><li><a href="#ObjectField">ObjectField</a></li><li><a href="#ObjectValue">ObjectValue</a></li><li><a href="#OperationDefinition">OperationDefinition</a></li><li><a href="#OperationType">OperationType</a></li><li><a href="#Punctuator">Punctuator</a></li><li><a href="#ResolveAbstractType()">ResolveAbstractType</a></li><li><a href="#ResolveFieldValue()">ResolveFieldValue</a></li><li><a href="#SameResponseShape()">SameResponseShape</a></li><li><a href="#Selection">Selection</a></li><li><a href="#SelectionSet">SelectionSet</a></li><li><a href="#Sign">Sign</a></li><li><a href="#SourceCharacter">SourceCharacter</a></li><li><a href="#StringCharacter">StringCharacter</a></li><li><a href="#StringValue">StringValue</a></li><li><a href="#Token">Token</a></li><li><a href="#Type">Type</a></li><li><a href="#TypeCondition">TypeCondition</a></li><li><a href="#UnicodeBOM">UnicodeBOM</a></li><li><a href="#Value">Value</a></li><li><a href="#Variable">Variable</a></li><li><a href="#VariableDefinition">VariableDefinition</a></li><li><a href="#VariableDefinitions">VariableDefinitions</a></li><li><a href="#WhiteSpace">WhiteSpace</a></li></ol></section><footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer><input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden>&#x2630;</label><div class="spec-sidebar" aria-hidden><div class="spec-toc"><div class="title"><a href="#">GraphQL</a></div><ol><li id="_sidebar_1"><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a></li><li id="_sidebar_2"><a href="#sec-Language"><span class="spec-secid">2</span>Language</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2" /><label for="_sidebar_toggle_2"></label><ol><li id="_sidebar_2.1"><a href="#sec-Source-Text"><span class="spec-secid">2.1</span>Source Text</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.1" /><label for="_sidebar_toggle_2.1"></label><ol><li id="_sidebar_2.1.1"><a href="#sec-Unicode"><span class="spec-secid">2.1.1</span>Unicode</a></li><li id="_sidebar_2.1.2"><a href="#sec-White-Space"><span class="spec-secid">2.1.2</span>White Space</a></li><li id="_sidebar_2.1.3"><a href="#sec-Line-Terminators"><span class="spec-secid">2.1.3</span>Line Terminators</a></li><li id="_sidebar_2.1.4"><a href="#sec-Comments"><span class="spec-secid">2.1.4</span>Comments</a></li><li id="_sidebar_2.1.5"><a href="#sec-Insignificant-Commas"><span class="spec-secid">2.1.5</span>Insignificant Commas</a></li><li id="_sidebar_2.1.6"><a href="#sec-Source-Text.Lexical-Tokens"><span class="spec-secid">2.1.6</span>Lexical Tokens</a></li><li id="_sidebar_2.1.7"><a href="#sec-Source-Text.Ignored-Tokens"><span class="spec-secid">2.1.7</span>Ignored Tokens</a></li><li id="_sidebar_2.1.8"><a href="#sec-Punctuators"><span class="spec-secid">2.1.8</span>Punctuators</a></li><li id="_sidebar_2.1.9"><a href="#sec-Names"><span class="spec-secid">2.1.9</span>Names</a></li></ol></li><li id="_sidebar_2.2"><a href="#sec-Language.Query-Document"><span class="spec-secid">2.2</span>Query Document</a></li><li id="_sidebar_2.3"><a href="#sec-Language.Operations"><span class="spec-secid">2.3</span>Operations</a></li><li id="_sidebar_2.4"><a href="#sec-Selection-Sets"><span class="spec-secid">2.4</span>Selection Sets</a></li><li id="_sidebar_2.5"><a href="#sec-Language.Fields"><span class="spec-secid">2.5</span>Fields</a></li><li id="_sidebar_2.6"><a href="#sec-Language.Arguments"><span class="spec-secid">2.6</span>Arguments</a></li><li id="_sidebar_2.7"><a href="#sec-Field-Alias"><span class="spec-secid">2.7</span>Field Alias</a></li><li id="_sidebar_2.8"><a href="#sec-Language.Fragments"><span class="spec-secid">2.8</span>Fragments</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.8" /><label for="_sidebar_toggle_2.8"></label><ol><li id="_sidebar_2.8.1"><a href="#sec-Type-Conditions"><span class="spec-secid">2.8.1</span>Type Conditions</a></li><li id="_sidebar_2.8.2"><a href="#sec-Inline-Fragments"><span class="spec-secid">2.8.2</span>Inline Fragments</a></li></ol></li><li id="_sidebar_2.9"><a href="#sec-Input-Values"><span class="spec-secid">2.9</span>Input Values</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.9" /><label for="_sidebar_toggle_2.9"></label><ol><li id="_sidebar_2.9.1"><a href="#sec-Int-Value"><span class="spec-secid">2.9.1</span>Int Value</a></li><li id="_sidebar_2.9.2"><a href="#sec-Float-Value"><span class="spec-secid">2.9.2</span>Float Value</a></li><li id="_sidebar_2.9.3"><a href="#sec-Boolean-Value"><span class="spec-secid">2.9.3</span>Boolean Value</a></li><li id="_sidebar_2.9.4"><a href="#sec-String-Value"><span class="spec-secid">2.9.4</span>String Value</a></li><li id="_sidebar_2.9.5"><a href="#sec-Null-Value"><span class="spec-secid">2.9.5</span>Null Value</a></li><li id="_sidebar_2.9.6"><a href="#sec-Enum-Value"><span class="spec-secid">2.9.6</span>Enum Value</a></li><li id="_sidebar_2.9.7"><a href="#sec-List-Value"><span class="spec-secid">2.9.7</span>List Value</a></li><li id="_sidebar_2.9.8"><a href="#sec-Input-Object-Values"><span class="spec-secid">2.9.8</span>Input Object Values</a></li></ol></li><li id="_sidebar_2.10"><a href="#sec-Language.Variables"><span class="spec-secid">2.10</span>Variables</a></li><li id="_sidebar_2.11"><a href="#sec-Input-Types"><span class="spec-secid">2.11</span>Input Types</a></li><li id="_sidebar_2.12"><a href="#sec-Language.Directives"><span class="spec-secid">2.12</span>Directives</a></li></ol></li><li id="_sidebar_3"><a href="#sec-Type-System"><span class="spec-secid">3</span>Type System</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3" /><label for="_sidebar_toggle_3"></label><ol><li id="_sidebar_3.1"><a href="#sec-Types"><span class="spec-secid">3.1</span>Types</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1" /><label for="_sidebar_toggle_3.1"></label><ol><li id="_sidebar_3.1.1"><a href="#sec-Scalars"><span class="spec-secid">3.1.1</span>Scalars</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.1" /><label for="_sidebar_toggle_3.1.1"></label><ol><li id="_sidebar_3.1.1.1"><a href="#sec-Int"><span class="spec-secid">3.1.1.1</span>Int</a></li><li id="_sidebar_3.1.1.2"><a href="#sec-Float"><span class="spec-secid">3.1.1.2</span>Float</a></li><li id="_sidebar_3.1.1.3"><a href="#sec-String"><span class="spec-secid">3.1.1.3</span>String</a></li><li id="_sidebar_3.1.1.4"><a href="#sec-Boolean"><span class="spec-secid">3.1.1.4</span>Boolean</a></li><li id="_sidebar_3.1.1.5"><a href="#sec-ID"><span class="spec-secid">3.1.1.5</span>ID</a></li></ol></li><li id="_sidebar_3.1.2"><a href="#sec-Objects"><span class="spec-secid">3.1.2</span>Objects</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.2" /><label for="_sidebar_toggle_3.1.2"></label><ol><li id="_sidebar_3.1.2.1"><a href="#sec-Object-Field-Arguments"><span class="spec-secid">3.1.2.1</span>Object Field Arguments</a></li><li id="_sidebar_3.1.2.2"><a href="#sec-Object-Field-deprecation"><span class="spec-secid">3.1.2.2</span>Object Field deprecation</a></li><li id="_sidebar_3.1.2.3"><a href="#sec-Object-type-validation"><span class="spec-secid">3.1.2.3</span>Object type validation</a></li></ol></li><li id="_sidebar_3.1.3"><a href="#sec-Interfaces"><span class="spec-secid">3.1.3</span>Interfaces</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.3" /><label for="_sidebar_toggle_3.1.3"></label><ol><li id="_sidebar_3.1.3.1"><a href="#sec-Interface-type-validation"><span class="spec-secid">3.1.3.1</span>Interface type validation</a></li></ol></li><li id="_sidebar_3.1.4"><a href="#sec-Unions"><span class="spec-secid">3.1.4</span>Unions</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.4" /><label for="_sidebar_toggle_3.1.4"></label><ol><li id="_sidebar_3.1.4.1"><a href="#sec-Union-type-validation"><span class="spec-secid">3.1.4.1</span>Union type validation</a></li></ol></li><li id="_sidebar_3.1.5"><a href="#sec-Enums"><span class="spec-secid">3.1.5</span>Enums</a></li><li id="_sidebar_3.1.6"><a href="#sec-Input-Objects"><span class="spec-secid">3.1.6</span>Input Objects</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.6" /><label for="_sidebar_toggle_3.1.6"></label><ol><li id="_sidebar_3.1.6.1"><a href="#sec-Input-Object-type-validation"><span class="spec-secid">3.1.6.1</span>Input Object type validation</a></li></ol></li><li id="_sidebar_3.1.7"><a href="#sec-Lists"><span class="spec-secid">3.1.7</span>Lists</a></li><li id="_sidebar_3.1.8"><a href="#sec-Types.Non-Null"><span class="spec-secid">3.1.8</span>Non-Null</a></li></ol></li><li id="_sidebar_3.2"><a href="#sec-Type-System.Directives"><span class="spec-secid">3.2</span>Directives</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.2" /><label for="_sidebar_toggle_3.2"></label><ol><li id="_sidebar_3.2.1"><a href="#sec--skip"><span class="spec-secid">3.2.1</span>@skip</a></li><li id="_sidebar_3.2.2"><a href="#sec--include"><span class="spec-secid">3.2.2</span>@include</a></li></ol></li><li id="_sidebar_3.3"><a href="#sec-Initial-types"><span class="spec-secid">3.3</span>Initial types</a></li></ol></li><li id="_sidebar_4"><a href="#sec-Introspection"><span class="spec-secid">4</span>Introspection</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4" /><label for="_sidebar_toggle_4"></label><ol><li id="_sidebar_4.1"><a href="#sec-General-Principles"><span class="spec-secid">4.1</span>General Principles</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.1" /><label for="_sidebar_toggle_4.1"></label><ol><li id="_sidebar_4.1.1"><a href="#sec-Naming-conventions"><span class="spec-secid">4.1.1</span>Naming conventions</a></li><li id="_sidebar_4.1.2"><a href="#sec-Documentation"><span class="spec-secid">4.1.2</span>Documentation</a></li><li id="_sidebar_4.1.3"><a href="#sec-Deprecation"><span class="spec-secid">4.1.3</span>Deprecation</a></li><li id="_sidebar_4.1.4"><a href="#sec-Type-Name-Introspection"><span class="spec-secid">4.1.4</span>Type Name Introspection</a></li></ol></li><li id="_sidebar_4.2"><a href="#sec-Schema-Introspection"><span class="spec-secid">4.2</span>Schema Introspection</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.2" /><label for="_sidebar_toggle_4.2"></label><ol><li id="_sidebar_4.2.1"><a href="#sec-The-__Type-Type"><span class="spec-secid">4.2.1</span>The __Type Type</a></li><li id="_sidebar_4.2.2"><a href="#sec-Type-Kinds"><span class="spec-secid">4.2.2</span>Type Kinds</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.2.2" /><label for="_sidebar_toggle_4.2.2"></label><ol><li id="_sidebar_4.2.2.1"><a href="#sec-Scalar"><span class="spec-secid">4.2.2.1</span>Scalar</a></li><li id="_sidebar_4.2.2.2"><a href="#sec-Object"><span class="spec-secid">4.2.2.2</span>Object</a></li><li id="_sidebar_4.2.2.3"><a href="#sec-Union"><span class="spec-secid">4.2.2.3</span>Union</a></li><li id="_sidebar_4.2.2.4"><a href="#sec-Interface"><span class="spec-secid">4.2.2.4</span>Interface</a></li><li id="_sidebar_4.2.2.5"><a href="#sec-Enum"><span class="spec-secid">4.2.2.5</span>Enum</a></li><li id="_sidebar_4.2.2.6"><a href="#sec-Input-Object"><span class="spec-secid">4.2.2.6</span>Input Object</a></li><li id="_sidebar_4.2.2.7"><a href="#sec-List"><span class="spec-secid">4.2.2.7</span>List</a></li><li id="_sidebar_4.2.2.8"><a href="#sec-Type-Kinds.Non-Null"><span class="spec-secid">4.2.2.8</span>Non-Null</a></li><li id="_sidebar_4.2.2.9"><a href="#sec-Combining-List-and-Non-Null"><span class="spec-secid">4.2.2.9</span>Combining List and Non-Null</a></li></ol></li><li id="_sidebar_4.2.3"><a href="#sec-The-__Field-Type"><span class="spec-secid">4.2.3</span>The __Field Type</a></li><li id="_sidebar_4.2.4"><a href="#sec-The-__InputValue-Type"><span class="spec-secid">4.2.4</span>The __InputValue Type</a></li><li id="_sidebar_4.2.5"><a href="#sec-The-__Directive-Type"><span class="spec-secid">4.2.5</span>The __Directive Type</a></li></ol></li></ol></li><li id="_sidebar_5"><a href="#sec-Validation"><span class="spec-secid">5</span>Validation</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5" /><label for="_sidebar_toggle_5"></label><ol><li id="_sidebar_5.1"><a href="#sec-Validation.Operations"><span class="spec-secid">5.1</span>Operations</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1" /><label for="_sidebar_toggle_5.1"></label><ol><li id="_sidebar_5.1.1"><a href="#sec-Named-Operation-Definitions"><span class="spec-secid">5.1.1</span>Named Operation Definitions</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1.1" /><label for="_sidebar_toggle_5.1.1"></label><ol><li id="_sidebar_5.1.1.1"><a href="#sec-Operation-Name-Uniqueness"><span class="spec-secid">5.1.1.1</span>Operation Name Uniqueness</a></li></ol></li><li id="_sidebar_5.1.2"><a href="#sec-Anonymous-Operation-Definitions"><span class="spec-secid">5.1.2</span>Anonymous Operation Definitions</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1.2" /><label for="_sidebar_toggle_5.1.2"></label><ol><li id="_sidebar_5.1.2.1"><a href="#sec-Lone-Anonymous-Operation"><span class="spec-secid">5.1.2.1</span>Lone Anonymous Operation</a></li></ol></li></ol></li><li id="_sidebar_5.2"><a href="#sec-Validation.Fields"><span class="spec-secid">5.2</span>Fields</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.2" /><label for="_sidebar_toggle_5.2"></label><ol><li id="_sidebar_5.2.1"><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types"><span class="spec-secid">5.2.1</span>Field Selections on Objects, Interfaces, and Unions Types</a></li><li id="_sidebar_5.2.2"><a href="#sec-Field-Selection-Merging"><span class="spec-secid">5.2.2</span>Field Selection Merging</a></li><li id="_sidebar_5.2.3"><a href="#sec-Leaf-Field-Selections"><span class="spec-secid">5.2.3</span>Leaf Field Selections</a></li></ol></li><li id="_sidebar_5.3"><a href="#sec-Validation.Arguments"><span class="spec-secid">5.3</span>Arguments</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.3" /><label for="_sidebar_toggle_5.3"></label><ol><li id="_sidebar_5.3.1"><a href="#sec-Argument-Names"><span class="spec-secid">5.3.1</span>Argument Names</a></li><li id="_sidebar_5.3.2"><a href="#sec-Argument-Uniqueness"><span class="spec-secid">5.3.2</span>Argument Uniqueness</a></li><li id="_sidebar_5.3.3"><a href="#sec-Argument-Values-Type-Correctness"><span class="spec-secid">5.3.3</span>Argument Values Type Correctness</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.3.3" /><label for="_sidebar_toggle_5.3.3"></label><ol><li id="_sidebar_5.3.3.1"><a href="#sec-Compatible-Values"><span class="spec-secid">5.3.3.1</span>Compatible Values</a></li><li id="_sidebar_5.3.3.2"><a href="#sec-Required-Non-Null-Arguments"><span class="spec-secid">5.3.3.2</span>Required Non-Null Arguments</a></li></ol></li></ol></li><li id="_sidebar_5.4"><a href="#sec-Validation.Fragments"><span class="spec-secid">5.4</span>Fragments</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4" /><label for="_sidebar_toggle_5.4"></label><ol><li id="_sidebar_5.4.1"><a href="#sec-Fragment-Declarations"><span class="spec-secid">5.4.1</span>Fragment Declarations</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.1" /><label for="_sidebar_toggle_5.4.1"></label><ol><li id="_sidebar_5.4.1.1"><a href="#sec-Fragment-Name-Uniqueness"><span class="spec-secid">5.4.1.1</span>Fragment Name Uniqueness</a></li><li id="_sidebar_5.4.1.2"><a href="#sec-Fragment-Spread-Type-Existence"><span class="spec-secid">5.4.1.2</span>Fragment Spread Type Existence</a></li><li id="_sidebar_5.4.1.3"><a href="#sec-Fragments-On-Composite-Types"><span class="spec-secid">5.4.1.3</span>Fragments On Composite Types</a></li><li id="_sidebar_5.4.1.4"><a href="#sec-Fragments-Must-Be-Used"><span class="spec-secid">5.4.1.4</span>Fragments Must Be Used</a></li></ol></li><li id="_sidebar_5.4.2"><a href="#sec-Fragment-Spreads"><span class="spec-secid">5.4.2</span>Fragment Spreads</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.2" /><label for="_sidebar_toggle_5.4.2"></label><ol><li id="_sidebar_5.4.2.1"><a href="#sec-Fragment-spread-target-defined"><span class="spec-secid">5.4.2.1</span>Fragment spread target defined</a></li><li id="_sidebar_5.4.2.2"><a href="#sec-Fragment-spreads-must-not-form-cycles"><span class="spec-secid">5.4.2.2</span>Fragment spreads must not form cycles</a></li><li id="_sidebar_5.4.2.3"><a href="#sec-Fragment-spread-is-possible"><span class="spec-secid">5.4.2.3</span>Fragment spread is possible</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.2.3" /><label for="_sidebar_toggle_5.4.2.3"></label><ol><li id="_sidebar_5.4.2.3.1"><a href="#sec-Object-Spreads-In-Object-Scope"><span class="spec-secid">5.4.2.3.1</span>Object Spreads In Object Scope</a></li><li id="_sidebar_5.4.2.3.2"><a href="#sec-Abstract-Spreads-in-Object-Scope"><span class="spec-secid">5.4.2.3.2</span>Abstract Spreads in Object Scope</a></li><li id="_sidebar_5.4.2.3.3"><a href="#sec-Object-Spreads-In-Abstract-Scope"><span class="spec-secid">5.4.2.3.3</span>Object Spreads In Abstract Scope</a></li><li id="_sidebar_5.4.2.3.4"><a href="#sec-Abstract-Spreads-in-Abstract-Scope"><span class="spec-secid">5.4.2.3.4</span>Abstract Spreads in Abstract Scope</a></li></ol></li></ol></li></ol></li><li id="_sidebar_5.5"><a href="#sec-Values"><span class="spec-secid">5.5</span>Values</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.5" /><label for="_sidebar_toggle_5.5"></label><ol><li id="_sidebar_5.5.1"><a href="#sec-Input-Object-Field-Uniqueness"><span class="spec-secid">5.5.1</span>Input Object Field Uniqueness</a></li></ol></li><li id="_sidebar_5.6"><a href="#sec-Validation.Directives"><span class="spec-secid">5.6</span>Directives</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.6" /><label for="_sidebar_toggle_5.6"></label><ol><li id="_sidebar_5.6.1"><a href="#sec-Directives-Are-Defined"><span class="spec-secid">5.6.1</span>Directives Are Defined</a></li><li id="_sidebar_5.6.2"><a href="#sec-Directives-Are-In-Valid-Locations"><span class="spec-secid">5.6.2</span>Directives Are In Valid Locations</a></li><li id="_sidebar_5.6.3"><a href="#sec-Directives-Are-Unique-Per-Location"><span class="spec-secid">5.6.3</span>Directives Are Unique Per Location</a></li></ol></li><li id="_sidebar_5.7"><a href="#sec-Validation.Variables"><span class="spec-secid">5.7</span>Variables</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.7" /><label for="_sidebar_toggle_5.7"></label><ol><li id="_sidebar_5.7.1"><a href="#sec-Variable-Uniqueness"><span class="spec-secid">5.7.1</span>Variable Uniqueness</a></li><li id="_sidebar_5.7.2"><a href="#sec-Variable-Default-Values-Are-Correctly-Typed"><span class="spec-secid">5.7.2</span>Variable Default Values Are Correctly Typed</a></li><li id="_sidebar_5.7.3"><a href="#sec-Variables-Are-Input-Types"><span class="spec-secid">5.7.3</span>Variables Are Input Types</a></li><li id="_sidebar_5.7.4"><a href="#sec-All-Variable-Uses-Defined"><span class="spec-secid">5.7.4</span>All Variable Uses Defined</a></li><li id="_sidebar_5.7.5"><a href="#sec-All-Variables-Used"><span class="spec-secid">5.7.5</span>All Variables Used</a></li><li id="_sidebar_5.7.6"><a href="#sec-All-Variable-Usages-are-Allowed"><span class="spec-secid">5.7.6</span>All Variable Usages are Allowed</a></li></ol></li></ol></li><li id="_sidebar_6"><a href="#sec-Execution"><span class="spec-secid">6</span>Execution</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6" /><label for="_sidebar_toggle_6"></label><ol><li id="_sidebar_6.1"><a href="#sec-Executing-Requests"><span class="spec-secid">6.1</span>Executing Requests</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.1" /><label for="_sidebar_toggle_6.1"></label><ol><li id="_sidebar_6.1.1"><a href="#sec-Validating-Requests"><span class="spec-secid">6.1.1</span>Validating Requests</a></li><li id="_sidebar_6.1.2"><a href="#sec-Coercing-Variable-Values"><span class="spec-secid">6.1.2</span>Coercing Variable Values</a></li></ol></li><li id="_sidebar_6.2"><a href="#sec-Executing-Operations"><span class="spec-secid">6.2</span>Executing Operations</a></li><li id="_sidebar_6.3"><a href="#sec-Executing-Selection-Sets"><span class="spec-secid">6.3</span>Executing Selection Sets</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.3" /><label for="_sidebar_toggle_6.3"></label><ol><li id="_sidebar_6.3.1"><a href="#sec-Normal-and-Serial-Execution"><span class="spec-secid">6.3.1</span>Normal and Serial Execution</a></li><li id="_sidebar_6.3.2"><a href="#sec-Field-Collection"><span class="spec-secid">6.3.2</span>Field Collection</a></li></ol></li><li id="_sidebar_6.4"><a href="#sec-Executing-Fields"><span class="spec-secid">6.4</span>Executing Fields</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.4" /><label for="_sidebar_toggle_6.4"></label><ol><li id="_sidebar_6.4.1"><a href="#sec-Coercing-Field-Arguments"><span class="spec-secid">6.4.1</span>Coercing Field Arguments</a></li><li id="_sidebar_6.4.2"><a href="#sec-Value-Resolution"><span class="spec-secid">6.4.2</span>Value Resolution</a></li><li id="_sidebar_6.4.3"><a href="#sec-Value-Completion"><span class="spec-secid">6.4.3</span>Value Completion</a></li><li id="_sidebar_6.4.4"><a href="#sec-Errors-and-Non-Nullability"><span class="spec-secid">6.4.4</span>Errors and Non-Nullability</a></li></ol></li></ol></li><li id="_sidebar_7"><a href="#sec-Response"><span class="spec-secid">7</span>Response</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7" /><label for="_sidebar_toggle_7"></label><ol><li id="_sidebar_7.1"><a href="#sec-Serialization-Format"><span class="spec-secid">7.1</span>Serialization Format</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7.1" /><label for="_sidebar_toggle_7.1"></label><ol><li id="_sidebar_7.1.1"><a href="#sec-JSON-Serialization"><span class="spec-secid">7.1.1</span>JSON Serialization</a></li></ol></li><li id="_sidebar_7.2"><a href="#sec-Response-Format"><span class="spec-secid">7.2</span>Response Format</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7.2" /><label for="_sidebar_toggle_7.2"></label><ol><li id="_sidebar_7.2.1"><a href="#sec-Data"><span class="spec-secid">7.2.1</span>Data</a></li><li id="_sidebar_7.2.2"><a href="#sec-Errors"><span class="spec-secid">7.2.2</span>Errors</a></li></ol></li></ol></li><li id="_sidebar_A"><a href="#sec-Appendix-Notation-Conventions"><span class="spec-secid">A</span>Appendix: Notation Conventions</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_A" /><label for="_sidebar_toggle_A"></label><ol><li id="_sidebar_A.1"><a href="#sec-Context-Free-Grammar"><span class="spec-secid">A.1</span>Context-Free Grammar</a></li><li id="_sidebar_A.2"><a href="#sec-Lexical-and-Syntactical-Grammar"><span class="spec-secid">A.2</span>Lexical and Syntactical Grammar</a></li><li id="_sidebar_A.3"><a href="#sec-Grammar-Notation"><span class="spec-secid">A.3</span>Grammar Notation</a></li><li id="_sidebar_A.4"><a href="#sec-Grammar-Semantics"><span class="spec-secid">A.4</span>Grammar Semantics</a></li><li id="_sidebar_A.5"><a href="#sec-Algorithms"><span class="spec-secid">A.5</span>Algorithms</a></li></ol></li><li id="_sidebar_B"><a href="#sec-Appendix-Grammar-Summary"><span class="spec-secid">B</span>Appendix: Grammar Summary</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_B" /><label for="_sidebar_toggle_B"></label><ol><li id="_sidebar_B.1"><a href="#sec-Appendix-Grammar-Summary.Ignored-Tokens"><span class="spec-secid">B.1</span>Ignored Tokens</a></li><li id="_sidebar_B.2"><a href="#sec-Appendix-Grammar-Summary.Lexical-Tokens"><span class="spec-secid">B.2</span>Lexical Tokens</a></li><li id="_sidebar_B.3"><a href="#sec-Appendix-Grammar-Summary.Query-Document"><span class="spec-secid">B.3</span>Query Document</a></li></ol></li><li id="_sidebar_index"><a href="#index"><span class="spec-secid">ยง</span>Index</a></li></ol></div><script>(function (){
var currentSection;
var numberedSections = [];

var sections = document.getElementsByTagName('section');
for (var i = 0; i < sections.length; i++) {
  if (sections[i].getAttribute('secid')) {
    numberedSections.push(sections[i]);
  }
}

var scrollPos = window.scrollY;
var pending = false;
window.addEventListener('scroll', function (e) {
  scrollPos = window.scrollY;
  if (!pending) {
    pending = true;
    window.requestAnimationFrame(function () {
      updateSectionFocus(scrollPos);
      pending = false;
    });
  }
});

function updateSectionFocus(pos) {
  var readLine = pos + document.documentElement.clientHeight / 4;

  var focusedSection;
  for (var n = numberedSections.length - 1; n >= 0; n--) {
    if (numberedSections[n].offsetTop < readLine) {
      focusedSection = numberedSections[n];
      break;
    }
  }

  var secid = focusedSection && focusedSection.getAttribute('secid');
  if (secid !== currentSection) {
    currentSection && fold(currentSection, false);
    secid && fold(secid, true);
    currentSection = secid;
  }
}

function fold(secid, check) {
  document.getElementById('_sidebar_' + secid).className = check ? 'viewing' : '';
  var sections = secid.split('.');
  while (sections.length) {
    var toggle = document.getElementById('_sidebar_toggle_' + sections.join('.'));
    if (toggle) {
      toggle.checked = check;
    }
    sections.pop();
  }
}

updateSectionFocus(window.scrollY);
})()</script></div></body></html>
