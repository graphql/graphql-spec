<!DOCTYPE html>
<html>
<!-- Built with spec-md -->

<head>
  <meta charset="utf-8">
  <title>GraphQL</title>
  <link href="spec.css" rel="stylesheet">
  <link href="highlight.css" rel="stylesheet">
</head>

<body>
  <header>
    <h1>GraphQL</h1>
    <section id="intro">
      <p><em>Working Draft &ndash; July 2015</em></p>
      <p><strong>Introduction</strong></p>
      <p>This is a Draft RFC Specification for GraphQL, a query language created by Facebook in 2012 for describing the capabilities and requirements of data models for client&#8208;server applications. The development of this standard started in 2015. GraphQL
        is a new and evolving language and is not complete. Significant enhancement will continue in future editions of this specification.</p>
      <p><strong>Copyright notice</strong></p>
      <p>Copyright (c) 2015, Facebook, Inc. All rights reserved.</p>
      <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
      <ul>
        <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
        <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
        <li>Neither the name Facebook nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
      </ul>
      <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &ldquo;AS IS&rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
        OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        POSSIBILITY OF SUCH DAMAGE.</p>
    </section>
    <div class="spec-toc">
      <ol>
        <li><a href="#sec-Overview"><span class="spec-secnum">1</span>Overview</a></li>
        <li><a href="#sec-Language"><span class="spec-secnum">2</span>Language</a>
          <ol>
            <li><a href="#sec-Names"><span class="spec-secnum">2.1</span>Names</a></li>
            <li><a href="#sec-Language.Document"><span class="spec-secnum">2.2</span>Document</a></li>
            <li><a href="#sec-Language.Operations"><span class="spec-secnum">2.3</span>Operations</a></li>
            <li><a href="#sec-Language.Fields"><span class="spec-secnum">2.4</span>Fields</a></li>
            <li><a href="#sec-Field-Selections"><span class="spec-secnum">2.5</span>Field Selections</a></li>
            <li><a href="#sec-Language.Arguments"><span class="spec-secnum">2.6</span>Arguments</a></li>
            <li><a href="#sec-Field-Alias"><span class="spec-secnum">2.7</span>Field Alias</a></li>
            <li><a href="#sec-Input-Values"><span class="spec-secnum">2.8</span>Input Values</a></li>
            <li><a href="#sec-Language.Variables"><span class="spec-secnum">2.9</span>Variables</a></li>
            <li><a href="#sec-Language.Fragments"><span class="spec-secnum">2.10</span>Fragments</a>
              <ol>
                <li><a href="#sec-Types-on-fragments"><span class="spec-secnum">2.10.1</span>Types on fragments</a></li>
                <li><a href="#sec-Query-variables-in-fragments"><span class="spec-secnum">2.10.2</span>Query variables in fragments</a></li>
                <li><a href="#sec-Inline-fragments"><span class="spec-secnum">2.10.3</span>Inline fragments</a></li>
              </ol>
            </li>
            <li><a href="#sec-Language.Directives"><span class="spec-secnum">2.11</span>Directives</a>
              <ol>
                <li><a href="#sec-Fragment-Directives"><span class="spec-secnum">2.11.1</span>Fragment Directives</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#sec-Type-System"><span class="spec-secnum">3</span>Type System</a>
          <ol>
            <li><a href="#sec-Type-System.Types"><span class="spec-secnum">3.1</span>Types</a>
              <ol>
                <li><a href="#sec-Scalars"><span class="spec-secnum">3.1.1</span>Scalars</a>
                  <ol>
                    <li><a href="#sec-Built-in-Scalars"><span class="spec-secnum">3.1.1.1</span>Built-in Scalars</a>
                      <ol>
                        <li><a href="#sec-Int"><span class="spec-secnum">3.1.1.1.1</span>Int</a></li>
                        <li><a href="#sec-Float"><span class="spec-secnum">3.1.1.1.2</span>Float</a></li>
                        <li><a href="#sec-String"><span class="spec-secnum">3.1.1.1.3</span>String</a></li>
                        <li><a href="#sec-Boolean"><span class="spec-secnum">3.1.1.1.4</span>Boolean</a></li>
                        <li><a href="#sec-ID"><span class="spec-secnum">3.1.1.1.5</span>ID</a></li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li><a href="#sec-Objects"><span class="spec-secnum">3.1.2</span>Objects</a>
                  <ol>
                    <li><a href="#sec-Object-Field-Arguments"><span class="spec-secnum">3.1.2.1</span>Object Field Arguments</a></li>
                    <li><a href="#sec-Object-Field-deprecation"><span class="spec-secnum">3.1.2.2</span>Object Field deprecation</a></li>
                    <li><a href="#sec-Object-type-validation"><span class="spec-secnum">3.1.2.3</span>Object type validation</a></li>
                  </ol>
                </li>
                <li><a href="#sec-Interfaces"><span class="spec-secnum">3.1.3</span>Interfaces</a>
                  <ol>
                    <li><a href="#sec-Interface-type-validation"><span class="spec-secnum">3.1.3.1</span>Interface type validation</a></li>
                  </ol>
                </li>
                <li><a href="#sec-Unions"><span class="spec-secnum">3.1.4</span>Unions</a>
                  <ol>
                    <li><a href="#sec-Union-type-validation"><span class="spec-secnum">3.1.4.1</span>Union type validation</a></li>
                  </ol>
                </li>
                <li><a href="#sec-Enums"><span class="spec-secnum">3.1.5</span>Enums</a></li>
                <li><a href="#sec-Input-Objects"><span class="spec-secnum">3.1.6</span>Input Objects</a></li>
                <li><a href="#sec-Lists"><span class="spec-secnum">3.1.7</span>Lists</a></li>
                <li><a href="#sec-Non-Null"><span class="spec-secnum">3.1.8</span>Non-Null</a></li>
              </ol>
            </li>
            <li><a href="#sec-Type-System.Directives"><span class="spec-secnum">3.2</span>Directives</a>
              <ol>
                <li><a href="#sec--skip"><span class="spec-secnum">3.2.1</span>@skip</a></li>
                <li><a href="#sec--include"><span class="spec-secnum">3.2.2</span>@include</a></li>
              </ol>
            </li>
            <li><a href="#sec-Starting-types"><span class="spec-secnum">3.3</span>Starting types</a></li>
          </ol>
        </li>
        <li><a href="#sec-Introspection"><span class="spec-secnum">4</span>Introspection</a>
          <ol>
            <li><a href="#sec-General-Principles"><span class="spec-secnum">4.1</span>General Principles</a>
              <ol>
                <li><a href="#sec-Naming-conventions"><span class="spec-secnum">4.1.1</span>Naming conventions</a></li>
                <li><a href="#sec-Documentation"><span class="spec-secnum">4.1.2</span>Documentation</a></li>
                <li><a href="#sec-Deprecation"><span class="spec-secnum">4.1.3</span>Deprecation</a></li>
                <li><a href="#sec-Type-Name-Introspection"><span class="spec-secnum">4.1.4</span>Type Name Introspection</a></li>
              </ol>
            </li>
            <li><a href="#sec-Schema-Introspection"><span class="spec-secnum">4.2</span>Schema Introspection</a>
              <ol>
                <li><a href="#sec-The-__Type-Type"><span class="spec-secnum">4.2.1</span>The &quot;__Type&quot; Type</a></li>
                <li><a href="#sec-Type-Kinds"><span class="spec-secnum">4.2.2</span>Type Kinds</a>
                  <ol>
                    <li><a href="#sec-Scalar"><span class="spec-secnum">4.2.2.1</span>Scalar</a></li>
                    <li><a href="#sec-Object"><span class="spec-secnum">4.2.2.2</span>Object</a></li>
                    <li><a href="#sec-Union"><span class="spec-secnum">4.2.2.3</span>Union</a></li>
                    <li><a href="#sec-Interface"><span class="spec-secnum">4.2.2.4</span>Interface</a></li>
                    <li><a href="#sec-Enum"><span class="spec-secnum">4.2.2.5</span>Enum</a></li>
                    <li><a href="#sec-Input-Object"><span class="spec-secnum">4.2.2.6</span>Input Object</a></li>
                    <li><a href="#sec-List"><span class="spec-secnum">4.2.2.7</span>List</a></li>
                    <li><a href="#sec-Non-null"><span class="spec-secnum">4.2.2.8</span>Non-null</a></li>
                    <li><a href="#sec-Combining-List-and-Non-Null"><span class="spec-secnum">4.2.2.9</span>Combining List and Non-Null</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#sec-Validation"><span class="spec-secnum">5</span>Validation</a>
          <ol>
            <li><a href="#sec-Validation.Fields"><span class="spec-secnum">5.1</span>Fields</a>
              <ol>
                <li><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types"><span class="spec-secnum">5.1.1</span>Field Selections on Objects, Interfaces, and Unions Types</a></li>
                <li><a href="#sec-Field-Selection-Merging"><span class="spec-secnum">5.1.2</span>Field Selection Merging</a></li>
                <li><a href="#sec-Leaf-Field-Selections"><span class="spec-secnum">5.1.3</span>Leaf Field Selections</a></li>
              </ol>
            </li>
            <li><a href="#sec-Validation.Arguments"><span class="spec-secnum">5.2</span>Arguments</a>
              <ol>
                <li><a href="#sec-Argument-Names"><span class="spec-secnum">5.2.1</span>Argument Names</a></li>
                <li><a href="#sec-Argument-Values-Type-Correctness"><span class="spec-secnum">5.2.2</span>Argument Values Type Correctness</a>
                  <ol>
                    <li><a href="#sec-Compatible-Values"><span class="spec-secnum">5.2.2.1</span>Compatible Values</a></li>
                    <li><a href="#sec-Required-Arguments"><span class="spec-secnum">5.2.2.2</span>Required Arguments</a></li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#sec-Validation.Fragments"><span class="spec-secnum">5.3</span>Fragments</a>
              <ol>
                <li><a href="#sec-Fragment-Declarations"><span class="spec-secnum">5.3.1</span>Fragment Declarations</a>
                  <ol>
                    <li><a href="#sec-Fragment-Spread-Type-Existence"><span class="spec-secnum">5.3.1.1</span>Fragment Spread Type Existence</a></li>
                    <li><a href="#sec-Fragments-On-Composite-Types"><span class="spec-secnum">5.3.1.2</span>Fragments On Composite Types</a></li>
                    <li><a href="#sec-Fragments-Must-Be-Used"><span class="spec-secnum">5.3.1.3</span>Fragments Must Be Used</a></li>
                  </ol>
                </li>
                <li><a href="#sec-Fragment-Spreads"><span class="spec-secnum">5.3.2</span>Fragment Spreads</a>
                  <ol>
                    <li><a href="#sec-Fragment-spread-target-defined"><span class="spec-secnum">5.3.2.1</span>Fragment spread target defined</a></li>
                    <li><a href="#sec-Fragment-spreads-must-not-form-cycles"><span class="spec-secnum">5.3.2.2</span>Fragment spreads must not form cycles</a></li>
                    <li><a href="#sec-Fragment-spread-is-possible"><span class="spec-secnum">5.3.2.3</span>Fragment spread is possible</a>
                      <ol>
                        <li><a href="#sec-Object-Spreads-In-Object-Scope"><span class="spec-secnum">5.3.2.3.1</span>Object Spreads In Object Scope</a></li>
                        <li><a href="#sec-Abstract-Spreads-in-Object-Scope"><span class="spec-secnum">5.3.2.3.2</span>Abstract Spreads in Object Scope</a></li>
                        <li><a href="#sec-Object-Spreads-In-Abstract-Scope"><span class="spec-secnum">5.3.2.3.3</span>Object Spreads In Abstract Scope</a></li>
                        <li><a href="#sec-Abstract-Spreads-in-Abstract-Scope"><span class="spec-secnum">5.3.2.3.4</span>Abstract Spreads in Abstract Scope</a></li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#sec-Validation.Directives"><span class="spec-secnum">5.4</span>Directives</a>
              <ol>
                <li><a href="#sec-Directives-Are-Defined"><span class="spec-secnum">5.4.1</span>Directives Are Defined</a></li>
              </ol>
            </li>
            <li><a href="#sec-Validation.Operations"><span class="spec-secnum">5.5</span>Operations</a>
              <ol>
                <li><a href="#sec-Validation.Operations.Variables"><span class="spec-secnum">5.5.1</span>Variables</a>
                  <ol>
                    <li><a href="#sec-Variable-Default-Values-Are-Correctly-Typed"><span class="spec-secnum">5.5.1.1</span>Variable Default Values Are Correctly Typed</a></li>
                    <li><a href="#sec-Variables-Are-Input-Types"><span class="spec-secnum">5.5.1.2</span>Variables Are Input Types</a></li>
                    <li><a href="#sec-All-Variable-Uses-Defined"><span class="spec-secnum">5.5.1.3</span>All Variable Uses Defined</a></li>
                    <li><a href="#sec-All-Variables-Used"><span class="spec-secnum">5.5.1.4</span>All Variables Used</a></li>
                    <li><a href="#sec-All-Variable-Usages-are-Allowed"><span class="spec-secnum">5.5.1.5</span>All Variable Usages are Allowed</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#sec-Execution"><span class="spec-secnum">6</span>Execution</a>
          <ol>
            <li><a href="#sec-Evaluating-requests"><span class="spec-secnum">6.1</span>Evaluating requests</a></li>
            <li><a href="#sec-Evaluating-operations"><span class="spec-secnum">6.2</span>Evaluating operations</a></li>
            <li><a href="#sec-Evaluating-selection-sets"><span class="spec-secnum">6.3</span>Evaluating selection sets</a></li>
            <li><a href="#sec-Evaluating-a-grouped-field-set"><span class="spec-secnum">6.4</span>Evaluating a grouped field set</a>
              <ol>
                <li><a href="#sec-Field-entries"><span class="spec-secnum">6.4.1</span>Field entries</a></li>
                <li><a href="#sec-Normal-evaluation"><span class="spec-secnum">6.4.2</span>Normal evaluation</a></li>
                <li><a href="#sec-Serial-execution"><span class="spec-secnum">6.4.3</span>Serial execution</a></li>
                <li><a href="#sec-Error-handling"><span class="spec-secnum">6.4.4</span>Error handling</a></li>
                <li><a href="#sec-Nullability"><span class="spec-secnum">6.4.5</span>Nullability</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#sec-Response"><span class="spec-secnum">7</span>Response</a>
          <ol>
            <li><a href="#sec-Serialization-Format"><span class="spec-secnum">7.1</span>Serialization Format</a>
              <ol>
                <li><a href="#sec-JSON-Serialization"><span class="spec-secnum">7.1.1</span>JSON Serialization</a></li>
              </ol>
            </li>
            <li><a href="#sec-Response-Format"><span class="spec-secnum">7.2</span>Response Format</a>
              <ol>
                <li><a href="#sec-Data"><span class="spec-secnum">7.2.1</span>Data</a></li>
                <li><a href="#sec-Errors"><span class="spec-secnum">7.2.2</span>Errors</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#sec-Grammar"><span class="spec-secnum">8</span>Grammar</a>
          <ol>
            <li><a href="#sec-Tokens"><span class="spec-secnum">8.1</span>Tokens</a>
              <ol>
                <li><a href="#sec-Ignored-Source"><span class="spec-secnum">8.1.1</span>Ignored Source</a></li>
              </ol>
            </li>
            <li><a href="#sec-Syntax"><span class="spec-secnum">8.2</span>Syntax</a>
              <ol>
                <li><a href="#sec-Syntax.Document"><span class="spec-secnum">8.2.1</span>Document</a></li>
                <li><a href="#sec-Syntax.Operations"><span class="spec-secnum">8.2.2</span>Operations</a></li>
                <li><a href="#sec-Syntax.Fragments"><span class="spec-secnum">8.2.3</span>Fragments</a></li>
                <li><a href="#sec-Values"><span class="spec-secnum">8.2.4</span>Values</a>
                  <ol>
                    <li><a href="#sec-Array-Value"><span class="spec-secnum">8.2.4.1</span>Array Value</a></li>
                    <li><a href="#sec-Object-Value"><span class="spec-secnum">8.2.4.2</span>Object Value</a></li>
                  </ol>
                </li>
                <li><a href="#sec-Syntax.Directives"><span class="spec-secnum">8.2.5</span>Directives</a></li>
                <li><a href="#sec-Syntax.Types"><span class="spec-secnum">8.2.6</span>Types</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </div>
  </header>
  <section id="sec-Overview">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Overview">1</a></span>Overview</h2>
    <p>GraphQL is a query language designed to build client applications by providing an intuitive and flexible syntax and system for describing their data requirements and interactions.</p>
    <p>For example, this GraphQL request will receive the name of the user with id 4 from the Facebook implementation of GraphQL.</p><pre><code>{
  user(id: 4) {
    name
  }
}
</code></pre>
    <p>Which produces the resulting data (in JSON):</p><pre><code>{
  <span class="hljs-string">"user"</span>: {
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>
  }
}
</code></pre>
    <p>GraphQL is not a programming language capable of arbitrary computation, but is instead a language used to query application servers that have capabilities defined in this specification. GraphQL does not mandate a particular programming language or
      storage system for application servers that implement it. Instead, application servers take their capabilities and map them to a uniform language, type system, and philosophy that GraphQL encodes. This provides a unified interface friendly to product
      development and a powerful platform for tool&#8208;building.</p>
    <p>GraphQL has a number of design principles:</p>
    <ul>
      <li><strong>Hierarchical</strong>: Most product development today involves the creation and manipulation of view hierarchies. To achieve congruence with the structure of these applications, a GraphQL query itself is structured hierarchically. The query
        is shaped just like the data it returns. It is a natural way for clients to describe data requirements.</li>
      <li><strong>Product&#8208;centric</strong>: GraphQL is unapologetically driven by the requirements of views and the front&#8208;end engineers that write them. GraphQL starts with their way of thinking and requirements and build the language and runtime
        necessary to enable that.</li>
      <li><strong>Strong&#8208;typing</strong>: Every GraphQL server defines an application&#8208;specific type system. Queries are executed within the context of that type system. Given a query, tools can ensure that the query is both syntactically correct
        and valid within the GraphQL type system before execution, i.e. at development time, and the server can make certain guarantees about the shape and nature of the response.</li>
      <li><strong>Client&#8208;specified queries</strong>: Through its type system, a GraphQL server publishes the capabilities that its clients are allowed to consume. It is the client that is responsible for specifying exactly how it will consume those
        published capabilities. These queries are specified at field&#8208;level granularity. In the majority of client&#8208;server applications written without GraphQL, the server determines the data returned in its various scripted endpoints. A GraphQL
        query, on the other hand, returns exactly what a client asks for and no more.</li>
      <li><strong>Introspective</strong>: GraphQL is introspective. A GraphQL server&rsquo;s type system must be queryable by the GraphQL language itself, as will be described in this specification. GraphQL introspection serves as a powerful platform for
        building common tools and client software libraries.</li>
    </ul>
    <p>Because of these principles, GraphQL is a powerful and productive environment for building client applications. Product developers and designers building applications against working GraphQL servers -- supported with quality tools -- can quickly become
      productive without reading extensive documentation and with little or no formal training. To enable that experience, there must be those that build those servers and tools.</p>
    <p>The following formal specification serves as a reference for those builders. It describes the language and its grammar; the type system and the introspection system used to query it; and the execution and validation engines with the algorithms to
      power them. The goal of this specification is to provide a foundation and framework for an ecosystem of GraphQL tools, client libraries, and server implementations -- spanning both organizations and platforms -- that has yet to be built. We look
      forward to working with the community in order to do that. </p>
  </section>
  <section id="sec-Language">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Language">2</a></span>Language</h2>
    <p>Clients use the GraphQL language to make requests to a GraphQL server. We refer to these requests as documents. A document may contain operations (queries and mutations are both operations) and fragments, a common unit of composition allowing for
      query reuse.</p>
    <section id="sec-Names">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Names">2.1</a></span>Names</h3>
      <p>GraphQL documents are full of named things: operations, fields, arguments, directives, fragments, and variables. All names follow the same grammatical form:</p>
      <div class="spec-production" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span>
        <div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div>
      </div>
      <p>Names in GraphQL are case&#8208;sensitive. That is to say <code>name</code>, <code>Name</code>, and <code>NAME</code> all refer to different names. Underscores are significant, which means <code>other_name</code> and <code>othername</code> are two
        different names.</p>
      <p>Names in GraphQL are limited to this <acronym>ASCII</acronym> subset of possible characters to support interoperation with as many other systems as possible.</p>
    </section>
    <section id="sec-Language.Document">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Document">2.2</a></span>Document</h3>
      <p>GraphQL documents are only executable by a server if they contain an operation. However documents which do not contain operations may still be parsed and validated to allow client to represent a single request across many documents.</p>
      <p>GraphQL documents may contain multiple operations, as long as they are named. When submitting a document with multiple operations to a GraphQL server, the name of the desired operation must also be provided.</p>
      <p>If a document contains only one query operation, that operation may be represented in the shorthand form, which omits the query keyword and query name.</p>
    </section>
    <section id="sec-Language.Operations">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Operations">2.3</a></span>Operations</h3>
      <p>There are two types of operations that GraphQL models:</p>
      <ul>
        <li>query &ndash; a read&#8208;only fetch.</li>
        <li>mutation &ndash; a write followed by a fetch.</li>
      </ul>
      <p>Each operation is represented by a custom name and a selection of fields.</p>
      <p><strong>Query shorthand</strong></p>
      <p>If a query has no variables or directives or name, the <code>query</code> keyword can be omitted. This means it must be the only query in the document.</p>
      <div class="spec-note">many examples below will use the query shorthand syntax.</div>
    </section>
    <section id="sec-Language.Fields">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Fields">2.4</a></span>Fields</h3>
      <p>A field in the top&#8208;level selection set often represents some kind of information that is globally accessible to your application and the current viewer. Some typical examples of global fields:</p><pre><code># `me` could represent the currently logged in user.
query getMe {
  me { /* ... */ }
}

# `user` represents one of many users in a graph of data.
query getZuck {
  user(id: 4) { /* ... */ }
}
</code></pre></section>
    <section id="sec-Field-Selections">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Field-Selections">2.5</a></span>Field Selections</h3>
      <p>Each field is of a specific type, and the sub&#8208;fields must always be explicitly declared via a field selection, unless it is a scalar. For example, when fetching data from some user object:</p><pre><code>query getZuck {
  user(id: 4) {
    id,
    firstName,
    lastName
  }
}
</code></pre>
      <p>Field selections can be further composed to explicitly state all subfields of nested types. All queries must specify down to scalar fields.</p><pre><code>query getZuck {
  user(id: 4) {
    id,
    firstName,
    lastName,
    birthday {
      month,
      day
    }
  }
}
</code></pre></section>
    <section id="sec-Language.Arguments">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Arguments">2.6</a></span>Arguments</h3>
      <p>Fields and directives may take arguments.</p>
      <p>These often map directly to function arguments within the GraphQL server implementation. We already saw arguments used in the global field above.</p>
      <p>In this example, we want to query a user&rsquo;s profile picture of a specific size:</p><pre><code>{
  user(id: 4) {
    id,
    name,
    profilePic(size: 100)
  }
}
</code></pre>
      <p>Many arguments can exist for a given field:</p><pre><code>{
  user(id: 4) {
    id,
    name,
    profilePic(width: 100, height: 50)
  }
}
</code></pre>
      <p><strong>Arguments are unordered</strong></p>
      <p>Arguments may be provided in any syntactic order and maintain identical semantic meaning.</p>
      <p>These two queries are semantically identical:</p><pre><code>{
  picture(width: 200, height: 100)
}
</code></pre><pre><code>{
  picture(height: 100, width: 200)
}
</code></pre></section>
    <section id="sec-Field-Alias">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Field-Alias">2.7</a></span>Field Alias</h3>
      <p>By default, the key in the response object will use the field name queried. However, you can define a different name by specifying an alias.</p>
      <p>In this example, we can fetch two profile pictures of different sizes and ensure the resulting object will not have duplicate keys:</p><pre><code>{
  user(id: 4) {
    id,
    name,
    smallPic: profilePic(size: 64),
    bigPic: profilePic(size: 1024)
  }
}
</code></pre>
      <p>Which returns the result:</p><pre><code>{
  <span class="hljs-string">"user"</span>: {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Mark"</span>,
    <span class="hljs-string">"smallPic"</span>: <span class="hljs-string">"https://cdn.site.io/pic-4-64.jpg"</span>,
    <span class="hljs-string">"bigPic"</span>: <span class="hljs-string">"https://cdn.site.io/pic-4-1024.jpg"</span>
  }
}
</code></pre>
      <p>Since the top level of a query is a field, it also can be given an alias:</p><pre><code>{
  zuck: user(id: 4) {
    id,
    name
  }
}
</code></pre>
      <p>Returns the result:</p><pre><code>{
  <span class="hljs-string">"zuck"</span>: {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>
  }
}
</code></pre>
      <p>A field&rsquo;s response key is its alias if an alias is provided, and it is the field&rsquo;s name otherwise.</p>
    </section>
    <section id="sec-Input-Values">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Input-Values">2.8</a></span>Input Values</h3>
      <p>Field and directive arguments accept input values. Input values can be specified as a variable or represented inline as literals. Input values can be scalars, enumerations, or input objects. List and inputs objects may also contain variables.</p>
      <p><strong>Int</strong></p>
      <p>Int is a number specified without a decimal point (ex. <code>1</code>).</p>
      <p><strong>Float</strong></p>
      <p>A Float numbers always includes a decimal point (ex. <code>1.0</code>) and may optionally also include an exponent (ex. <code>6.0221413e23</code>).</p>
      <p><strong>Boolean</strong></p>
      <p>The two keywords <code>true</code> and <code>false</code> represent the two boolean values.</p>
      <p><strong>String</strong></p>
      <p>Strings are lists of characters wrapped in double&#8208;quotes <code>&quot;</code>. (ex. <code>&quot;Hello World&quot;</code>). Whitespace is significant within a string.</p>
      <p><strong>Enum Value</strong></p>
      <p>Enum values are represented as unquoted names (ex. <code>MOBILE_WEB</code>). It is recommended that Enum values be &ldquo;all caps&rdquo;. Enum values are only used in contexts where the precise enumeration type is known. Therefore it&rsquo;s not
        necessary to use the enumeration type name in the literal.</p>
      <p><strong>List</strong></p>
      <p>Lists are an ordered sequence of values wrapped in square&#8208;brackets <code>[ ]</code>. The values of an Array literal may be any value literal or variable (ex. <code>[1, 2, 3]</code>).</p>
      <p>Commas are optional throughout GraphQL so trailing commas are allowed and repeated commas do not represent missing values.</p>
      <p><strong>Input Object</strong></p>
      <p>Input object literals are unordered lists of keyed input values wrapped in curly&#8208;braces <code>{ }</code>. The values of an object literal may be any input value literal or variable (ex. <code>{ name: &quot;Hello world&quot;, score: 1.0 }</code>).
        We refer to literal representation of input objects as &ldquo;object literals.&rdquo;</p>
    </section>
    <section id="sec-Language.Variables">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Variables">2.9</a></span>Variables</h3>
      <p>A GraphQL query can be parameterized with variables, maximizing query reuse, and avoiding costly string building in clients at runtime.</p>
      <p>Variables must be defined at the top of an operation and have global scope.</p>
      <p>In this example, we want to fetch a profile picture size based on the size of a particular device:</p><pre><code>query getZuckProfile($devicePicSize: Int) {
  user(id: 4) {
    id,
    name,
    profilePic(size: $devicePicSize)
  }
}
</code></pre>
      <p>Values for those variables are provided along with a GraphQL query, so they may be substituted during execution. If providing JSON for the variables values, we could run this query and request profilePic of size 60 width:</p><pre><code>{
  <span class="hljs-string">"devicePicSize"</span>: <span class="hljs-number">60</span>
}
</code></pre></section>
    <section id="sec-Language.Fragments">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Fragments">2.10</a></span>Fragments</h3>
      <p>Fragments allow for reuse of repeated portions of a query. It is the unit of composition in GraphQL.</p>
      <p>For example, if we wanted to fetch some common information about mutual friends as well as friends of some user:</p><pre><code>query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id,
      name,
      profilePic(size: 50)
    },
    mutualFriends(first: 10) {
      id,
      name,
      profilePic(size: 50)
    }
  }
}
</code></pre>
      <p>The repeated fields could be extracted into a fragment and composed by a parent fragment or query.</p><pre><code>query withFragments {
  user(id: 4) {
    friends(first: 10) { ...friendFields },
    mutualFriends(first: 10) { ...friendFields }
  }
}

fragment friendFields on User {
  id,
  name,
  profilePic(size: 50)
}
</code></pre>
      <p>Fragments are consumed by using the spread operator (<code>...</code>). All fields selected by the fragment will be added to the query field selection at the same level as the fragment invocation. This happens through multiple levels of fragment
        spreads.</p>
      <p>For example:</p><pre><code>query withNestedFragments
{
  user(id: 4) {
    friends(first: 10) { ...friendFields },
    mutualFriends(first: 10) { ...friendFields }
  }
}

fragment friendFields on User {
  id,
  name,
  ...standardProfilePic
}

fragment standardProfilePic on User {
  profilePic(size: 50)
}
</code></pre>
      <p>The queries <code>noFragments</code>, <code>withFragments</code>, and <code>withNestedFragments</code> all produce the same response object.</p>
      <section id="sec-Types-on-fragments">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Types-on-fragments">2.10.1</a></span>Types on fragments</h4>
        <p>Fragments must specify the type they apply to. In this example, <code>friendFields</code> can be used in the context of querying a <code>User</code>.</p>
        <p>Fragments cannot be specified on any input value (scalar, enumeration, or input object).</p>
        <p>Fragments can be specified on object types, interfaces, and unions.</p>
        <p>Selections within fragments only return values when concrete type of the object it is operating on matches the type of the fragment.</p>
        <p>For example in this query on the Facebook data model:</p><pre><code>query FragmentTyping {
  profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) {
    handle,
    ...userFragment,
    ...pageFragment
  }
}

fragment userFragment on User {
  friends { count }
}

fragment pageFragment on Page {
  likers { count }
}
</code></pre>
        <p>The <code>profiles</code> root field returns a list where each element could be a <code>Page</code> or a <code>User</code>. When the object in the <code>profiles</code> result is a <code>User</code>, <code>friends</code> will be present and <code>likers</code>          will not. Conversely when the result is a <code>Page</code>, <code>likers</code> will be present and <code>friends</code> will not.</p><pre><code>{
  <span class="hljs-string">"profiles"</span> : [
    {
      <span class="hljs-string">"handle"</span> : <span class="hljs-string">"zuck"</span>,
      <span class="hljs-string">"friends"</span> : { <span class="hljs-string">"count"</span> : <span class="hljs-number">1234</span> }
    },
    {
      <span class="hljs-string">"handle"</span> : <span class="hljs-string">"cocacola"</span>,
      <span class="hljs-string">"likers"</span> : { <span class="hljs-string">"count"</span> : <span class="hljs-number">90234512</span> }
    }
  ]
}
</code></pre></section>
      <section id="sec-Query-variables-in-fragments">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Query-variables-in-fragments">2.10.2</a></span>Query variables in fragments</h4>
        <p>Query variables can be used within fragments. Query variables have global scope with a given operation, so a variable used within a fragment must be declared in any top&#8208;level operation that transitively consumes that fragment. If a variable
          is referenced in a fragment and is included by an operation that does not define that variable, the operation cannot be executed.</p>
      </section>
      <section id="sec-Inline-fragments">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Inline-fragments">2.10.3</a></span>Inline fragments</h4>
        <p>Fragments can be defined inline to query. This is done to conditionally execute fields based on their runtime type. This feature of standard fragment inclusion was demonstrated in the <code>query FragmentTyping</code> example. We could accomplish
          the same thing using inline fragments.</p><pre><code>query InlineFragmentTyping {
  profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) {
    handle,
    ... on User {
      friends { count }
    },
    ... on Page {
      likers { count }
    }
  }
}
</code></pre></section>
    </section>
    <section id="sec-Language.Directives">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Language.Directives">2.11</a></span>Directives</h3>
      <p>In some cases, you need to provide options to alter GraphQL&rsquo;s execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to
        the executor.</p>
      <p>Directives have a name along with a list of arguments which may accept values of any input type.</p>
      <p>Directives can be used to describe additional information for fields, fragments, and operations.</p>
      <p>As future versions of GraphQL adopts new configurable execution capabilities, they may be exposed via directives.</p>
      <section id="sec-Fragment-Directives">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-Directives">2.11.1</a></span>Fragment Directives</h4>
        <p>Fragments may include directives to alter their behavior. At runtime, the directives provided on a fragment spread override those described on the definition.</p>
        <p>For example, the following query:</p><pre><code>query HasConditionalFragment($condition: Boolean) {
  ...MaybeFragment @include(if: $condition)
}

fragment MaybeFragment on Query {
  me {
    name
  }
}
</code></pre>
        <p>Will have identical runtime behavior as</p><pre><code>query HasConditionalFragment($condition: Boolean) {
  ...MaybeFragment
}

fragment MaybeFragment on Query @include(if: $condition) {
  me {
    name
  }
}
</code></pre>
        <div class="spec-algo" id="FragmentSpreadDirectives()"><span class="spec-call"><a href="#FragmentSpreadDirectives()">FragmentSpreadDirectives</a>(<var>fragmentSpread</var>)</span>
          <ol>
            <li>Let <var>directives</var> be the set of directives on <var>fragmentSpread</var></li>
            <li>Let <var>fragmentDefinition</var> be the FragmentDefinition in the document named <var>fragmentSpread</var> refers to.</li>
            <li>For each <var>directive</var> in directives on <var>fragmentDefinition</var>
              <ol>
                <li>If <var>directives</var> does not contain a directive named <var>directive</var>.</li>
                <li>Add <var>directive</var> into <var>directives</var></li>
              </ol>
            </li>
            <li>Return <var>directives</var> </li>
          </ol>
        </div>
      </section>
    </section>
  </section>
  <section id="sec-Type-System">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Type-System">3</a></span>Type System</h2>
    <p>The GraphQL Type system describes the capabilities of a GraphQL server and is used to determine if a query is valid. The type system also describes the input types of query variables to determine if values provided at runtime are valid.</p>
    <p>A GraphQL server&rsquo;s capabilities are referred to as that server&rsquo;s &ldquo;schema&rdquo;. A schema is defined in terms of the types and directives it supports.</p>
    <p>A given GraphQL schema must itself be internally valid. This section describes the rules for this validation process where relevant.</p>
    <p>A GraphQL schema is represented by a root type for each kind of operation: query and mutation; this determines the place in the type system where those operations begin.</p>
    <p>All types within a GraphQL schema must have unique names. No two provided types may have the same name. No provided type may have a name which conflicts with any built in types (including Scalar and Introspection types).</p>
    <p>All directives within a GraphQL schema must have unique names. A directive and a type may share the same name, since there is no ambiguity between them.</p>
    <section id="sec-Type-System.Types">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Type-System.Types">3.1</a></span>Types</h3>
      <p>The fundamental unit of any GraphQL Schema is the type. There are eight kinds of types in GraphQL.</p>
      <p>The most basic type is a <code>Scalar</code>. A scalar represents a primitive value, like a string or an integer. Oftentimes, the possible responses for a scalar field are enumerable. GraphQL offers an <code>Enum</code> type in those cases, where
        the type specifies the space of valid responses.</p>
      <p>Scalars and Enums form the leaves in response trees; the intermediate levels are <code>Object</code> types, which define a set of fields, where each field is another type in the system, allowing the definition of arbitrary type hierarchies.</p>
      <p>GraphQL supports two abstract types: interfaces and unions.</p>
      <p>An <code>Interface</code> defines a list of fields; <code>Object</code> types that implement that interface are guaranteed to implement those fields. Whenever the type system claims it will return an interface, it will return a valid implementing
        type.</p>
      <p>A <code>Union</code> defines a list of possible types; similar to interfaces, whenever the type system claims a union will be returned, one of the possible types will be returned.</p>
      <p>All of the types so far are assumed to be both nullable and singular: e.g. a scalar string returns either null or a singular string. The type system might want to define that it returns a list of other types; the <code>List</code> type is provided
        for this reason, and wraps another type. Similarly, the <code>Non-Null</code> type wraps another type, and denotes that the result will never be null. These two types are referred to as &ldquo;wrapping types&rdquo;; non&#8208;wrapping types are
        referred to as &ldquo;base types&rdquo;. A wrapping type has an underlying &ldquo;base type&rdquo;, found by continually unwrapping the type until a base type is found.</p>
      <p>Finally, oftentimes it is useful to provide complex structs as inputs to GraphQL queries; the <code>Input Object</code> type allows the schema to define exactly what data is expected from the client in these queries.</p>
      <section id="sec-Scalars">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Scalars">3.1.1</a></span>Scalars</h4>
        <p>As expected by the name, a scalar represents a primitive value in GraphQL. GraphQL responses take the form of a hierarchical tree; the leaves on these trees are GraphQL scalars.</p>
        <p>All GraphQL scalars are representable as strings, though depending on the response format being used, there may be a more appropriate primitive for the given scalar type, and server should use those types when appropriate.</p>
        <p>GraphQL provides a number of built&#8208;in scalars, but type systems can add additional scalars with semantic meaning. For example, a GraphQL system could define a scalar called <code>Time</code> which, while serialized as a string, promises
          to conform to ISO&#8208;8601. When querying a field of type <code>Time</code>, you can then rely on the ability to parse the result with an ISO&#8208;8601 parser and use a client&#8208;specific primitive for time. Another example of a potentially
          useful custom scalar is <code>Url</code>, which serializes as a string, but is guaranteed by the server to be a valid URL.</p>
        <p><strong>Result Coercion</strong></p>
        <p>A GraphQL server, when preparing a field of a given scalar type, must uphold the contract the scalar type describes, either by coercing the value or producing an error.</p>
        <p>For example, a GraphQL server could be preparing a field with the scalar type <code>Int</code> and encounter a floating&#8208;point number. Since the server must not break the contract by yielding a non&#8208;integer, the server should truncate
          the fractional value and only yield the integer value. If the server encountered a boolean <code>true</code> value, it should return <code>1</code>. If the server encountered a string, it may attempt to parse the string for a base&#8208;10 integer
          value. If the server encounters some value that cannot be reasonably coerced to an <code>Int</code>, then it must raise a field error.</p>
        <p>Since this coercion behavior is not observable to clients of the GraphQL server, the precise rules of coercion are left to the implementation. The only requirement is that the server must yield values which adhere to the expected Scalar type.</p>
        <p><strong>Input Coercion</strong></p>
        <p>If a GraphQL server expects a scalar type as input to an argument, coercion is observable and the rules must be well defined. If an input value does not match a coercion rule, a query error must be raised.</p>
        <p>GraphQL has different constant literals to represent integer and floating&#8208;point input values, and coercion rules may apply differently depending on which type of input value is encountered. GraphQL may be parameterized by query variables,
          the values of which are often serialized when sent over a transport like HTTP. Since some common serializations (ex. JSON) do not discriminate between integer and floating&#8208;point values, they are interpreted as an integer input value if
          they have an empty fractional part (ex. <code>1.0</code>) and otherwise as floating&#8208;point input value.</p>
        <section id="sec-Built-in-Scalars">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Built-in-Scalars">3.1.1.1</a></span>Built-in Scalars</h5>
          <p>GraphQL provides a basic set of well&#8208;defined Scalar types. A GraphQL server should support all of these types, and a GraphQL server which provide a type by these names must adhere to the behavior described below.</p>
          <section id="sec-Int">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Int">3.1.1.1.1</a></span>Int</h6>
            <p>The Int scalar type represents a signed 32&#8208;bit numeric non&#8208;fractional values. Response formats that support a 32&#8208;bit integer or a number type should use that type to represent this scalar.</p>
            <p><strong>Result Coercion</strong></p>
            <p>GraphQL servers should coerce non&#8208;int raw values to Int when possible otherwise they must raise a field error. Examples of this may include returning <code>1</code> for the floating&#8208;point number <code>1.0</code>, or <code>2</code>              for the string <code>&quot;2&quot;</code>.</p>
            <p><strong>Input Coercion</strong></p>
            <p>When expected as an input type, only integer input values are accepted. All other input values, including strings with numeric content, must raise a query error indicating an incorrect type. If the integer input value represents a value less
              than -2<sup>31</sup> or greater than or equal to 2<sup>31</sup>, a query error should be raised.</p>
            <div class="spec-note">Numeric integer values larger than 32&#8208;bit should either use String or a custom&#8208;defined Scalar type, as not all platforms and transports support encoding integer numbers larger than 32&#8208;bit.</div>
          </section>
          <section id="sec-Float">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Float">3.1.1.1.2</a></span>Float</h6>
            <p>The Float scalar type represents signed double&#8208;precision fractional values as specified by <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>. Response formats that support an appropriate double&#8208;precision number
              type should use that type to represent this scalar.</p>
            <p><strong>Result Coercion</strong></p>
            <p>GraphQL servers should coerce non&#8208;floating&#8208;point raw values to Float when possible otherwise they must raise a field error. Examples of this may include returning <code>1.0</code> for the integer number <code>1</code>, or <code>2.0</code>              for the string <code>&quot;2&quot;</code>.</p>
            <p><strong>Input Coercion</strong></p>
            <p>When expected as an input type, both integer and float input values are accepted. Integer input values are coerced to Float by adding an empty fractional part, for example <code>1.0</code> for the integer input value <code>1</code>. All other
              input values, including strings with numeric content, must raise a query error indicating an incorrect type. If the integer input value represents a value not representable by IEEE 754, a query error should be raised.</p>
          </section>
          <section id="sec-String">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-String">3.1.1.1.3</a></span>String</h6>
            <p>The String scalar type represents textual data, represented as UTF&#8208;8 character sequences. The String type is most often used by GraphQL to represent free&#8208;form human&#8208;readable text. All response formats must support string
              representations, and that representation must be used here.</p>
            <p><strong>Result Coercion</strong></p>
            <p>GraphQL servers should coerce non&#8208;string raw values to String when possible otherwise they must raise a field error. Examples of this may include returning the string <code>&quot;true&quot;</code> for a boolean true value, or the string
              <code>&quot;1&quot;</code> for the integer <code>1</code>.</p>
            <p><strong>Input Coercion</strong></p>
            <p>When expected as an input type, only valid UTF&#8208;8 string input values are accepted. All other input values must raise a query error indicating an incorrect type.</p>
          </section>
          <section id="sec-Boolean">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Boolean">3.1.1.1.4</a></span>Boolean</h6>
            <p>The Boolean scalar type represents <code>true</code> or <code>false</code>. Response formats should use a built&#8208;in boolean type if supported; otherwise, they should use their representation of the integers <code>1</code> and <code>0</code>.</p>
            <p><strong>Result Coercion</strong></p>
            <p>GraphQL servers should coerce non&#8208;boolean raw values to Boolean when possible otherwise they must raise a field error. Examples of this may include returning <code>true</code> for any non&#8208;zero number.</p>
            <p><strong>Input Coercion</strong></p>
            <p>When expected as an input type, only boolean input values are accepted. All other input values must raise a query error indicating an incorrect type.</p>
          </section>
          <section id="sec-ID">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-ID">3.1.1.1.5</a></span>ID</h6>
            <p>The ID scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type is serialized in the same way as a <code>String</code>; however, it is not intended to be human&#8208;readable. While it
              is often numeric, it should always serialize as a <code>String</code>.</p>
            <p><strong>Result Coercion</strong></p>
            <p>GraphQL is agnostic to ID format, and serializes to string to ensure consistency across many formats ID could represent, from small auto&#8208;increment numbers, to large 128&#8208;bit random numbers, to base64 encoded values, or string values
              of a format like <a href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a>.</p>
            <p>GraphQL servers should coerce as appropriate given the ID formats they expect, when coercion is not possible they must raise a field error.</p>
            <p><strong>Input Coercion</strong></p>
            <p>When expected as an input type, any string (such as <code>&quot;4&quot;</code>) or integer (such as <code>4</code>) input value should be coerced to ID as appropriate for the ID formats a given GraphQL server expects. Any other input value,
              including float input values (such as <code>4.0</code>), must raise a query error indicating an incorrect type.</p>
          </section>
        </section>
      </section>
      <section id="sec-Objects">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Objects">3.1.2</a></span>Objects</h4>
        <p>GraphQL queries are hierarchical and composed, describing a tree of information. While Scalar types describe the leaf values of these hierarchical queries, Objects describe the intermediate levels.</p>
        <p>GraphQL Objects represent a list of named fields, each of which yield a value of a specific type. Object values are serialized as unordered maps, where the queried field names (or aliases) are the keys and the result of evaluating the field is
          the value.</p>
        <p>For example, a type <code>Person</code> could be described as:</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
}
</code></pre>
        <p>Where <code>name</code> is a field that will yield a <code>String</code> value, and <code>age</code> is a field that will yield an <code>Int</code> value, and <code>picture</code> a field that will yield a <code>Url</code> value.</p>
        <p>A query of an object value must select at least one field. This selection of fields will yield an unordered map containing exactly the subset of the object queried. Only fields that are declared on the object type may validly be queried on that
          object.</p>
        <p>For example, selecting all the fields of <code>Person</code>:</p><pre><code>{
  name,
  age,
  picture
}
</code></pre>
        <p>Would yield the object:</p><pre><code>{
  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,
  &quot;age&quot;: 30,
  &quot;picture&quot;: &quot;http://some.cdn/picture.jpg&quot;
}
</code></pre>
        <p>While selecting a subset of fields:</p><pre><code>{
  name,
  age
}
</code></pre>
        <p>Must only yield exactly that subset:</p><pre><code>{
  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,
  &quot;age&quot;: 30
}
</code></pre>
        <p>A field of an Object type may be a Scalar, Enum, another Object type, an Interface, or a Union. Additionally, it may be any wrapping type whose underlying base type is one of those five.</p>
        <p>For example, the <code>Person</code> type might include a <code>relationship</code>:</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
  relationship: Person
}
</code></pre>
        <p>Valid queries must supply a nested field set for a field that returns an object, so this query is not valid:</p><pre class="spec-counter-example"><code>{
  name,
  relationship
}
</code></pre>
        <p>However, this example is valid:</p><pre><code>{
  name,
  relationship {
    name
  }
}
</code></pre>
        <p>And will yield the subset of each object type queried:</p><pre><code>{
  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,
  &quot;relationship&quot;: {
    &quot;name&quot;: &quot;Priscilla Chan&quot;
  }
}
</code></pre>
        <p><strong>Result Coercion</strong></p>
        <p>Determining the result of coercing an object is the heart of the GraphQL executor, so this is covered in that section of the spec.</p>
        <p><strong>Input Coercion</strong></p>
        <p>Objects are never valid inputs.</p>
        <section id="sec-Object-Field-Arguments">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Object-Field-Arguments">3.1.2.1</a></span>Object Field Arguments</h5>
          <p>Object fields are conceptually functions which yield values. Occasionally object fields can accept arguments to further specify the return value. Object field arguments are defined as a list of all possible argument names and their expected
            input types.</p>
          <p>For example, a <code>Person</code> type with a <code>picture</code> field could accept an argument to determine what size of an image to return.</p><pre><code>type Person {
  name: String
  picture(size: Int): Url
}
</code></pre>
          <p>GraphQL queries can optionally specify arguments to their fields to provide these arguments.</p>
          <p>This example query:</p><pre><code>{
  name,
  picture(size: 600)
}
</code></pre>
          <p>May yield the result:</p><pre><code>{
  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,
  &quot;picture&quot;: &quot;http://some.cdn/picture_600.jpg&quot;
}
</code></pre>
          <p>The type of an object field argument can be any Input type.</p>
        </section>
        <section id="sec-Object-Field-deprecation">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Object-Field-deprecation">3.1.2.2</a></span>Object Field deprecation</h5>
          <p>Fields in an object may be marked as deprecated as deemed necessary by the application. It is still legal to query for these fields (to ensure existing clients are not broken by the change), but the fields should be appropriately treated in
            documentation and tooling.</p>
        </section>
        <section id="sec-Object-type-validation">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Object-type-validation">3.1.2.3</a></span>Object type validation</h5>
          <p>Object types have the potential to be invalid if incorrectly defined. This set of rules must be adhered to by every Object type in a GraphQL schema.</p>
          <ol>
            <li>The fields of an Object type must have unique names within that Object type; no two fields may share the same name.</li>
            <li>An object type must be a super&#8208;set of all interfaces it implements.
              <ol>
                <li>The object type must include a field of the same name for every field defined in an interface.
                  <ol>
                    <li>The object field must include an argument of the same name for every argument defined by the interface field.
                      <ol>
                        <li>The object field argument must accept the same type (invariant) as the interface field argument.</li>
                      </ol>
                    </li>
                    <li>The object field must be of a type which is equal to the interface field.</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </section>
      </section>
      <section id="sec-Interfaces">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Interfaces">3.1.3</a></span>Interfaces</h4>
        <p>GraphQL Interfaces represent a list of named fields and their arguments. GraphQL object can then implement an interface, which guarantees that they will contain the specified fields.</p>
        <p>Fields on a GraphQL interface have the same rules as fields on a GraphQL object; their type can be Scalar, Object, Enum, Interface, or Union, or any wrapping type whose base type is one of those five.</p>
        <p>For example, an interface may describe a required field and types such as <code>Person</code> or <code>Business</code> may then implement this interface.</p><pre><code>interface NamedEntity {
  name: String
}

type Person : NamedEntity {
  name: String
  age: Int
}

type Business : NamedEntity {
  name: String
  employeeCount: Int
}
</code></pre>
        <p>Fields which yield an interface are useful when one of many Object types are expected, but some fields should be guaranteed.</p>
        <p>To continue the example, a <code>Contact</code> might refer to <code>NamedEntity</code>.</p><pre><code>type Contact {
  entity: NamedEntity
  phoneNumber: String
  address: String
}
</code></pre>
        <p>This allows us to write a query for a <code>Contact</code> that can select the common fields.</p><pre><code>{
  entity {
    name
  },
  phoneNumber
}
</code></pre>
        <p>When querying for fields on an interface type, only those fields declared on the interface may be queried. In the above example, <code>entity</code> returns a <code>NamedEntity</code>, and <code>name</code> is defined on <code>NamedEntity</code>,
          so it is valid. However, the following would not be a valid query:</p><pre class="spec-counter-example"><code>{
  entity {
    name,
    age
  },
  phoneNumber
}
</code></pre>
        <p>because <code>entity</code> refers to a <code>NamedEntity</code>, and <code>age</code> is not defined on that interface. Querying for <code>age</code> is only valid when the result of <code>entity</code> is a <code>Person</code>; the query can
          express this using a fragment or an inline fragment:</p><pre><code>{
  entity {
    name,
    ... on Person {
      age
    }
  },
  phoneNumber
}
</code></pre>
        <p><strong>Result Coercion</strong></p>
        <p>The interface type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the interface is the same as the result coercion of the object.</p>
        <p><strong>Input Coercion</strong></p>
        <p>Interfaces are never valid inputs.</p>
        <section id="sec-Interface-type-validation">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Interface-type-validation">3.1.3.1</a></span>Interface type validation</h5>
          <p>Interface types have the potential to be invalid if incorrectly defined.</p>
          <ol>
            <li>The fields of an Interface type must have unique names within that Interface type; no two fields may share the same name.</li>
          </ol>
        </section>
      </section>
      <section id="sec-Unions">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Unions">3.1.4</a></span>Unions</h4>
        <p>GraphQL Unions represent an object that could be one of a list of GraphQL Object types, but provides for no guaranteed fields between those types. They also differ from interfaces in that Object types declare what interfaces they implement, but
          are not aware of what unions contain them.</p>
        <p>With interfaces and objects, only those fields defined on the type can be queried directly; to query other fields on an interface, typed fragments must be used. This is the same as for unions, but unions do not define any fields, so <strong>no</strong>          fields may be queried on this type without the use of typed fragments.</p>
        <p>For example, we might have the following type system:</p><pre><code>Union SearchResult = Photo | Person

type Person {
  name: String
  age: Int
}

type Photo {
  height: Int
  width: Int
}

type SearchQuery {
  firstSearchResult: SearchResult
}
</code></pre>
        <p>When querying the <code>firstSearchResult</code> field of type <code>SearchQuery</code>, the query would ask for all fields inside of a fragment indicating the appropriate type. If the query wanted the name if the result was a Person, and the
          height if it was a photo, the following query is invalid, because the union itself defines no fields:</p><pre class="spec-counter-example"><code>{
  firstSearchResult {
    name
    height
  }
}
</code></pre>
        <p>Instead, the query would be:</p><pre><code>{
  firstSearchResult {
    ... on Person {
      name
    }
    ... on Photo {
      height
    }
  }
}
</code></pre>
        <p><strong>Result Coercion</strong></p>
        <p>The union type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the union is the same as the result coercion of the object.</p>
        <p><strong>Input Coercion</strong></p>
        <p>Unions are never valid inputs.</p>
        <section id="sec-Union-type-validation">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Union-type-validation">3.1.4.1</a></span>Union type validation</h5>
          <p>Union types have the potential to be invalid if incorrectly defined.</p>
          <ol>
            <li>The member types of an Union type must all be Object base types; Scalar, Interface and Union types may not be member types of a Union. Similarly, wrapping types may not be member types of a Union.</li>
            <li>A Union type must define two or more member types.</li>
          </ol>
          <p>When expected as an input type, array input values are accepted only when each item in the input array can be accepted by the item type. If the input value is not an array but can be accepted by the item type, it is coerced by creating an array
            with the input value as the sole item. Other input values must raise a query error indicating an incorrect type.</p>
        </section>
      </section>
      <section id="sec-Enums">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Enums">3.1.5</a></span>Enums</h4>
        <p>GraphQL Enums are a variant on the Scalar type, which represents one of a finite set of possible values.</p>
        <p>GraphQL Enums are not references for a numeric value, but are unique values in their own right. They serialize as a string: the name of the represented value.</p>
        <p><strong>Result Coercion</strong></p>
        <p>GraphQL servers must return one of the defined set of possible values, if a reasonable coercion is not possible they must raise a field error.</p>
        <p><strong>Input Coercion</strong></p>
        <p>GraphQL has a constant literal to represent enum input values. GraphQL string literals must not be accepted as an enum input and instead raise a query error.</p>
        <p>Query variable transport serializations which have a different representation for non&#8208;string symbolic values (for example, <a href="https://github.com/edn-format/edn">EDN</a>) should only allow such values as enum input values. Otherwise,
          for most transport serializations that do not, strings may be interpreted as the enum input value with the same name.</p>
      </section>
      <section id="sec-Input-Objects">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Input-Objects">3.1.6</a></span>Input Objects</h4>
        <p>Fields can define arguments that the client passes up with the query, to configure their behavior. These inputs can be Strings or Enums, but they sometimes need to be more complex than this.</p>
        <p>The <code>Object</code> type defined above is inappropriate for re&#8208;use here, because <code>Object</code>s can contain fields that express circular references or references to interfaces and unions, neither of which is appropriate for use
          as an input argument. For this reason, input objects have a separate type in the system.</p>
        <p>An <code>Input Object</code> defines a set of input fields; the input fields are either scalars, enums, or other input objects. This allows arguments to accept arbitrarily complex structs.</p>
        <p><strong>Result Coercion</strong></p>
        <p>An input object is never a valid result.</p>
        <p><strong>Input Coercion</strong></p>
        <p>The input to an input object should be an unordered map, otherwise an error should be thrown. The result of the coercion is an unordered map, with an entry for each input field, whose key is the name of the input field. The value of an entry in
          the coerced map is the result of input coercing the value of the entry in the input with the same key; if the input does not have a corresponding entry, the value is the result of coercing null. The input coercion above should be performed according
          to the input coercion rules of the type declared by the input field.</p>
      </section>
      <section id="sec-Lists">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Lists">3.1.7</a></span>Lists</h4>
        <p>A GraphQL list is a special collection type which declares the type of each item in the List (referred to as the <em>item type</em> of the list). List values are serialized as ordered lists, where each item in the array is serialized as per the
          item type.</p>
        <p><strong>Result Coercion</strong></p>
        <p>GraphQL servers must return an ordered list as the result of a list type. Each item in the list must be the result of a result coercion of the item type. If a reasonable coercion is not possible they must raise a field error. In particular, if
          a non&#8208;list is returned, the coercion should fail, as this indicates a mismatch in expectations between the type system and the implementation.</p>
        <p><strong>Input Coercion</strong></p>
        <p>When accepted as an input, each item in the list should be coerced as per the input coercion of the item type.</p>
        <p>If the value passed as an input to a list type is <em>not</em> as list, it should be coerced as though the input was a list of size one, where the value passed is the only item in the list. This is to allow inputs that accept a &ldquo;var args&rdquo;
          to declare their input type as a list; if only one argument is passed (a common case), the client can just pass that value rather than constructing the list.</p>
      </section>
      <section id="sec-Non-Null">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Non-Null">3.1.8</a></span>Non-Null</h4>
        <p>By default, all types in GraphQL are nullable; the <span class="spec-keyword">null</span> value is a valid response for all of the above types. To declare a type that disallows null, the GraphQL Non&#8208;Null type can be used. This type declares
          an underlying type, and this type acts identically to that underlying type, with the exception that <code>null</code> is not a valid response for the wrapping type.</p>
        <p><strong>Result Coercion</strong></p>
        <p>In all of the above result coercion, <code>null</code> was considered a valid value. To coerce the result of a Non Null type, the result coercion of the underlying type should be performed. If that result was not <code>null</code>, then the result
          of coercing the Non Null type is that result. If that result was <code>null</code>, then an error should be raised.</p>
        <p><strong>Input Coercion</strong></p>
        <div class="spec-note">that <code>null</code> is not a valid keyword in GraphQL, so a query cannot look like:</div><pre class="spec-counter-example"><code>{
  field(arg: null)
}
</code></pre>
        <p>to indicate that the argument is null. Instead, an argument would be null only if it is passed a variable that is then not set:</p><pre><code>{
  field(arg: $var)
}
</code></pre>
        <p>Hence, if the value for a non&#8208;null is hard&#8208;coded in the query, it is always coerced using the input coercion for the wrapped type.</p>
        <p>When a non&#8208;null input has its value set using a variable, the coerced value should be <code>null</code> if the provided value is <code>null</code>-like in the provided representation, or if the provided value is omitted. Otherwise, the coerced
          value is the result of running the wrapped type&rsquo;s input coercion on the provided value.</p>
      </section>
    </section>
    <section id="sec-Type-System.Directives">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Type-System.Directives">3.2</a></span>Directives</h3>
      <p>A GraphQL schema includes a list of the directives the execution engine supports.</p>
      <p>GraphQL implementations should provide the <code>@skip</code> and <code>@include</code> directives.</p>
      <section id="sec--skip">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec--skip">3.2.1</a></span>@skip</h4>
        <p>The <code>@skip</code> directive may be provided for fields or fragments, and allows for conditional exclusion during execution as described by the if argument.</p>
        <p>In this example <code>experimentalField</code> will be queried only if the <code>$someTest</code> is provided a <code>false</code> value.</p><pre><code>query myQuery($someTest: Boolean) {
  experimentalField @skip(if: $someTest)
}
</code></pre></section>
      <section id="sec--include">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec--include">3.2.2</a></span>@include</h4>
        <p>The <code>@include</code> directive may be provided for fields or fragments, and allows for conditional inclusion during execution as described by the if argument.</p>
        <p>In this example <code>experimentalField</code> will be queried only if the <code>$someTest</code> is provided a <code>true</code> value.</p><pre><code>query myQuery($someTest: Boolean) {
  experimentalField @include(if: $someTest)
}
</code></pre>
        <p>The <code>@skip</code> directive has precedence over the <code>@include</code> directive should both be provided in the same context.</p>
      </section>
    </section>
    <section id="sec-Starting-types">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Starting-types">3.3</a></span>Starting types</h3>
      <p>A GraphQL schema includes types, indicating where query and mutation operations start. This provides the initial entry points into the type system. The query type must always be provided, and is an Object base type. The mutation type is optional;
        if it is null, that means the system does not support mutations. If it is provided, it must be an object base type.</p>
      <p>The fields on the query type indicate what fields are available at the top level of a GraphQL query. For example, a basic GraphQL query like this one:</p><pre><code>query getMe {
  me
}
</code></pre>
      <p>Is valid when the type provided for the query starting type has a field named &ldquo;me&rdquo;. Similarly</p><pre><code>mutation setName {
  setName(name: &quot;Zuck&quot;) {
    newName
  }
}
</code></pre>
      <p>Is valid when the type provided for the mutation starting type is not null, and has a field named &ldquo;setName&rdquo; with a string argument named &ldquo;name&rdquo;. </p>
    </section>
  </section>
  <section id="sec-Introspection">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Introspection">4</a></span>Introspection</h2>
    <p>A GraphQL server supports introspection over its schema. This schema is queried using GraphQL itself, creating a powerful platform for tool&#8208;building.</p>
    <p>Take an example query for a trivial app. In this case there is a User type with three fields: id, user, and birthday.</p>
    <p>For example, given a server with the following type definition:</p><pre><code>type User {
  id: String
  name: String
  birthday: Date
}
</code></pre>
    <p>The query</p><pre><code>{
  __type(name: &quot;User&quot;) {
    name,
    fields {
      name,
      type { name }
    }
  }
}
</code></pre>
    <p>would return</p><pre><code>{
  &quot;__type&quot;: {
    &quot;name&quot; : &quot;User&quot;,
    &quot;fields&quot;: [
      { &quot;name&quot;: &quot;id&quot;, &quot;type&quot;: { &quot;name&quot;: &quot;String&quot; } },
      { &quot;name&quot;: &quot;name&quot;, &quot;type&quot;: { &quot;name&quot;: &quot;String&quot; } },
      { &quot;name&quot;: &quot;birthday&quot;, &quot;type&quot;: { &quot;name&quot;: &quot;Date&quot; } },
    ]
  }
}
</code></pre>
    <section id="sec-General-Principles">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-General-Principles">4.1</a></span>General Principles</h3>
      <section id="sec-Naming-conventions">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Naming-conventions">4.1.1</a></span>Naming conventions</h4>
        <p>Types and fields required by the GraphQL introspection system that are used in the same context as user&#8208;defined type and fields are prefixed with two underscores. This in order to avoid naming collisions with user&#8208;defined GraphQL types.
          Conversely, GraphQL type system authors must not define any types, fields, arguments, or any other type system artifact with two leading underscores.</p>
      </section>
      <section id="sec-Documentation">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Documentation">4.1.2</a></span>Documentation</h4>
        <p>All types in the introspection system provide a <code>description</code> field of type <code>String</code> to allow type designers to publish documentation in addition to capabilities. A GraphQL server may return the <code>description</code> field
          using Markdown syntax. Therefore it is recommended that any tool that displays description use a Markdown renderer.</p>
      </section>
      <section id="sec-Deprecation">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Deprecation">4.1.3</a></span>Deprecation</h4>
        <p>To support the management of backwards compatibility, GraphQL fields and enum values can indicate whether or not they are deprecated (<code>isDeprecated: Boolean</code>) and a description of why it is deprecated (<code>deprecationReason: String</code>).</p>
        <p>Tools built using GraphQL introspection should respect deprecation by discouraging deprecated use through information hiding or developer&#8208;facing warnings.</p>
      </section>
      <section id="sec-Type-Name-Introspection">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Type-Name-Introspection">4.1.4</a></span>Type Name Introspection</h4>
        <p>GraphQL supports type name introspection at any point within a query by the meta field <code>__typename: String!</code> when querying against any Object, Interface, or Union. It returns the name of the object type currently being queried.</p>
        <p>This is most often used when querying against Interface or Union types to identify which actual type of the possible types has been returned.</p>
        <p>This field is implicit and does not appear in the fields list in any defined type.</p>
      </section>
    </section>
    <section id="sec-Schema-Introspection">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Schema-Introspection">4.2</a></span>Schema Introspection</h3>
      <p>The schema introspection system is accessible from the meta&#8208;fields <code>__schema</code> and <code>__type</code> which are accessible from the type of the root of a query operation.</p><pre><code>__schema : __Schema!
__type(name: String) : __Type
</code></pre>
      <p>These fields are implicit and do not appear in the fields list in the root type of the query operation.</p>
      <p>The schema of the GraphQL schema introspection system:</p><pre><code>type __Schema {
  types: [__Type!]!
  queryType: __Type!
  mutationType: __Type
  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!
  name: String
  description: String

  # OBJECT and INTERFACE only
  fields(includeDeprecated: Boolean = false): [__Field!]

  # OBJECT only
  interfaces: [__Type!]

  # INTERFACE and UNION only
  possibleTypes: [__Type!]

  # ENUM only
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  # INPUT_OBJECT only
  inputFields: [__InputValue!]

  # NON_NULL and LIST only
  ofType: __Type
}

type __Field {
  name: String!
  description: String
  args: [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

type __InputValue {
  name: String!
  description: String
  type: __Type!
  defaultValue: String
}

type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

type __Directive {
  name: String!
  description: String
  args: [__InputValue!]!
  onOperation: Boolean!
  onFragment: Boolean!
  onField: Boolean!
}

</code></pre>
      <section id="sec-The-__Type-Type">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-The-__Type-Type">4.2.1</a></span>The &quot;__Type&quot; Type</h4>
        <p><code>__Type</code> is at the core of the type introspection system. It represents scalars, interfaces, object types, unions, enums in the system.</p>
        <p><code>__Type</code> also represents type modifiers, which are used to modify a type that it refers to (<code>ofType: __Type</code>). This is how we represent lists, non&#8208;nullable types, and the combinations thereof.</p>
      </section>
      <section id="sec-Type-Kinds">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Type-Kinds">4.2.2</a></span>Type Kinds</h4>
        <p>There are several different kinds of type. In each kind, different fields are actually valid. These kinds are listed in the <code>__TypeKind</code> enumeration.</p>
        <section id="sec-Scalar">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Scalar">4.2.2.1</a></span>Scalar</h5>
          <p>Represents scalar types such as Int, String, and Boolean. Scalars cannot have fields.</p>
          <p>A GraphQL type designer should describe the data format and scalar coercion rules in the description field of any scalar.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.SCALAR</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Object">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Object">4.2.2.2</a></span>Object</h5>
          <p>Object types represent concrete instantiations of sets of fields. The introspection types (e.g. <code>__Type</code>, <code>__Field</code>, etc) are examples of objects.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.OBJECT</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li><code>fields</code>: The set of fields query&#8208;able on this type.
              <ul>
                <li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated fields are also returned.</li>
              </ul>
            </li>
            <li><code>interfaces</code>: The set of interfaces that an object implements.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Union">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Union">4.2.2.3</a></span>Union</h5>
          <p>Unions are an abstract types where no common fields are declared. The possible types of a union are explicitly listed out in <code>possibleTypes</code>. Types can be made parts of unions without modification of that type.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.UNION</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li><code>possibleTypes</code> returns the list of types that can be represented within this union. They must be object types.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Interface">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Interface">4.2.2.4</a></span>Interface</h5>
          <p>Interfaces is an abstract type where there are common fields declared. Any type that implements an interface must define all the fields with names and types exactly matching. The implementations of this interface are explicitly listed out in
            <code>possibleTypes</code>.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.INTERFACE</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li><code>fields</code>: The set of fields required by this interface.
              <ul>
                <li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated fields are also returned.</li>
              </ul>
            </li>
            <li><code>possibleTypes</code> returns the list of types that implement this interface. They must be object types.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Enum">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Enum">4.2.2.5</a></span>Enum</h5>
          <p>Enums are special scalars that can only have a defined set of values.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.ENUM</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li><code>enumValues</code>: The list of <code>EnumValue</code>. There must be at least one and they must have unique names.
              <ul>
                <li>Accepts the argument <code>includeDeprecated</code> which defaults to <span class="spec-keyword">false</span>. If <span class="spec-keyword">true</span>, deprecated enum values are also returned.</li>
              </ul>
            </li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Input-Object">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Input-Object">4.2.2.6</a></span>Input Object</h5>
          <p>Input objects are composite types used as inputs into queries defined as a list of named input values.</p>
          <p>For example the input object <code>Point</code> could be defined as:</p><pre><code>type Point {
  x: Int
  y: Int
}
</code></pre>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.INPUT_OBJECT</code>.</li>
            <li><code>name</code> must return a String.</li>
            <li><code>description</code> may return a String or <span class="spec-keyword">null</span>.</li>
            <li><code>inputFields</code>: a list of <code>InputValue</code>.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-List">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-List">4.2.2.7</a></span>List</h5>
          <p>Lists represent sequences of values in GraphQL. A List type is a type modifier: it wraps another type instance in the <code>ofType</code> field, which defines the type of each item in the list.</p>
          <p>Fields</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.LIST</code>.</li>
            <li><code>ofType</code>: Any type.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Non-null">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Non-null">4.2.2.8</a></span>Non-null</h5>
          <p>GraphQL types are nullable. The value <span class="spec-keyword">null</span> is a valid response for field type.</p>
          <p>A Non&#8208;null type is a type modifier: it wraps another type instance in the <code>ofType</code> field. Non&#8208;null types do not allow <span class="spec-keyword">null</span> as a response, and indicate required inputs for arguments and
            input object fields.</p>
          <ul>
            <li><code>kind</code> must return <code>__TypeKind.NON_NULL</code>.</li>
            <li><code>ofType</code>: Any type except Non&#8208;null.</li>
            <li>All other fields must return <span class="spec-keyword">null</span>.</li>
          </ul>
        </section>
        <section id="sec-Combining-List-and-Non-Null">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Combining-List-and-Non-Null">4.2.2.9</a></span>Combining List and Non-Null</h5>
          <p>List and Non&#8208;Null can compose, representing more complex types.</p>
          <p>If the modified type of a List is Non&#8208;Null, then that List may not contain any <span class="spec-keyword">null</span> items.</p>
          <p>If the modified type of a Non&#8208;Null is List, then <span class="spec-keyword">null</span> is not accepted, however an empty list is accepted.</p>
          <p>If the modified type of a List is a List, then each item in the first List is another List of the second List&rsquo;s type.</p>
          <p>A Non&#8208;Null type cannot modify another Non&#8208;Null type. </p>
        </section>
      </section>
    </section>
  </section>
  <section id="sec-Validation">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Validation">5</a></span>Validation</h2>
    <p>GraphQL does not just verify if a request is syntactically correct.</p>
    <p>Prior to execution, it can also verify that a request is valid within the context of a given GraphQL schema. Validation is primarily targeted at development&#8208;time tooling. Any client&#8208;side tooling should return errors and not allow the formulation
      of queries known to violate the type system at a given point in time.</p>
    <p>Total request validation on the server&#8208;side during execution is optional. As schemas and systems change over time existing clients may end up emitting queries that are no longer valid given the current type system. Servers (as described in the
      Execution section of this spec) attempt to satisfy as much as the request as possible and continue to execute in the presence of type system errors rather than cease execution completely.</p>
    <p>For this section of this schema, we will assume the following type system in order to demonstrate examples:</p><pre><code>
enum DogCommand { SIT, DOWN, HEEL }

type Dog : Pet {
  name: String!,
  nickname: String,
  barkVolume: Int,
  doesKnowCommand(dogCommand: DogCommand!) : Boolean!
  isHousetrained(atOtherHomes: Boolean): Boolean!
}

interface Sentient { name: String! }
interface Pet { name: String! }

type Alien : Sentient { name: String!, homePlanet: String }
type Human : Sentient { name: String! }

type Cat : Pet {
  name: String!,
  nickname: String,
  meowVolume: Int
}

union CatOrDog = Cat | Dog
union DogOrHuman = Dog | Human
union HumanOrAlien = Human | Alien
</code></pre>
    <section id="sec-Validation.Fields">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Fields">5.1</a></span>Fields</h3>
      <section id="sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types">5.1.1</a></span>Field Selections on Objects, Interfaces, and Unions Types</h4>
        <p><strong> Formal Specification </strong></p>
        <ul>
          <li>For each <var>selection</var> in the document.</li>
          <li>Let <var>fieldName</var> be the target field of <var>selection</var></li>
          <li><var>fieldName</var> must be defined on type in scope</li>
        </ul>
        <p><strong> Explanatory Text </strong></p>
        <p>The target field of a field selection must defined on the scoped type of the selection set. There are no limitations on alias names.</p>
        <p>For example the following fragment would not pass validation:</p><pre class="spec-counter-example"><code>
fragment fieldNotDefined on Dog {
  meowVolume
}

fragment aliasedLyingFieldTargetNotDefined on Dog {
  barkVolume: kawVolume
}
</code></pre>
        <p>For interfaces, direct field selection can only be done on fields. Fields of concrete implementors is not relevant to the validity of the given interface&#8208;typed selection set.</p>
        <p>For example, the following is valid:</p><pre><code>fragment interfaceFieldSelection on Pet {
  name
}
</code></pre>
        <p>and the following is invalid:</p><pre class="spec-counter-example"><code>fragment definedOnImplementorsButNotInterface on Pet {
  nickname
}
</code></pre>
        <p>Because fields are not declared on unions, direct field selection on union&#8208;typed selection set. This is true even if concrete implementors of the union define the fieldName.</p>
        <p>For example the following is invalid</p><pre class="spec-counter-example"><code>fragment directFieldSelectionOnUnion on CatOrDog {
  directField
}

fragment definedOnImplementorsQueriedOnUnion on CatOrDog {
  name
}
</code></pre></section>
      <section id="sec-Field-Selection-Merging">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Field-Selection-Merging">5.1.2</a></span>Field Selection Merging</h4>
        <p><strong> Formal Specification </strong></p>
        <ul>
          <li>Let <var>set</var> be any selection set defined in the GraphQL document</li>
          <li>Let <var>setForKey</var> be the set of selections with a given response key in <var>set</var></li>
          <li>All members of <var>setForKey</var> must:
            <ul>
              <li>Have identical target fields</li>
              <li>Have identical sets of arguments.</li>
              <li>Have identical sets of directives.</li>
            </ul>
          </li>
        </ul>
        <p><strong> Explanatory Text </strong></p>
        <p>Selection names are de&#8208;duplicated and merged for validation, but the target field, arguments, and directives must all be identical.</p>
        <p>For human&#8208;curated GraphQL, this rules seem a bit counterintuitive since it appears to be clear developer error. However in the presence of nested fragments or machine&#8208;generated GraphQL, requiring unique selections is a burdensome limitation
          on tool authors.</p>
        <p>The following selections correctly merge:</p><pre><code>fragment mergeIdenticalFields on Dog {
  name
  name
}

fragment mergeIdenticalAliasesAndFields on Dog {
  otherName: name
  otherName: name
}
</code></pre>
        <p>The following is not able to merge:</p><pre class="spec-counter-example"><code>
fragment conflictingBecauseAlias on Dog {
  name: nickname
  name
}

</code></pre>
        <p>Identical arguments are also merged if they have identical arguments. Both values and variables can be correctly merged.</p>
        <p>For example the following correctly merge:</p><pre><code>
fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: SIT)
}

fragment mergeIdenticalFieldsWithIdenticalValues on Dog {
  doesKnowCommand(dogCommand: $dogCommand)
  doesKnowCommand(dogCommand: $dogCommand)
}

</code></pre>
        <p>The following do not correctly merge:</p><pre class="spec-counter-example"><code>
fragment conflictingArgsOnValues on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: HEEL)
}

fragment conflictingArgsValueAndVar on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: $dogCommand)
}

fragment conflictingArgsWithVars on Dog {
  doesKnowCommand(dogCommand: $varOne)
  doesKnowCommand(dogCommand: $varTwo)
}
</code></pre>
        <p>The same logic applies to directives. The set of directives on each selection with the same response key in a given scope must be identical.</p>
        <p>The following is valid:</p><pre><code>fragment mergeSameFieldsWithSameDirectives on Dog {
  name @include(if: true)
  name @include(if: true)
}
</code></pre>
        <p>and the following is invalid:</p><pre class="spec-counter-example"><code>fragment conflictingDirectiveArgs on Dog {
  name @include(if: true)
  name @include(if: false)
}
</code></pre></section>
      <section id="sec-Leaf-Field-Selections">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Leaf-Field-Selections">5.1.3</a></span>Leaf Field Selections</h4>
        <p><strong> Formal Specification </strong></p>
        <ul>
          <li>For each <var>selection</var> in the document</li>
          <li>Let <var>selectionType</var> be the result type of <var>selection</var></li>
          <li>If <var>selectionType</var> is a scalar:
            <ul>
              <li>The subselection set of that selection must be empty</li>
            </ul>
          </li>
          <li>If <var>selectionType</var> is an interface, union, or object
            <ul>
              <li>The subselection set of that selection must NOT BE empty</li>
            </ul>
          </li>
        </ul>
        <p><strong> Explanatory Text </strong></p>
        <p>Field selections on scalars are never allowed: scalars are the leaf nodes of any GraphQL query.</p>
        <p>The following is valid.</p><pre><code>fragment scalarSelection: Dog {
  barkVolume
}
</code></pre>
        <p>The following is invalid.</p><pre class="spec-counter-example"><code>fragment scalarSelectionsNotAllowedOnBoolean : Dog {
  barkVolume { sinceWhen }
}
</code></pre>
        <p>Conversely the leaf field selections of GraphQL queries must be scalars. Leaf selections on objects, interfaces, and unions without subfields are disallowed.</p>
        <p>Let&rsquo;s assume the following query root type of the schema:</p><pre><code>type QueryRoot {
  human: Human
  pet: Pet
  catOrDog: CatOrDog
}
</code></pre>
        <p>The following examples are invalid</p><pre class="spec-counter-example"><code>
query directQueryOnObjectWithoutSubFields
{
  human
}

query directQueryOnInterfaceWithoutSubFields
{
  pet
}

query directQueryOnUnionWithoutSubFields
{
  catOrDog
}
</code></pre></section>
    </section>
    <section id="sec-Validation.Arguments">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Arguments">5.2</a></span>Arguments</h3>
      <p>Arguments are provided to both fields and directives. The following validation rules apply in both cases.</p>
      <section id="sec-Argument-Names">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Argument-Names">5.2.1</a></span>Argument Names</h4>
        <p><strong> Formal Specification </strong></p>
        <ul>
          <li>For each <var>argument</var> in the document</li>
          <li>Let <var>argumentName</var> be the Name of <var>argument</var>.</li>
          <li>Let <var>argumentDefinition</var> be the argument definition provided by the parent field or definition named <var>argumentName</var>.</li>
          <li><var>argumentDefinition</var> must exist.</li>
        </ul>
        <p><strong> Explanatory Text </strong></p>
        <p>Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive.</p>
        <p>For example the following are valid:</p><pre><code>fragment argOnRequiredArg on Dog {
  doesKnowCommand(dogCommand: SIT)
}

fragment argOnOptional on Dog {
  isHousetrained(atOtherHomes: true) @include(if: true)
}
</code></pre>
        <p>the following is invalid since <code>command</code> is not defined on <code>DogCommand</code>.</p><pre class="spec-counter-example"><code>fragment invalidArgName on Dog {
  doesKnowCommand(command: CLEAN_UP_HOUSE)
}
</code></pre>
        <p>and this is also invalid as <code>unless</code> is not defined on <code>@include</code>.</p><pre class="spec-counter-example"><code>fragment invalidArgName on Dog {
  isHousetrained(atOtherHomes: true) @include(unless: false)
}
</code></pre>
        <p>In order to explore more complicated argument examples, let&rsquo;s add the following to our type system:</p><pre><code>type Arguments {
  multipleReqs(x: Int!, y: Int!)
  booleanArgField(booleanArg: Boolean)
  floatArgField(floatArg: Float)
  intArgField(intArg: Int)
  nonNullBooleanArgField(nonNullBooleanArg: Boolean!)
}
</code></pre>
        <p>Order does not matter in arguments. Therefore both the following example are valid.</p><pre><code>fragment multipleArgs on Arguments {
  multipleReqs(x: 1, y: 2)
}

fragment multipleArgsReverseOrder on Arguments {
  multipleReqs(y: 1, x: 2)
}
</code></pre></section>
      <section id="sec-Argument-Values-Type-Correctness">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Argument-Values-Type-Correctness">5.2.2</a></span>Argument Values Type Correctness</h4>
        <section id="sec-Compatible-Values">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Compatible-Values">5.2.2.1</a></span>Compatible Values</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>argument</var> in the document</li>
            <li>Let <var>value</var> be the Value of <var>argument</var></li>
            <li>If <var>value</var> is not a Variable
              <ul>
                <li>Let <var>argumentName</var> be the Name of <var>argument</var>.</li>
                <li>Let <var>argumentDefinition</var> be the argument definition provided by the parent field or definition named <var>argumentName</var>.</li>
                <li>Let <var>type</var> be the type expected by <var>argumentDefinition</var>.</li>
                <li>The type of <var>literalArgument</var> must be coercible to <var>type</var>.</li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System chapter.</p>
          <p>For example, an Int can be coerced into a Float.</p><pre><code>fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment coercedIntIntoFloatArg on Arguments {
  floatArgField(floatArg: 1)
}
</code></pre>
          <p>An incoercible conversion, is string to int. Therefore, the following example is invalid.</p><pre class="spec-counter-example"><code>fragment stringIntoInt on Arguments {
  intArgField(intArg: &quot;3&quot;)
}
</code></pre></section>
        <section id="sec-Required-Arguments">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Required-Arguments">5.2.2.2</a></span>Required Arguments</h5>
          <ul>
            <li>For each Field or Directive in the document.</li>
            <li>Let <var>arguments</var> be the arguments provided by the Field or Directive.</li>
            <li>Let <var>argumentDefinitions</var> be the set of argument definitions of that Field or Directive.</li>
            <li>For each <var>definition</var> in <var>argumentDefinitions</var>
              <ul>
                <li>Let <var>type</var> be the expected type of <var>definition</var></li>
                <li>If <var>type</var> is Non&#8208;Null
                  <ul>
                    <li>Let <var>argumentName</var> be the name of <var>definition</var></li>
                    <li>Let <var>argument</var> be the argument in <var>arguments</var> named <var>argumentName</var></li>
                    <li><var>argument</var> must exist.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Arguments can be required. Arguments are required if the type of the argument is non&#8208;null. If it is not non&#8208;null, the argument is optional.</p>
          <p>For example the following are valid:</p><pre><code>fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment goodNonNullArg on Arguments {
  nonNullBooleanArgField(nonNullBooleanArg: true)
}

</code></pre>
          <p>The argument can be omitted from a field with a nullable argument.</p>
          <p>Therefore the following query is valid:</p><pre><code>fragment goodBooleanArgDefault on Arguments {
  booleanArgField
}
</code></pre>
          <p>but this is not valid on a non&#8208;null argument.</p><pre class="spec-counter-example"><code>fragment missingRequiredArg on Arguments {
  notNullBooleanArgField
}
</code></pre></section>
      </section>
    </section>
    <section id="sec-Validation.Fragments">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Fragments">5.3</a></span>Fragments</h3>
      <section id="sec-Fragment-Declarations">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-Declarations">5.3.1</a></span>Fragment Declarations</h4>
        <section id="sec-Fragment-Spread-Type-Existence">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-Spread-Type-Existence">5.3.1.1</a></span>Fragment Spread Type Existence</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each named spread <var>namedSpread</var> in the document</li>
            <li>Let <var>fragment</var> be the target of <var>namedSpread</var></li>
            <li>The target type of <var>fragment</var> must be defined in the schema</li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Fragments must be specified on types that exist in the schema. This applies for both named and inline fragments. If they are not defined in the schema, the query does not validate.</p>
          <p>For example the following fragments are valid:</p><pre><code>
fragment CorrectType on Dog {
  name
}

fragment InlineFragment on Dog {
  ... on Dog {
    name
  }
}

</code></pre>
          <p>and the following do not validate:</p><pre class="spec-counter-example"><code>
fragment NotOnExistingType on NotInSchema {
  name
}

fragment InlineNotExistingType on Dog {
  ... on NotInSchema { name }
}
</code></pre></section>
        <section id="sec-Fragments-On-Composite-Types">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragments-On-Composite-Types">5.3.1.2</a></span>Fragments On Composite Types</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>fragment</var> defined in the document.</li>
            <li>The target type of fragment must be have kind <span class="spec-nt">UNION</span>, <span class="spec-nt">INTERFACE</span>, or <span class="spec-nt">OBJECT</span>.</li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Fragments can only be declared on unions, interfaces, and objects. They are invalid on scalars. They can only be applied on non&#8208;leaf fields. This rule applies to both inline and named fragments.</p>
          <p>The following fragment declarations are valid:</p><pre><code>fragment fragOnObject on Dog { name }
fragment fragOnInterface on Pet { name }
fragment fragOnUnion on CatOrDog { ... on Dog { name } }
</code></pre>
          <p>and the following are invalid:</p><pre class="spec-counter-example"><code>fragment fragOnScalar on Int { something }
fragment inlineFragOnScalar on Dog { ... on Boolean { somethingElse } }
</code></pre></section>
        <section id="sec-Fragments-Must-Be-Used">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragments-Must-Be-Used">5.3.1.3</a></span>Fragments Must Be Used</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>fragment</var> defined in the document.</li>
            <li><var>fragment</var> must be be the target of at least one spread in the document</li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Defined fragments must be used within a query document.</p>
          <p>For example the following is an invalid query document:</p><pre class="spec-counter-example"><code>fragment nameFragment on Dog { // unused
  name
}
{ dog { name } }
</code></pre></section>
      </section>
      <section id="sec-Fragment-Spreads">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-Spreads">5.3.2</a></span>Fragment Spreads</h4>
        <p>Field selection is also determined by spreading fragments into one another. The selection set of the target fragment is unioned with the selection set at the level at which the target fragment is referenced.</p>
        <section id="sec-Fragment-spread-target-defined">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-spread-target-defined">5.3.2.1</a></span>Fragment spread target defined</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For every <var>namedSpread</var> in the document.</li>
            <li>Let <var>fragment</var> be the target of <var>namedSpread</var></li>
            <li><var>fragment</var> must be defined in the document</li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Named fragment spreads must refer to fragments defined within the document. If the target of a spread is not defined, this is an error:</p><pre class="spec-counter-example"><code>fragment nameFragment on Dog { name }
{ dog { ...undefinedFragment} }
</code></pre></section>
        <section id="sec-Fragment-spreads-must-not-form-cycles">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-spreads-must-not-form-cycles">5.3.2.2</a></span>Fragment spreads must not form cycles</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>fragmentDefinition</var> in the document</li>
            <li>Let <var>visited</var> be the empty set.</li>
            <li><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span></li>
          </ul>
          <p><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span> :</p>
          <ul>
            <li>Let <var>spreads</var> be all fragment spread descendants of <var>fragmentDefinition</var></li>
            <li>For each <var>spread</var> in <var>spreads</var>
              <ul>
                <li><var>visited</var> must not contain <var>spread</var></li>
                <li>Let <var>nextVisited</var> be the set including <var>spread</var> and members of <var>visited</var></li>
                <li>Let <var>nextFragmentDefinition</var> be the target of <var>spread</var></li>
                <li><span class="spec-call">DetectCycles(<var>nextFragmentDefinition</var>, <var>nextVisited</var>)</span></li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.</p>
          <p>This invalidates fragments that would result in an infinite spread:</p><pre class="spec-counter-example"><code>{
  dog {
    ...nameFragment
  }
}

fragment nameFragment on Dog {
  name
  ...barkVolumeFragment
}

fragment barkVolumeFragment on Dog {
  barkVolume
  ...nameFragment
}
</code></pre>
          <p>If the above fragments were inlined, this would result in the infinitely large:</p><pre class="spec-counter-example"><code>{
  dog {
    name, barkVolume, name, barkVolume, name, barkVolume, name, # etc...
  }
}
</code></pre>
          <p>This also invalidates fragments that would result in an infinite recursion when executed against cyclic data:</p><pre class="spec-counter-example"><code>{
  dog {
    ...dogFragment
  }
}

fragment dogFragment on Dog {
  name
  owner {
    ...ownerFragment
  }
}

fragment ownerFragment on Dog {
  name
  pets {
    ...dogFragment
  }
}
</code></pre></section>
        <section id="sec-Fragment-spread-is-possible">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Fragment-spread-is-possible">5.3.2.3</a></span>Fragment spread is possible</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>spread</var> (named or inline) in defined in the document.</li>
            <li>Let <var>fragment</var> be the target of <var>spread</var></li>
            <li>Let <var>fragmentType</var> be the type condition of <var>fragment</var></li>
            <li>Let <var>parentType</var> be the type of the selection set containing <var>spread</var></li>
            <li>Let <var>applicableTypes</var> be the intersection of <span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>fragmentType</var>)</span> and <span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>parentType</var>)</span></li>
            <li><var>applicableTypes</var> must not be empty.</li>
          </ul>
          <div class="spec-algo" id="GetPossibleTypes()"><span class="spec-call"><a href="#GetPossibleTypes()">GetPossibleTypes</a>(<var>type</var>)</span>
            <ol>
              <li>If <var>type</var> is an object type, return a set containing <var>type</var></li>
              <li>If <var>type</var> is an interface type, return the set of types implementing <var>type</var></li>
              <li>If <var>type</var> is a union type, return the set of possible types of <var>type</var></li>
            </ol>
          </div>
          <p><strong> Explanatory Text </strong></p>
          <p>Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within
            the parent type.</p>
          <p>and the following valid fragments:</p>
          <section id="sec-Object-Spreads-In-Object-Scope">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Object-Spreads-In-Object-Scope">5.3.2.3.1</a></span>Object Spreads In Object Scope</h6>
            <p>In the scope of a object type, the only valid object type fragment spread is one that applies to the same type that is in scope.</p>
            <p>For example</p><pre><code>fragment dogFragment on Dog { ... on Dog { barkVolume } }
</code></pre>
            <p>and the following is invalid</p><pre class="spec-counter-example"><code>fragment catInDogFragmentInvalid on Dog { ... on Cat { meowVolume } }
</code></pre></section>
          <section id="sec-Abstract-Spreads-in-Object-Scope">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Abstract-Spreads-in-Object-Scope">5.3.2.3.2</a></span>Abstract Spreads in Object Scope</h6>
            <p>In scope of an object type, unions or interface spreads can be used if the object type implements the interface or is a member of the union.</p>
            <p>For example</p><pre><code>fragment petNameFragment on Pet { name }
fragment interfaceWithinObjectFragment on Dog { ...petNameFragment }
</code></pre>
            <p>is valid because <span class="spec-nt">Dog</span> implements Pet.</p>
            <p>Likewise</p><pre><code>fragment CatOrDogNameFragment on CatOrDog { ... on Cat { meowVolume } }
fragment unionWithObjectFragment on Dog { ...CatOrDogFragment }
</code></pre>
            <p>is valid because <span class="spec-nt">Dog</span> is a member of the <span class="spec-nt">CatOrDog</span> union. It is worth noting that if one inspected the contents of the <span class="spec-nt">CatOrDogNameFragment</span> you could note
              that the no valid results would ever be returned. However we do not specify this as invalid because we only consider the fragment declaration, not its body.</p>
          </section>
          <section id="sec-Object-Spreads-In-Abstract-Scope">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Object-Spreads-In-Abstract-Scope">5.3.2.3.3</a></span>Object Spreads In Abstract Scope</h6>
            <p>Union or interface spreads can be used within the context of an object type fragment, but only if the object type is one of the possible types of the that interface or union.</p>
            <p>For example, the following fragments are valid:</p><pre><code>fragment petFragment on Pet { name, ... on Dog { barkVolume } }
fragment catOrDogFragment on CatOrDog { ... on Cat { meowVolume } }
</code></pre>
            <p><var>petFragment</var> is valid because <span class="spec-nt">Dog</span> implements the interface <span class="spec-nt">Pet</span>. <var>catOrDogFragment</var> is valid because <span class="spec-nt">Cat</span> is a member of the <span class="spec-nt">CatOrDog</span>              union.</p>
            <p>By contrast the following fragments are invalid:</p><pre class="spec-counter-example"><code>fragment sentientFragment on Sentient { ... on Dog { barkVolume } }
fragment humanOrAlienFragment on HumanOrAlien { ... on Cat { meowVolume } }
</code></pre>
            <p><span class="spec-nt">Dog</span> does not implement the interface <span class="spec-nt">Sentient</span> and therefore <var>sentientFragment</var> can never return meaningful results. Therefore the fragment is invalid. Likewise <span class="spec-nt">Cat</span>              is not a member of the union <span class="spec-nt">HumanOrAlien</span>, and it can also never return meaningful results, making it invalid.</p>
          </section>
          <section id="sec-Abstract-Spreads-in-Abstract-Scope">
            <h6><span class="spec-secnum" title="link to this section"><a href="#sec-Abstract-Spreads-in-Abstract-Scope">5.3.2.3.4</a></span>Abstract Spreads in Abstract Scope</h6>
            <p>Union or interfaces fragments can be used within each other. As long as there exists at least <em>one</em> object type that exists in the intersection of the possible types of the scope and the spread, the spread is considered valid.</p>
            <p>So for example</p><pre><code>fragment unionWithInterface on Pet { ...dogOrHumanFragment }
fragment dogOrHumanFragment on DogOrHuman { ... on Dog { barkVolume } }
</code></pre>
            <p>is consider valid because <span class="spec-nt">Dog</span> implements interface <span class="spec-nt">Pet</span> and is a member of <span class="spec-nt">DogOrHuman</span>.</p>
            <p>However</p><pre class="spec-counter-example"><code>fragment nonIntersectingInterfaces on Pet { ...sentientFragment }
fragment sentientFragment on Sentient { name }
</code></pre>
            <p>is not valid because there exists no type that implements both <span class="spec-nt">Pet</span> and <span class="spec-nt">Sentient</span>.</p>
          </section>
        </section>
      </section>
    </section>
    <section id="sec-Validation.Directives">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Directives">5.4</a></span>Directives</h3>
      <section id="sec-Directives-Are-Defined">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Directives-Are-Defined">5.4.1</a></span>Directives Are Defined</h4>
        <p><strong> Formal Specification </strong></p>
        <ul>
          <li>For every <var>directive</var> in a document.</li>
          <li>Let <var>directiveName</var> be the name of <var>directive</var>.</li>
          <li>Let <var>directiveDefinition</var> be the directive named <var>directiveName</var>.</li>
          <li><var>directiveDefinition</var> must exist.</li>
        </ul>
        <p><strong> Explanatory Text </strong></p>
        <p>GraphQL servers define what directives they support. For each usage of a directive, the directive must be available on that server.</p>
      </section>
    </section>
    <section id="sec-Validation.Operations">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Operations">5.5</a></span>Operations</h3>
      <section id="sec-Validation.Operations.Variables">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Validation.Operations.Variables">5.5.1</a></span>Variables</h4>
        <section id="sec-Variable-Default-Values-Are-Correctly-Typed">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Variable-Default-Values-Are-Correctly-Typed">5.5.1.1</a></span>Variable Default Values Are Correctly Typed</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For every <var>operation</var> in a document</li>
            <li>For every <var>variable</var> on each <var>operation</var>
              <ul>
                <li>Let <var>variableType</var> be the type of <var>variable</var></li>
                <li>If <var>variableType</var> is non&#8208;null it cannot have a default value</li>
                <li>If <var>variable</var> has a default value it must be of the same types or able to be coerced to <var>variableType</var></li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Variable defined by operations are allowed to define default values if the type of that variable not non&#8208;null.</p>
          <p>For example the following query will pass validation.</p><pre><code>  query HouseTrainedQuery($atOtherHomes: Boolean = true) {
    dog { isHousetrained(atOtherHomes: $atOtherHomes) }
  }
</code></pre>
          <p>However if the variable is defined as non&#8208;null, default values are unreachable. Therefore queries such as the following fail validation</p><pre class="spec-counter-example"><code>  query HouseTrainedQuery($atOtherHomes: Boolean! = true) {
    dog { isHousetrained(atOtherHomes: $atOtherHomes) }
  }
</code></pre>
          <p>Default values must be compatible with the types of variables. Types much match or they must be coercible to the type.</p>
          <p>Non&#8208;matching types fail, such as in the following example:</p><pre class="spec-counter-example"><code>  query HouseTrainedQuery($atOtherHomes: Boolean = &quot;true&quot;) {
    dog { isHousetrained(atOtherHomes: $atOtherHomes) }
  }
</code></pre>
          <p>However if a type is coercible the query will pass validation.</p>
          <p>For example:</p><pre><code>  query IntToFloatQuery($floatVar: Float = 1) {
    arguments {
      floatArgField(floatArg: $floatVar)
    }
  }
</code></pre></section>
        <section id="sec-Variables-Are-Input-Types">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Variables-Are-Input-Types">5.5.1.2</a></span>Variables Are Input Types</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For every <var>operation</var> in a <var>document</var></li>
            <li>For every <var>variable</var> on each <var>operation</var>
              <ul>
                <li>Let <var>variableType</var> be the type of <var>variable</var></li>
                <li><var>variableType</var> must of kind <span class="spec-nt">SCALAR</span>, <span class="spec-nt">ENUM</span> or <span class="spec-nt">INPUT_OBJECT</span></li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Variables can only be scalars, enums, input objects, or lists and non&#8208;null variants of those types. These are known as input types. Object, unions, and interfaces cannot be used as inputs.</p>
          <p>The following queries are valid:</p><pre><code>  query TakesBoolean($atOtherHomes: Boolean) { /* ... */ }
  query TakesComplexInput($complexInput: ComplexInput) { /* ... */ }
  query TakesListOfBooleanBang($booleans: [Boolean!]) { /* ... */ }
</code></pre>
          <p>The following queries are invalid:</p><pre class="spec-counter-example"><code>  query TakesCat($cat: Cat) { /* ... */ }
  query TakesDogBang($dog: Dog!) { /* ... */ }
  query TakesListOfPet($pets: [Pet]) { /* ... */ }
  query TakesCatOrDog($catOrDog: CatOrDog) { /* ... */ }
</code></pre></section>
        <section id="sec-All-Variable-Uses-Defined">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-All-Variable-Uses-Defined">5.5.1.3</a></span>All Variable Uses Defined</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>operation</var> in a document
              <ul>
                <li>For each <var>variableUsage</var> in scope, variable must be operation&rsquo;s variable list.</li>
                <li>Let <var>fragments</var> be every fragment reference by that operation transitively</li>
                <li>For each <var>fragment</var> in <var>fragments</var>
                  <ul>
                    <li>For each <var>variableUsage</var> in scope of <var>fragment</var>, variable must be <var>operation</var>&lsquo;s variable list.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Variables are scoped on a per&#8208;operation basis. That means that any variable used within the context of a operation must be defined at the top level of that operation</p>
          <p>For example:</p><pre><code>query VariableIsDefined($atOtherHomes: Boolean) {
  dog { isHousetrained(atOtherHomes: $booleanArg)
}
</code></pre>
          <p>is valid. $<var>atOtherHomes</var> is defined by the operation.</p>
          <p>By contrast the following query is invalid:</p><pre class="spec-counter-example"><code>query VariableIsNotDefined {
  dog { isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre>
          <p>$<var>atOtherHomes</var> is not defined by the operation.</p>
          <p>Fragments complicate this rule. Any fragment transitively included by an operation has access to the variables defined by that operation. Fragments can appear within multiple operations and therefore variable usages must correspond to variable
            definitions in all of those operations.</p>
          <p>For example the following is valid:</p><pre><code>query VariableIsDefinedUsedInSingleFragment($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes}
}
</code></pre>
          <p>since <var>isHousetrainedFragment</var> is used within the context of the operation <span class="spec-nt">VariableIsDefinedUsedInSingleFragment</span> and the variable is defined by that operation.</p>
          <p>On the contrary is a fragment is included within an operation that does not define a referenced variable, this is a validation error.</p><pre class="spec-counter-example"><code>query VariableIsNotDefinedUsedInSingleFragment {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes}
}
</code></pre>
          <p>This applies transitively as well, so the following also fails:</p><pre class="spec-counter-example"><code>query VariableIsNotDefinedUsedInNestedFragment {
  dog { ...outerHousetrainedFragment }
}

fragment outerHousetrainedFragment on Dog {
  ...isHousetrainedFragment
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes}
}
</code></pre>
          <p>Variables must be defined in all operations in which a fragment is used.</p><pre><code>query HousetrainedQueryOne($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

query HousetrainedQueryTwo($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes}
}
</code></pre>
          <p>However the following does not validate:</p><pre class="spec-counter-example"><code>
query HousetrainedQueryOne($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

query HousetrainedQueryTwoNotDefined {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes}
}
</code></pre>
          <p>This is because <span class="spec-nt">HousetrainedQueryTwoNotDefined</span> does not define a variable $<var>atOtherHomes</var> but that variable is used by <var>isHousetrainedFragment</var> which is included in that operation.</p>
        </section>
        <section id="sec-All-Variables-Used">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-All-Variables-Used">5.5.1.4</a></span>All Variables Used</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For every <var>operation</var> in the document.</li>
            <li>Let <var>variables</var> be the variables defined by that <var>operation</var></li>
            <li>Each <var>variable</var> in <var>variables</var> must be used at least once in either the operation scope itself or any fragment transitively referenced by that operation.</li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error.</p>
          <p>For example the following is invalid:</p><pre class="spec-counter-example"><code>query VariableUnused($atOtherHomes: Boolean) {
  dog { isHousetrained }
}
</code></pre>
          <p>because $<var>atOtherHomes</var> in not referenced.</p>
          <p>These rules apply to transitive fragment spreads as well:</p><pre><code>query VariableUsedInFragment($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre>
          <p>The above is valid since $<var>atOtherHomes</var> is used in <var>isHousetrainedFragment</var> which is included by <span class="spec-nt">VariableUsedInFragment</span>.</p>
          <p>If that fragment did not have a reference to $<var>atOtherHomes</var> it would be not valid:</p><pre class="spec-counter-example"><code>query VariableNotUsedWithinFragment($atOtherHomes: Boolean) {
  ...isHousetrainedWithoutVariableFragment
}

fragment isHousetrainedWithoutVariableFragment on Dog {
  isHousetrained
}
</code></pre>
          <p>All operations in a document must use all of their variables.</p>
          <p>As a result, the following document does not validate.</p><pre class="spec-counter-example"><code>
query QueryWithUsedVar($atOtherHomes: Boolean) {
  dog { ...isHousetrainedFragment }
}

query QueryWithExtraVar($atOtherHomes: Boolean, $extra: Int) {
  dog { ...isHousetrainedFragment }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre>
          <p>This document is not valid because <span class="spec-nt">QueryWithExtraVar</span> defines an extraneous variable.</p>
        </section>
        <section id="sec-All-Variable-Usages-are-Allowed">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-All-Variable-Usages-are-Allowed">5.5.1.5</a></span>All Variable Usages are Allowed</h5>
          <p><strong> Formal Specification </strong></p>
          <ul>
            <li>For each <var>operation</var> in <var>document</var></li>
            <li>Let <var>variableUsages</var> be all usages transitively included in the <var>operation</var></li>
            <li>For each <var>variableUsage</var> in <var>variableUsages</var>
              <ul>
                <li>Let <var>variableType</var> be the type of variable definition in the operation</li>
                <li>Let <var>argumentType</var> be the type of the argument the variable is passed to.</li>
                <li>Let <var>hasDefault</var> be true if the variable definition defines a default.</li>
                <li>AreTypesCompatible(<var>argumentType</var>, <var>variableType</var>, <var>hasDefault</var>) must be true</li>
              </ul>
            </li>
            <li>AreTypesCompatible(<var>argumentType</var>, <var>variableType</var>, <var>hasDefault</var>):
              <ul>
                <li>If <var>hasDefault</var> is true, treat the <var>variableType</var> as non&#8208;null.</li>
                <li>If inner type of <var>argumentType</var> and <var>variableType</var> be different, return false</li>
                <li>If <var>argumentType</var> and <var>variableType</var> have different list dimensions, return false</li>
                <li>If any list level of <var>variableType</var> is not non&#8208;null, and the corresponding level in <var>argument</var> is non&#8208;null, the types are not compatible.</li>
              </ul>
            </li>
          </ul>
          <p><strong> Explanatory Text </strong></p>
          <p>Variable usages must be compatible with the arguments they are passed to.</p>
          <p>Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a not&#8208;null argument type.</p>
          <p>Types must match:</p><pre class="spec-counter-example"><code>Query IntCannotGoIntoBoolean($intArg: Int) {
  arguments { booleanArgField(booleanArg: $intArg) }
}
</code></pre>
          <p>$<var>intArg</var> typed as <span class="spec-nt">Int</span> cannot be used as a argument to <var>booleanArg</var>, typed as <span class="spec-nt">Boolean</span>.</p>
          <p>List cardinality must also be the same. For example, lists cannot be passed into singular values.</p><pre class="spec-counter-example"><code>Query BooleanListCannotGoIntoBoolean($booleanListArg: [Boolean]) {
  arguments { booleanArgField(booleanArg: $booleanListArg) }
}
</code></pre>
          <p>Nullability must also be respected. In general a nullable variable cannot be passed to a non&#8208;null argument.</p><pre class="spec-counter-example"><code>Query BooleanArgQuery($booleanArg: Boolean) {
  arguments { nonNullBooleanArgField(nonNullBooleanArg: $booleanArg) }
}
</code></pre>
          <p>A notable exception is when default arguments are provided. They are, in effect, treated as non&#8208;nulls.</p><pre><code>Query BooleanArgQueryWithDefault($booleanArg: Boolean = true) {
  arguments { nonNullBooleanArgField(nonNullBooleanArg: $booleanArg) }
}
</code></pre>
          <p>For list types, the same rules around nullability apply to both outer types and inner types. A nullable list cannot be passed to a non&#8208;null list, and a lists of nullable values cannot be passed to a list of non&#8208;null values.</p><pre><code>
Query NonNullListToList($nonNullBooleanList: ![Boolean]) {
  arguments { booleanListArgField(booleanListArg: $nonNullBooleanList) }
}

</code></pre>
          <p>However a nullable list could not be passed to a non&#8208;null list.</p><pre class="spec-counter-example"><code>
Query ListToNonNullList($booleanList: [Boolean]) {
  arguments { nonNullBooleanListField(nonNullBooleanListArg: $booleanList) }
}

</code></pre>
          <p>This would fail validation because a <code>[T]</code> cannot be passed to a <code>[T]!</code>.</p>
          <p>Similarly a <code>[T]</code> cannot be passed to a <code>[T!]</code>. </p>
        </section>
      </section>
    </section>
  </section>
  <section id="sec-Execution">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Execution">6</a></span>Execution</h2>
    <p>This section describes how GraphQL generates a response from a request.</p>
    <section id="sec-Evaluating-requests">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Evaluating-requests">6.1</a></span>Evaluating requests</h3>
      <p>To evaluate a request, the executor must have a parsed <code>Document</code> (as defined in the &ldquo;Query Language&rdquo; part of this spec) and a selected operation name to run.</p>
      <p>The executor should find the <code>Operation</code> in the <code>Document</code> with the given operation name. If no such operation exists, the executor should throw an error. If the operation is found, then the result of evaluating the request
        should be the result of evaluating the operation according to the &ldquo;Evaluating operations&rdquo; section.</p>
    </section>
    <section id="sec-Evaluating-operations">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Evaluating-operations">6.2</a></span>Evaluating operations</h3>
      <p>The type system, as described in the &ldquo;Type System&rdquo; part of the spec, must provide a &ldquo;Query Root&rdquo; and a &ldquo;Mutation Root&rdquo; object.</p>
      <p>If the operation is a mutation, the result of the operation is the result of evaluating the mutation&rsquo;s top level selection set on the &ldquo;Mutation Root&rdquo; object. This selection set should be evaluated serially.</p>
      <p>If the operation is a query, the result of the operation is the result of evaluating the query&rsquo;s top level selection set on the &ldquo;Query Root&rdquo; object.</p>
    </section>
    <section id="sec-Evaluating-selection-sets">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Evaluating-selection-sets">6.3</a></span>Evaluating selection sets</h3>
      <p>To evaluate a selection set, the executor needs to know the object on which it is evaluating the set and whether it is being evaluated serially.</p>
      <p>If the selection set is being evaluated on the <code>null</code> object, then the result of evaluating the selection set is <code>null</code>.</p>
      <p>Otherwise, the selection set is turned into a grouped field set; each entry in the grouped field set is a list of fields that share a responseKey.</p>
      <p>The selection set is converted to a grouped field set by calling <code>CollectFields</code>, initializing <code>visitedFragments</code> to an empty list.</p>
      <div class="spec-algo" id="CollectFields()"><span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>selectionSet</var>, <var>visitedFragments</var>)</span>
        <ol>
          <li>Initialize <var>groupedFields</var> to an empty list of lists.</li>
          <li>For each <var>selection</var> in <var>selectionSet</var>;
            <ol>
              <li>If <var>selection</var> provides the directive <code>@skip</code>, let <var>skipDirective</var> be that directive.
                <ol>
                  <li>If <var>skipDirective</var>&lsquo;s <var>if</var> argument is <span class="spec-keyword">true</span>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                </ol>
              </li>
              <li>If <var>selection</var> provides the directive <code>@include</code>, let <var>includeDirective</var> be that directive.
                <ol>
                  <li>If <var>includeDirective</var>&lsquo;s <var>if</var> argument is <span class="spec-keyword">false</span>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                </ol>
              </li>
              <li>If <var>selection</var> is a Field:
                <ol>
                  <li>Let <var>responseKey</var> be the response key of <var>selection</var>.</li>
                  <li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li>
                  <li>Append <var>selection</var> to the <var>groupForResponseKey</var>.</li>
                </ol>
              </li>
              <li>If <var>selection</var> is a FragmentSpread:
                <ol>
                  <li>Let <var>fragmentSpreadName</var> be the name of <var>selection</var>.</li>
                  <li>If <var>fragmentSpreadName</var> is in <var>visitedFragments</var>, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                  <li>Add <var>fragmentSpreadName</var> to <var>visitedFragments</var>.</li>
                  <li>Let <var>fragment</var> be the Fragment in the current Document whose name is <var>fragmentSpreadName</var>.</li>
                  <li>If no such <var>fragment</var> exists, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                  <li>Let <var>fragmentType</var> be the type condition on <var>fragment</var>.</li>
                  <li>If <span class="spec-call"><a href="#doesFragmentTypeApply()">doesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span> is false, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                  <li>Let <var>fragmentSelectionSet</var> be the top&#8208;level selection set of <var>fragment</var>.</li>
                  <li>Let <var>fragmentGroupedFields</var> be the result of calling <span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>fragmentSelectionSet</var>)</span>.</li>
                  <li>For each <var>fragmentGroup</var> in <var>fragmentGroupedFields</var>:
                    <ol>
                      <li>Let <var>responseKey</var> be the response key shared by all fields in <var>fragmentGroup</var></li>
                      <li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li>
                      <li>Append all items in <var>fragmentGroup</var> to <var>groupForResponseKey</var>.</li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>If <var>selection</var> is an inline fragment:
                <ol>
                  <li>Let <var>fragmentType</var> be the type condition on <var>selection</var>.</li>
                  <li>If <span class="spec-call"><a href="#doesFragmentTypeApply()">doesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span> is false, continue with the next <var>selection</var> in <var>selectionSet</var>.</li>
                  <li>Let <var>fragmentSelectionSet</var> be the top&#8208;level selection set of <var>selection</var>.</li>
                  <li>Let <var>fragmentGroupedFields</var> be the result of calling <span class="spec-call"><a href="#CollectFields()">CollectFields</a>(<var>objectType</var>, <var>fragmentSelectionSet</var>)</span>.</li>
                  <li>For each <var>fragmentGroup</var> in <var>fragmentGroupedFields</var>:
                    <ol>
                      <li>Let <var>responseKey</var> be the response key shared by all fields in <var>fragmentGroup</var></li>
                      <li>Let <var>groupForResponseKey</var> be the list in <var>groupedFields</var> for <var>responseKey</var>; if no such list exists, create it as an empty list.</li>
                      <li>Append all items in <var>fragmentGroup</var> to <var>groupForResponseKey</var>.</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return <var>groupedFields</var>.</li>
        </ol>
      </div>
      <div class="spec-algo" id="doesFragmentTypeApply()"><span class="spec-call"><a href="#doesFragmentTypeApply()">doesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span>
        <ol>
          <li>If <var>fragmentType</var> is an Object Type, return <span class="spec-keyword">true</span> if <var>objectType</var> is <var>fragmentType</var>, otherwise return <span class="spec-keyword">false</span>.</li>
          <li>If <var>fragmentType</var> is an Interface Type, return <span class="spec-keyword">true</span> if <var>objectType</var> is an implementation of <var>fragmentType</var>, otherwise return <span class="spec-keyword">false</span>.</li>
          <li>If <var>fragmentType</var> is a Union, return <span class="spec-keyword">true</span> if <var>objectType</var> is a possible type of <var>fragmentType</var>, otherwise return <span class="spec-keyword">false</span>.</li>
        </ol>
      </div>
      <p>The result of evaluating the selection set is the result of evaluating the corresponding grouped field set. The corresponding grouped field set should be evaluated serially if the selection set is being evaluated serially, otherwise it should be
        evaluated normally.</p>
    </section>
    <section id="sec-Evaluating-a-grouped-field-set">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Evaluating-a-grouped-field-set">6.4</a></span>Evaluating a grouped field set</h3>
      <p>The result of evaluating a grouped field set will be an unordered map. There will be an entry in this map for every item in the grouped field set.</p>
      <section id="sec-Field-entries">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Field-entries">6.4.1</a></span>Field entries</h4>
        <p>Each item in the grouped field set can potentially create an entry in the result map. That entry in the result map is the result is the result of calling <code>GetFieldEntry</code> on the corresponding item in the grouped field set. <code>GetFieldEntry</code>          can return <code>null</code>, which indicates that there should be no entry in the result map for this item. Note that this is distinct from returning an entry with a string key and a null value, which indicates that an entry in the result should
          be added for that key, and its value should be null.</p>
        <p><code>GetFieldEntry</code> assumes the existence of two functions that are not defined in this section of the spec. It is expected that the type system provides these methods:</p>
        <ul>
          <li><code>ResolveFieldOnObject</code>, which takes an object type, a field, and an object, and returns the result of resolving that field on the object.</li>
          <li><code>GetFieldTypeFromObjectType</code>, which takes an object type and a field, and returns that field&rsquo;s type on the object type, or <code>null</code> if the field is not valid on the object type.</li>
        </ul>
        <div class="spec-algo" id="GetFieldEntry()"><span class="spec-call"><a href="#GetFieldEntry()">GetFieldEntry</a>(<var>objectType</var>, <var>object</var>, <var>fields</var>)</span>
          <ol>
            <li>Let <var>firstField</var> be the first entry in the ordered list <var>fields</var>. Note that <var>fields</var> is never empty, as the entry in the grouped field set would not exist if there were no fields.</li>
            <li>Let <var>responseKey</var> be the response key of <var>firstField</var>.</li>
            <li>Let <var>fieldType</var> be the result of calling <span class="spec-call"><a href="#GetFieldTypeFromObjectType()">GetFieldTypeFromObjectType</a>(<var>objectType</var>, <var>firstField</var>)</span>.</li>
            <li>If <var>fieldType</var> is <span class="spec-keyword">null</span>, return <span class="spec-keyword">null</span>, indicating that no entry exists in the result map.</li>
            <li>Let <var>resolvedObject</var> be <span class="spec-call"><a href="#ResolveFieldOnObject()">ResolveFieldOnObject</a>(<var>objectType</var>, <var>object</var>, <var>fieldEntry</var>)</span>.</li>
            <li>If <var>resolvedObject</var> is <span class="spec-keyword">null</span>, return <span class="spec-call">tuple(<var>responseKey</var>, <span class="spec-keyword">null</span>)</span>, indicating that an entry exists in the result map whose value
              is <code>null</code>.</li>
            <li>Let <var>subSelectionSet</var> be the result of calling <span class="spec-call"><a href="#MergeSelectionSets()">MergeSelectionSets</a>(<var>fields</var>)</span>.</li>
            <li>Let <var>responseValue</var> be the result of calling <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>fieldType</var>, <var>resolvedObject</var>, <var>subSelectionSet</var>)</span>.</li>
            <li>Return <span class="spec-call">tuple(<var>responseKey</var>, <var>responseValue</var>)</span>.</li>
          </ol>
        </div>
        <div class="spec-algo" id="GetFieldTypeFromObjectType()"><span class="spec-call"><a href="#GetFieldTypeFromObjectType()">GetFieldTypeFromObjectType</a>(<var>objectType</var>, <var>firstField</var>)</span>
          <ol>
            <li>Call the method provided by the type system for determining the field type on a given object type.</li>
          </ol>
        </div>
        <div class="spec-algo" id="ResolveFieldOnObject()"><span class="spec-call"><a href="#ResolveFieldOnObject()">ResolveFieldOnObject</a>(<var>objectType</var>, <var>object</var>, <var>firstField</var>)</span>
          <ol>
            <li>Call the method provided by the type system for determining the resolution of a field on a given object.</li>
          </ol>
        </div>
        <div class="spec-algo" id="MergeSelectionSets()"><span class="spec-call"><a href="#MergeSelectionSets()">MergeSelectionSets</a>(<var>fields</var>)</span>
          <ol>
            <li>Let <var>selectionSet</var> be an empty list.</li>
            <li>For each <var>field</var> in <var>fields</var>:
              <ol>
                <li>Let <var>fieldSelectionSet</var> be the selection set of <var>field</var>.</li>
                <li>If <var>fieldSelectionSet</var> is null or empty, continue to the next field.</li>
                <li>Append all selections in <var>fieldSelectionSet</var> to <var>selectionSet</var>.</li>
              </ol>
            </li>
            <li>Return <var>selectionSet</var>.</li>
          </ol>
        </div>
        <div class="spec-algo" id="CompleteValue()"><span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>fieldType</var>, <var>result</var>, <var>subSelectionSet</var>)</span>
          <ol>
            <li>If the <var>fieldType</var> is a Non&#8208;Null type:
              <ol>
                <li>Let <var>innerType</var> be the inner type of <var>fieldType</var>.</li>
                <li>Let <var>completedResult</var> be the result of calling <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>innerType</var>, <var>result</var>)</span>.</li>
                <li>If <var>completedResult</var> is <span class="spec-keyword">null</span>, throw a field error.</li>
                <li>Return <var>completedResult</var>.</li>
              </ol>
            </li>
            <li>If <var>result</var> is <span class="spec-keyword">null</span> or a value similar to <span class="spec-keyword">null</span> such as <span class="spec-keyword">undefined</span> or <span class="spec-nt">NaN</span>, return <span class="spec-keyword">null</span>.</li>
            <li>If <var>fieldType</var> is a List type:
              <ol>
                <li>If <var>result</var> is not a collection of values, throw a field error.</li>
                <li>Let <var>innerType</var> be the inner type of <var>fieldType</var>.</li>
                <li>Return a list where each item is the result of calling <span class="spec-call"><a href="#CompleteValue()">CompleteValue</a>(<var>innerType</var>, <var>resultItem</var>)</span>, where <var>resultItem</var> is each item in <var>result</var>.</li>
              </ol>
            </li>
            <li>If <var>fieldType</var> is a Scalar or Enum type:
              <ol>
                <li>Return the result of &ldquo;coercing&rdquo; <var>result</var>, ensuring it is a legal value of <var>fieldType</var>, otherwise <span class="spec-keyword">null</span>.</li>
              </ol>
            </li>
            <li>If <var>fieldType</var> is an Object, Interface, or Union type:
              <ol>
                <li>Return the result of evaluating <var>subSelectionSet</var> on <var>fieldType</var> normally.</li>
              </ol>
            </li>
          </ol>
        </div>
      </section>
      <section id="sec-Normal-evaluation">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Normal-evaluation">6.4.2</a></span>Normal evaluation</h4>
        <p>When evaluating a grouped field set without a serial execution order requirement, the executor can determine the entries in the result map in whatever order it chooses. Because the resolution of fields other than top&#8208;level mutation fields
          is always side effect&ndash;free and idempotent, the execution order must not affect the result, and hence the server has the freedom to evaluate the field entries in whatever order it deems optimal.</p>
        <p>For example, given the following grouped field set to be evaluated normally:</p><pre><code>{
  birthday {
    month
  },
  address {
    street
  }
}
</code></pre>
        <p>A valid GraphQL executor can resolve the four fields in whatever order it chose.</p>
      </section>
      <section id="sec-Serial-execution">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Serial-execution">6.4.3</a></span>Serial execution</h4>
        <p>Observe that based on the above sections, the only time an executor will run in serial execution order is on the top level selection set of a mutation operation and on its corresponding grouped field set.</p>
        <p>When evaluating a grouped field set serially, the executor must consider each entry from the grouped field set in the order provided in the grouped field set. It must determine the corresponding entry in the result map for each item to completion
          before it continues on to the next item in the grouped field set:</p>
        <p>For example, given the following selection set to be evaluated serially:</p><pre><code>{
  changeBirthday(birthday: $newBirthday) {
    month
  },
  changeAddress(address: $newAddress) {
    street
  }
}
</code></pre>
        <p>The executor must, in serial:</p>
        <ul>
          <li>Run <code>getFieldEntry</code> for <code>changeBirthday</code>, which during <code>CompleteValue</code> will evaluate the <code>{ month }</code> sub&#8208;selection set normally.</li>
          <li>Run <code>getFieldEntry</code> for <code>changeAddress</code>, which during <code>CompleteValue</code> will evaluate the <code>{ street }</code> sub&#8208;selection set normally.</li>
        </ul>
        <p>As an illustrative example, let&rsquo;s assume we have a mutation field <code>changeTheNumber</code> that returns an object containing one field, <code>theNumber</code>. If we execute the following selection set serially:</p><pre><code>{
  first: changeTheNumber(newNumber: 1) {
    theNumber
  },
  second: changeTheNumber(newNumber: 3) {
    theNumber
  },
  third: changeTheNumber(newNumber: 2) {
    theNumber
  },
}
</code></pre>
        <p>The executor will evaluate the following serially:</p>
        <ul>
          <li>Resolve the <code>changeTheNumber(newNumber: 1)</code> field</li>
          <li>Evaluate the <code>{ theNumber }</code> sub&#8208;selection set of <code>first</code> normally</li>
          <li>Resolve the <code>changeTheNumber(newNumber: 3)</code> field</li>
          <li>Evaluate the <code>{ theNumber }</code> sub&#8208;selection set of <code>second</code> normally</li>
          <li>Resolve the <code>changeTheNumber(newNumber: 2)</code> field</li>
          <li>Evaluate the <code>{ theNumber }</code> sub&#8208;selection set of <code>third</code> normally</li>
        </ul>
        <p>A correct executor must generate the following result for that selection set:</p><pre><code>{
  <span class="hljs-string">"first"</span>: {
    <span class="hljs-string">"theNumber"</span>: <span class="hljs-number">1</span>
  },
  <span class="hljs-string">"second"</span>: {
    <span class="hljs-string">"theNumber"</span>: <span class="hljs-number">3</span>
  },
  <span class="hljs-string">"third"</span>: {
    <span class="hljs-string">"theNumber"</span>: <span class="hljs-number">2</span>
  },
}
</code></pre></section>
      <section id="sec-Error-handling">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Error-handling">6.4.4</a></span>Error handling</h4>
        <p>If an error occurs when resolving a field, it should be treated as though the field returned null, and an error must be added to the &ldquo;errors&rdquo; list in the response.</p>
      </section>
      <section id="sec-Nullability">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Nullability">6.4.5</a></span>Nullability</h4>
        <p>If the result of resolving a field is null (either because the function to resolve the field returned null or because an error occurred), and that field is marked as being non&#8208;null in the type system, then the result of evaluating the entire
          field set that contains this field is now null.</p>
        <p>If the field was null because of an error, then the error has already been logged, and the &ldquo;errors&rdquo; list in the response must not be affected.</p>
        <p>If the field resolution function returned null, and the field was non&#8208;null, then no error has been logged, so an appropriate error must be added to the &ldquo;errors&rdquo; list. </p>
      </section>
    </section>
  </section>
  <section id="sec-Response">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Response">7</a></span>Response</h2>
    <p>When a GraphQL server receives a request, it must return a well&#8208;formed response. The server&rsquo;s response describes the result of executing the requested operation if successful, and describes any errors encountered during the request.</p>
    <p>A response may contain both a partial response as well as encountered errors in the case that an error occurred on a field which was replaced with null.</p>
    <section id="sec-Serialization-Format">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Serialization-Format">7.1</a></span>Serialization Format</h3>
      <p>GraphQL does not require a specific serialization format. However, clients should use a serialization format that supports the major primitives in the GraphQL response. In particular, the serialization format must support representations of the
        following four primitives:</p>
      <ul>
        <li>Map</li>
        <li>List</li>
        <li>String</li>
        <li>Null</li>
      </ul>
      <p>A serialization format may support the following primitives, however, strings may be used as a substitute for those primitives.</p>
      <ul>
        <li>Boolean</li>
        <li>Int</li>
        <li>Float</li>
        <li>Enum Value</li>
      </ul>
      <section id="sec-JSON-Serialization">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-JSON-Serialization">7.1.1</a></span>JSON Serialization</h4>
        <p>JSON is the preferred serialization format for GraphQL, though as noted above, GraphQL does not require a specific serialization format. For consistency and ease of notation, examples of the response are given in JSON throughout the spec. In particular,
          in our JSON examples, we will represent primitives using the following JSON concepts:</p>
        <table>
          <thead>
            <tr>
              <th>GraphQL Value </th>
              <th>JSON Value </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Map </td>
              <td>Object </td>
            </tr>
            <tr>
              <td>List </td>
              <td>Array </td>
            </tr>
            <tr>
              <td>Null </td>
              <td><span class="spec-keyword">null</span> </td>
            </tr>
            <tr>
              <td>String </td>
              <td>String </td>
            </tr>
            <tr>
              <td>Boolean </td>
              <td><span class="spec-keyword">true</span> or <span class="spec-keyword">false</span> </td>
            </tr>
            <tr>
              <td>Int </td>
              <td>Number </td>
            </tr>
            <tr>
              <td>Float </td>
              <td>Number </td>
            </tr>
            <tr>
              <td>Enum Value </td>
              <td>String </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section id="sec-Response-Format">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Response-Format">7.2</a></span>Response Format</h3>
      <p>A response to a GraphQL operation must be a map.</p>
      <p>If the operation included execution, the response map must contain an entry with key <code>data</code>. The value of this entry is described in the &ldquo;Data&rdquo; section. If the operation failed before execution, due to a syntax error, missing
        information, or validation error, this entry must not be present.</p>
      <p>If the operation encountered any errors, the response map must contain an entry with key <code>errors</code>. The value of this entry is described in the &ldquo;Errors&rdquo; section. If the operation completed without encountering any errors, this
        entry must not be present.</p>
      <p>The response map may also contain an entry with key <code>extensions</code>. This entry, if set, must have a map as its value. This entry is reserved for implementors to extend the protocol however they see fit, and hence there are no additional
        restrictions on its contents.</p>
      <p>To ensure future changes to the protocol do not break existing servers and clients, the top level response map must not contain any entries other than the three described above.</p>
      <section id="sec-Data">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Data">7.2.1</a></span>Data</h4>
        <p>The <code>data</code> entry in the response will be the result of the execution of the requested operation. If the operation was a query, this output will be an object of the schema&rsquo;s query root type; if the operation was a mutation, this
          output will be an object of the schema&rsquo;s mutation root type.</p>
        <p>If an error was encountered before execution begins, the <code>data</code> entry should not be present in the result.</p>
        <p>If an error was encountered during the execution that prevented a valid response, the <code>data</code> entry in the response should be <code>null</code>.</p>
      </section>
      <section id="sec-Errors">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Errors">7.2.2</a></span>Errors</h4>
        <p>The <code>errors</code> entry in the response is a non&#8208;empty list of errors, where each error is a map.</p>
        <p>If no errors were encountered during the requested operation, the <code>errors</code> entry should not be present in the result.</p>
        <p>Every error must contain an entry with the key <code>message</code> with a string description of the error intended for the developer as a guide to understand and correct the error.</p>
        <p>If an error can be associated to a particular point in the requested GraphQL document, it should contain an entry with the key <code>locations</code> with a list of locations, where each location is a map with the keys <code>line</code> and <code>column</code>,
          both positive numbers starting from <code>1</code> which describe the beginning of an associated syntax element.</p>
        <p>GraphQL servers may provide additional entries to error as they choose to produce more helpful or machine&#8208;readable errors, however future versions of the spec may describe additional entries to errors.</p>
        <p>If the <code>data</code> entry in the response is <code>null</code> or not present, the <code>errors</code> entry in the response must not be empty. It must contain at least one error. The errors it contains should indicate why no data was able
          to be returned.</p>
        <p>If the <code>data</code> entry in the response is not <code>null</code>, the <code>errors</code> entry in the response may contain any errors that occurred during execution. If errors occurred during execution, it should contain those errors.
          </p>
      </section>
    </section>
  </section>
  <section id="sec-Grammar">
    <h2><span class="spec-secnum" title="link to this section"><a href="#sec-Grammar">8</a></span>Grammar</h2>
    <p>A GraphQL document is defined in a syntactic grammar where terminal symbols are tokens. Tokens are defined in a lexical grammar which matches patterns of source characters. The result of parsing a sequence of source UTF&#8208;8 characters produces
      a GraphQL AST.</p>
    <p>Symbols are defined (ex. Symbol :) as either one sequence of symbols or a list of possible sequences of symbols, either as a bulleted list or using the &ldquo;one of&rdquo; short hand.</p>
    <p>A subscript suffix &ldquo;<span class="spec-nt optional">Symbol<span class="spec-mods"><span class="spec-mod optional">opt</span></span>
      </span>&rdquo; is shorthand for two possible sequences, one including that symbol and one excluding it.</p>
    <p>As an example:</p>
    <div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span>
      <div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-nt optional">Adverb<span class="spec-mods"><span class="spec-mod optional">opt</span></span>
        </span>
      </div>
    </div>
    <p>is shorthand for</p>
    <div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span>
      <div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span></div>
      <div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-nt">Adverb</span></div>
    </div>
    <p>A subscript suffix &ldquo;<span class="spec-nt list">Symbol<span class="spec-mods"><span class="spec-mod list">list</span></span>
      </span>&rdquo; is shorthand for a list of one or more of that symbol.</p>
    <p>As an example:</p>
    <div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span>
      <div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-nt list">Page<span class="spec-mods"><span class="spec-mod list">list</span></span>
        </span><span class="spec-nt">Cover</span></div>
    </div>
    <p>is shorthand for</p>
    <div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span>
      <div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Cover</span></div>
    </div>
    <div class="spec-production" id="Page_list"><span class="spec-nt"><a href="#Page_list">Page_list</a></span>
      <div class="spec-rhs"><span class="spec-nt">Page</span></div>
      <div class="spec-rhs"><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Page</span></div>
    </div>
    <p>A symbol definition subscript suffix parameter in braces &ldquo;<span class="spec-nt">Symbol<span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span>
      </span>
      </span>&rdquo; is shorthand for two symbol definitions, one appended with that parameter name, the other without. The same subscript suffix on a symbol is shorthand for that variant of the definition. If the parameter starts with &ldquo;?&rdquo;, that
      form of the symbol is used if in a symbol definition with the same parameter. Some possible sequences can be included or excluded conditionally when respectively prefixed with &ldquo;[+Param]&rdquo; and &ldquo;[~Param]&rdquo;.</p>
    <p>As an example:</p>
    <div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span>
      </span>
      </span>
      <div class="spec-rhs"><span class="spec-nt">A</span></div>
      <div class="spec-rhs"><span class="spec-nt">B<span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span>
        </span>
        </span>
      </div>
      <div class="spec-rhs"><span class="spec-nt">C<span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Param</span></span>
        </span>
        </span>
      </div>
      <div class="spec-rhs"><span class="spec-condition">Param</span><span class="spec-nt">D</span></div>
      <div class="spec-rhs"><span class="spec-condition not">Param</span><span class="spec-nt">E</span></div>
    </div>
    <p>is shorthand for</p>
    <div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span>
      <div class="spec-rhs"><span class="spec-nt">A</span></div>
      <div class="spec-rhs"><span class="spec-nt">B_param</span></div>
      <div class="spec-rhs"><span class="spec-nt">C</span></div>
      <div class="spec-rhs"><span class="spec-nt">E</span></div>
    </div>
    <div class="spec-production" id="Example_param"><span class="spec-nt"><a href="#Example_param">Example_param</a></span>
      <div class="spec-rhs"><span class="spec-nt">A</span></div>
      <div class="spec-rhs"><span class="spec-nt">B_param</span></div>
      <div class="spec-rhs"><span class="spec-nt">C_param</span></div>
      <div class="spec-rhs"><span class="spec-nt">D</span></div>
    </div>
    <section id="sec-Tokens">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Tokens">8.1</a></span>Tokens</h3>
      <p>A GraphQL document is comprised of several kinds of source tokens defined here in a lexical grammar and used as terminal symbols in GraphQL&rsquo;s syntactic grammar. This lexical grammar defines patterns of source characters by specifying character
        patterns in <span class="spec-t">monospace</span> or as <span class="spec-rx">/regular_expressions/</span>. Non&#8208;terminal patterns are defined as <span class="spec-nt">Italics</span>.</p>
      <p>The GraphQL document syntactic grammar is defined in terms of these lexical tokens:</p>
      <div class="spec-production" id="Token"><span class="spec-nt"><a href="#Token">Token</a></span>
        <div class="spec-rhs"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div>
      </div>
      <div class="spec-production oneof" id="Punctuator"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span>
        <table>
          <tr>
            <td class="spec-rhs"><span class="spec-t">!</span></td>
            <td class="spec-rhs"><span class="spec-t">$</span></td>
            <td class="spec-rhs"><span class="spec-t">(</span></td>
            <td class="spec-rhs"><span class="spec-t">)</span></td>
            <td class="spec-rhs"><span class="spec-t">...</span></td>
            <td class="spec-rhs"><span class="spec-t">:</span></td>
            <td class="spec-rhs"><span class="spec-t">=</span></td>
            <td class="spec-rhs"><span class="spec-t">@</span></td>
            <td class="spec-rhs"><span class="spec-t">[</span></td>
            <td class="spec-rhs"><span class="spec-t">]</span></td>
            <td class="spec-rhs"><span class="spec-t">{</span></td>
            <td class="spec-rhs"><span class="spec-t">|</span></td>
            <td class="spec-rhs"><span class="spec-t">}</span></td>
          </tr>
        </table>
      </div>
      <div class="spec-production" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span>
        <div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div>
      </div>
      <div class="spec-production" id="IntValue"><span class="spec-nt"><a href="#IntValue">IntValue</a></span>
        <div class="spec-rhs"><span class="spec-nt optional"><a href="#Sign">Sign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
          </span><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span></div>
      </div>
      <div class="spec-production" id="FloatValue"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span>
        <div class="spec-rhs"><span class="spec-nt optional"><a href="#Sign">Sign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
          </span><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-t">.</span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
          </span><span class="spec-nt optional"><a href="#ExponentPart">ExponentPart</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
          </span>
        </div>
      </div>
      <div class="spec-production" id="Sign"><span class="spec-nt"><a href="#Sign">Sign</a></span>
        <div class="spec-rhs"><span class="spec-t">-</span></div>
      </div>
      <div class="spec-production" id="IntegerPart"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span>
        <div class="spec-rhs"><span class="spec-t">0</span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
          </span>
        </div>
      </div>
      <div class="spec-production" id="ExponentPart"><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span>
        <div class="spec-rhs"><span class="spec-t">e</span><span class="spec-nt optional"><a href="#Sign">Sign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
          </span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
          </span>
        </div>
      </div>
      <div class="spec-production oneof" id="NonZeroDigit"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span>
        <table>
          <tr>
            <td class="spec-rhs"><span class="spec-t">1</span></td>
            <td class="spec-rhs"><span class="spec-t">2</span></td>
            <td class="spec-rhs"><span class="spec-t">3</span></td>
            <td class="spec-rhs"><span class="spec-t">4</span></td>
            <td class="spec-rhs"><span class="spec-t">5</span></td>
            <td class="spec-rhs"><span class="spec-t">6</span></td>
            <td class="spec-rhs"><span class="spec-t">7</span></td>
            <td class="spec-rhs"><span class="spec-t">8</span></td>
            <td class="spec-rhs"><span class="spec-t">9</span></td>
          </tr>
        </table>
      </div>
      <div class="spec-production" id="Digit"><span class="spec-nt"><a href="#Digit">Digit</a></span>
        <div class="spec-rhs"><span class="spec-t">0</span></div>
        <div class="spec-rhs"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span></div>
      </div>
      <div class="spec-production" id="StringValue"><span class="spec-nt"><a href="#StringValue">StringValue</a></span>
        <div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div>
        <div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-nt list"><a href="#StringCharacter">StringCharacter</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
          </span><span class="spec-t">&quot;</span></div>
      </div>
      <div class="spec-production" id="StringCharacter"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span>
        <div class="spec-rhs"><span class="spec-constrained"><span class="spec-prose">Any character</span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span>
          </span>
        </div>
        <div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div>
        <div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div>
      </div>
      <div class="spec-production" id="EscapedUnicode"><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span>
        <div class="spec-rhs"><span class="spec-t">u</span><span class="spec-rx">/[0-9A-Fa-f]{4}/</span></div>
      </div>
      <div class="spec-production oneof" id="EscapedCharacter"><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span>
        <table>
          <tr>
            <td class="spec-rhs"><span class="spec-t">&quot;</span></td>
            <td class="spec-rhs"><span class="spec-t">\</span></td>
            <td class="spec-rhs"><span class="spec-t">/</span></td>
            <td class="spec-rhs"><span class="spec-t">b</span></td>
            <td class="spec-rhs"><span class="spec-t">f</span></td>
            <td class="spec-rhs"><span class="spec-t">n</span></td>
            <td class="spec-rhs"><span class="spec-t">r</span></td>
            <td class="spec-rhs"><span class="spec-t">t</span></td>
          </tr>
        </table>
      </div>
      <section id="sec-Ignored-Source">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Ignored-Source">8.1.1</a></span>Ignored Source</h4>
        <p>Before every lexical token may be any amount of ignored source characters such as whitespace and comments. Whitespace, other than within strings, is not significant.</p>
        <p>GraphQL treats comma <code>,</code> similarly to whitespace. This ensures that the absence or presence of a comma does not meaningfully alter the interpreted syntax of the document which is a common user&#8208;error in other languages. It also
          allows for the stylistic use of trailing commas or line&#8208;breaks as delimiters which are often desired for legibility and maintainability of source code. The use of commas and other whitespace is suggested when it improves legibility.</p>
        <p>GraphQL ignores these character sequences:</p>
        <div class="spec-production" id="Ignored"><span class="spec-nt"><a href="#Ignored">Ignored</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Comment">Comment</a></span></div>
          <div class="spec-rhs"><span class="spec-t">,</span></div>
        </div>
        <div class="spec-production" id="WhiteSpace"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span>
          <div class="spec-rhs"><span class="spec-prose">Horizontal Tab (U+0009)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Vertical Tab (U+000B)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Form Feed (U+000C)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Space (U+0020)</span></div>
          <div class="spec-rhs"><span class="spec-prose">No-break Space (U+00A0)</span></div>
        </div>
        <div class="spec-production" id="LineTerminator"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span>
          <div class="spec-rhs"><span class="spec-prose">New Line (U+000A)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Line Separator (U+2028)</span></div>
          <div class="spec-rhs"><span class="spec-prose">Paragraph Separator (U+2029)</span></div>
        </div>
        <div class="spec-production" id="Comment"><span class="spec-nt"><a href="#Comment">Comment</a></span>
          <div class="spec-rhs"><span class="spec-t">#</span><span class="spec-nt list optional"><a href="#CommentChar">CommentChar</a><span class="spec-mods"><span class="spec-mod list">list</span><span class="spec-mod optional">opt</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="CommentChar"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span>
          <div class="spec-rhs"><span class="spec-constrained"><span class="spec-prose">Any character</span><span class="spec-butnot"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span>
            </span>
          </div>
        </div>
      </section>
    </section>
    <section id="sec-Syntax">
      <h3><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax">8.2</a></span>Syntax</h3>
      <p>A GraphQL document is defined in a syntactic grammar where terminal symbols are expressed as either an italicized token (ex. <span class="spec-nt"><a href="#Document">Document</a></span>) or as monospaced short&#8208;hand for a <span class="spec-nt"><a href="#Punctuator">Punctuator</a></span>        (ex. <span class="spec-t">:</span>) or <span class="spec-nt"><a href="#Name">Name</a></span> (ex. <span class="spec-t">query</span>).</p>
      <section id="sec-Syntax.Document">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax.Document">8.2.1</a></span>Document</h4>
        <p>A GraphQL document describes a complete file or request string. A document contains multiple definitions including an Operation.</p>
        <div class="spec-production" id="Document"><span class="spec-nt"><a href="#Document">Document</a></span>
          <div class="spec-rhs"><span class="spec-nt list"><a href="#Definition">Definition</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="Definition"><span class="spec-nt"><a href="#Definition">Definition</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span></div>
        </div>
      </section>
      <section id="sec-Syntax.Operations">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax.Operations">8.2.2</a></span>Operations</h4>
        <p>An operation describes some type of request to GraphQL. The most common operation is a <code>query</code>, a read&#8208;only request for data from GraphQL. A short&#8208;hand syntax exists for a query operation.</p>
        <div class="spec-production"
        id="OperationDefinition"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#VariableDefinitions">VariableDefinitions</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div>
        </div>
        <div class="spec-production oneof" id="OperationType"><span class="spec-nt"><a href="#OperationType">OperationType</a></span>
          <table>
            <tr>
              <td class="spec-rhs"><span class="spec-t">query</span></td>
              <td class="spec-rhs"><span class="spec-t">mutation</span></td>
            </tr>
          </table>
        </div>
        <div class="spec-production" id="VariableDefinitions"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span>
          <div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#VariableDefinition">VariableDefinition</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
            </span><span class="spec-t">)</span></div>
        </div>
        <div class="spec-production" id="VariableDefinition"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Variable">Variable</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-nt optional"><a href="#DefaultValue">DefaultValue</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="Variable"><span class="spec-nt"><a href="#Variable">Variable</a></span>
          <div class="spec-rhs"><span class="spec-t">$</span><span class="spec-nt"><a href="#Name">Name</a></span></div>
        </div>
        <div class="spec-production" id="DefaultValue"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span>
          <div class="spec-rhs"><span class="spec-t">=</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span>
            </span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="SelectionSet"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span>
          <div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#Selection">Selection</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
            </span><span class="spec-t">}</span></div>
        </div>
        <div class="spec-production" id="Selection"><span class="spec-nt"><a href="#Selection">Selection</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Field">Field</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span></div>
        </div>
        <div class="spec-production" id="Field"><span class="spec-nt"><a href="#Field">Field</a></span>
          <div class="spec-rhs"><span class="spec-nt optional"><a href="#Alias">Alias</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt optional"><a href="#SelectionSet">SelectionSet</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="Alias"><span class="spec-nt"><a href="#Alias">Alias</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span></div>
        </div>
        <div class="spec-production" id="Arguments"><span class="spec-nt"><a href="#Arguments">Arguments</a></span>
          <div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#Argument">Argument</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
            </span><span class="spec-t">)</span></div>
        </div>
        <div class="spec-production" id="Argument"><span class="spec-nt"><a href="#Argument">Argument</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a></span></div>
        </div>
      </section>
      <section id="sec-Syntax.Fragments">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax.Fragments">8.2.3</a></span>Fragments</h4>
        <p>Fragments allow for the reuse of common selections of fields, reducing duplicated text in the document. Inline fragments can be used directly inline a selection to apply a type condition when querying against an interface or union.</p>
        <div class="spec-production"
        id="FragmentSpread"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span>
          <div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="InlineFragment"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span>
          <div class="spec-rhs"><span class="spec-t">...</span><span class="spec-t">on</span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div>
        </div>
        <div class="spec-production" id="FragmentDefinition"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span>
          <div class="spec-rhs"><span class="spec-t">fragment</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-t">on</span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div>
        </div>
        <div class="spec-production" id="FragmentName"><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span>
          <div class="spec-rhs"><span class="spec-lookahead not"><span class="spec-t">on</span></span><span class="spec-nt"><a href="#Name">Name</a></span></div>
        </div>
        <div class="spec-production" id="TypeCondition"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#TypeName">TypeName</a></span></div>
        </div>
      </section>
      <section id="sec-Values">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Values">8.2.4</a></span>Values</h4>
        <p>Fields may take values for arguments. A value may be any JSON&#8208;style value, a variable or an Enum value.</p>
        <div class="spec-production" id="Value"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span>
          </span>
          </span>
          <div class="spec-rhs"><span class="spec-condition not">Const</span><span class="spec-nt"><a href="#Variable">Variable</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#ArrayValue">ArrayValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span>
            </span>
            </span>
          </div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span>
            </span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="BooleanValue"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span>
          <div class="spec-rhs"><span class="spec-t">true</span></div>
          <div class="spec-rhs"><span class="spec-t">false</span></div>
        </div>
        <div class="spec-production" id="EnumValue"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div>
        </div>
        <section id="sec-Array-Value">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Array-Value">8.2.4.1</a></span>Array Value</h5>
          <div class="spec-production" id="ArrayValue"><span class="spec-nt"><a href="#ArrayValue">ArrayValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span>
            </span>
            </span>
            <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div>
            <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span>
              </span><span class="spec-t">]</span></div>
          </div>
          <p><strong>Semantics</strong></p>
          <div class="spec-semantic"><span class="spec-nt"><a href="#ArrayValue">ArrayValue</a></span>
            <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div>
            <ol>
              <li>Return a new empty list value.</li>
            </ol>
          </div>
          <div class="spec-semantic"><span class="spec-nt"><a href="#ArrayValue">ArrayValue</a></span>
            <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
              </span><span class="spec-t">]</span></div>
            <ol>
              <li>Let <var>inputList</var> be a new empty list value.</li>
              <li>For each <span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
                </span>
                <ol>
                  <li>Let <var>value</var> be the result of evaluating <span class="spec-nt"><a href="#Value">Value</a></span>.</li>
                  <li>Append <var>value</var> to <var>inputList</var>.</li>
                </ol>
              </li>
              <li>Return <var>inputList</var></li>
            </ol>
          </div>
        </section>
        <section id="sec-Object-Value">
          <h5><span class="spec-secnum" title="link to this section"><a href="#sec-Object-Value">8.2.4.2</a></span>Object Value</h5>
          <div class="spec-production" id="ObjectValue"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span>
            </span>
            </span>
            <div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div>
            <div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span>
              </span><span class="spec-t">}</span></div>
          </div>
          <div class="spec-production" id="ObjectField"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span>
            </span>
            </span>
            <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span>
              </span>
              </span>
            </div>
          </div>
          <p><strong>Semantics</strong></p>
          <div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span>
            <div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div>
            <ol>
              <li>Return a new input object value with no fields.</li>
            </ol>
          </div>
          <div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span>
            <div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
              </span><span class="spec-t">}</span></div>
            <ol>
              <li>Let <var>inputObject</var> be a new input object value with no fields.</li>
              <li>For each <var>field</var> in <span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
                </span>
                <ol>
                  <li>Let <var>name</var> be <span class="spec-nt"><a href="#Name">Name</a></span> in <var>field</var>.</li>
                  <li>If <var>inputObject</var> contains a field named <var>name</var> throw Syntax Error.</li>
                  <li>Let <var>value</var> be the result of evaluating <span class="spec-nt"><a href="#Value">Value</a></span> in <var>field</var>.</li>
                  <li>Add a field to <var>inputObject</var> of name <var>name</var> containing value <var>value</var>.</li>
                </ol>
              </li>
              <li>Return <var>inputObject</var></li>
            </ol>
          </div>
        </section>
      </section>
      <section id="sec-Syntax.Directives">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax.Directives">8.2.5</a></span>Directives</h4>
        <p>Directives provide a way to describe runtime execution and type validation behavior in a GraphQL document.</p>
        <div class="spec-production" id="Directives"><span class="spec-nt"><a href="#Directives">Directives</a></span>
          <div class="spec-rhs"><span class="spec-nt list"><a href="#Directive">Directive</a><span class="spec-mods"><span class="spec-mod list">list</span></span>
            </span>
          </div>
        </div>
        <div class="spec-production" id="Directive"><span class="spec-nt"><a href="#Directive">Directive</a></span>
          <div class="spec-rhs"><span class="spec-t">@</span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span>
            </span>
          </div>
        </div>
      </section>
      <section id="sec-Syntax.Types">
        <h4><span class="spec-secnum" title="link to this section"><a href="#sec-Syntax.Types">8.2.6</a></span>Types</h4>
        <p>GraphQL describes the schema of the data it provides using a type system. These types are referred to in the document when defining query variables.</p>
        <div class="spec-production" id="Type"><span class="spec-nt"><a href="#Type">Type</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#TypeName">TypeName</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span></div>
        </div>
        <div class="spec-production" id="TypeName"><span class="spec-nt"><a href="#TypeName">TypeName</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div>
        </div>
        <div class="spec-production" id="ListType"><span class="spec-nt"><a href="#ListType">ListType</a></span>
          <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div>
        </div>
        <div class="spec-production" id="NonNullType"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#TypeName">TypeName</a></span><span class="spec-t">!</span></div>
          <div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span><span class="spec-t">!</span></div>
        </div>
        <p><strong>Semantics</strong></p>
        <div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div>
          <ol>
            <li>Let <var>name</var> be the string value of <span class="spec-nt"><a href="#Name">Name</a></span></li>
            <li>Let <var>type</var> be the type defined in the Schema named <var>name</var></li>
            <li><var>type</var> must not be <span class="spec-keyword">null</span></li>
            <li>Return <var>type</var></li>
          </ol>
        </div>
        <div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span>
          <div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div>
          <ol>
            <li>Let <var>itemType</var> be the result of evaluating <span class="spec-nt"><a href="#Type">Type</a></span></li>
            <li>Let <var>type</var> be a List type where <var>itemType</var> is the contained type.</li>
            <li>Return <var>type</var></li>
          </ol>
        </div>
        <div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span>
          <div class="spec-rhs"><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">!</span></div>
          <ol>
            <li>Let <var>nullableType</var> be the result of evaluating <span class="spec-nt"><a href="#Type">Type</a></span></li>
            <li>Let <var>type</var> be a Non&#8208;Null type where <var>nullableType</var> is the contained type.</li>
            <li>Return <var>type</var> </li>
          </ol>
        </div>
      </section>
    </section>
  </section>
  <footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer>
</body>

</html>